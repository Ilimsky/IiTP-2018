<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="answers" formatted="false">
        <!--1-->
        <item>1.ПОНЯТИЕ АЛГОРИТМА. ПОДХОДЫ К ОПРЕДЕЛЕНИЮ АЛГОРИТМА. СВОЙСТВО АЛГОРИТМА.\n\n
Понятие алгоритма является одним из основных понятий современных математики и информатики, но зародилось оно еще в глубокой древности. Термин алгоритм происходит от имени средневекового узбекского математика Аль Хорезми (IX в.), который сформулировал правила выполнения четырех арифметических действий в десятичной системе счисления.\n\n
В современной информатике используется следующее определение алгоритма. Алгоритмом называют систему четких однозначных указаний, которые определяют последовательность действий над некоторыми объектами и после конечного числа шагов приводят к получению требуемого результата.\n\n
Подходы к определению алгоритма:
Слово алгоритм происходит от algorithmi – латинской формы написания имени великого математика IX в. Аль Хорезми, который сформулировал правила выполнения арифметических действий. Первоначально под алгоритмами и понимали только правила выполнения четырех арифметических действий над многозначными числами. В дальнейшем это понятие стали использовать вообще для обозначения последовательности действий, приводящих к решению поставленной задачи.\n\n
Свойства алгоритма\n
1. Дискретность алгоритма предполагает, что решение задачи (т.е. алгоритм) разбито на отдельные шаги (операции, команды) и переход к следующему шагу возможен только после выполнения предыдущего.
\n
2. Определенность (точность) алгоритма предполагает, что каждая его команда должна однозначно определять действие исполнителя алгоритма (записанные в алгоритме команды должны иметь однозначную трактовку).
\n
3. Понятность алгоритма подразумевает, что он должен включать в себя только те шаги или команды, которые понятны исполнителю (в алгоритме не могут присутствовать команды, смысл которых неизвестен исполнителю).
\n
4. Результативность (конечность) предполагает, что алгоритм должен быть нацелен на получение конечного результата, т.е. исполнение алгоритма должно закончиться за конечное число шагов.
\n
5. Массовость алгоритма подразумевает, что алгоритм должен быть пригоден для решения целого класса однотипных задач (а не только для одной конкретной задачи).
\n\n
Основные способы записи алгоритмов
\n
1. Словесный способ, т.е. описание алгоритма на естественном языке (словами).\n
2. Формульно-словесный способ, в котором кроме слов могут использоваться математические формулы.\n
3. Графический способ, т.е. в виде блок-схемы.\n
4. Программный способ, т.е. в виде программы на алгоритмическом языке.\n
</item>
        <!--2-->
        <item>2.СТРУКТУРА ПРОГРАММЫ, ЭЛЕМЕНТЫ ЯЗЫКА С++. ПОНЯТИЕ ТИПА ДАННЫХ.\n\n\n\n
Структура программы на языке С++ \n
Программа на языке C++ состоит из функций, описаний и директив препроцессора.\n
(Препроцессор — это программа, которая выполняет обработку файла исходного кода перед началом компиляции).\n
Рассмотрим простейшую программу:\n
#include &lt;Ciostream>\n
using namespace std;\n
int main()\n
{\n
cout &lt;&lt; "Hello world!" &lt;&lt; end1;\n
return 0;\n
}\n
В первой строке с помощью директивы #include подключается заголовочный файл &lt;iostream>, который содержит необходимую информацию для управления вводом/выводом.\n
Следующая директива using открывает доступ к пространству имен (англ. namespace) std, в котором определяются средства стандартной библиотеки языка C++.\n
(Пространство имён — некоторое множество, созданное для логической группировки уникальных идентификаторов).\n
Отправной точкой выполнения любой С++-программы является функция main(). Функция содержит четыре элемента:\n
•	возвращаемый тип (в нашем случае int);\n
•	имя функции (main);\n
•	список параметров, заключенный в круглые скобки (в данном случае список пуст);\n
•	заключенное в фигурные скобки, тело функции, представляющее собой блок инструкций.\n\n
Инструкцией называется часть программы, определяющая действие и не являющаяся директивой препроцессора.\n
В нашей программе тело функции содержит две инструкции:\n
•	cout  "Hello, World!";\n
•	return 0;\n
Во-первых, выводится на экран строка Hello, World, а затем возвращается в точку вызова значение 0, которое означает, что программа выполнена успешно.\n
Обратим внимание на то, что каждая инструкция в языке С++ заканчивается точкой с запятой. Существуют следующие исключения:\n
•	директивы препроцессора, начинающиеся с символа # (например, #include);\n
•	составные операторы и блоки определения функций, которые обрамлены фигурными скобками — { }.\n\n

Элементы языка С++\n
Начнем изучение языка С++ с рассмотрения состава и основных конструкций необходимых для написания программ.\n
Алфавит языка\n
Алфавит языка программирования C++ включает:\n
•	прописные и строчные латинские буквы, и знак подчеркивания;\n
•	арабские цифры от 0 до 9;\n
•	специальные знаки: " { } , | [ ] ( ) + - / % * . \ ? &lt; = > ! &amp; # - ; ' '\n
•	пробельные символы: пробел, символы табуляции, символы перехода на новую строку.\n\n
Из символов алфавита формируются лексемы языка (минимальная единица языка, имеющая самостоятельный смысл):\n
o	идентификаторы;\n
o	ключевые слова;\n
o	знаки операций;\n
o	константы;\n
o	разделители (скобки, точка, запятая, пробельные символы).\n\n

Идентификаторы\n
Идентификатор — это имя программного объекта\n
Первым символом в идентификаторе может быть буква или знак подчеркивания. Внутри идентификаторов не допускается использование пробелов.\n
Например: v1, _sum\n\n

При выборе идентификатора следует иметь в виду следующее:\n
•	идентификатор не должен совпадать с ключевыми словами и именами используемых стандартных объектов языка;\n
•	не рекомендуется начинать идентификаторы с символа подчеркивания, т. к. в этом случае они могут совпасть с именами системных функций или переменных.\n\n

Ключевые слова\n
Ключевые слова — это зарезервированные идентификаторы, которые имеют специальное значение для компилятора.\n

Таблица1. Список ключевых слов C++\n
asm auto bool break case catch char class const\n
const_cast continue default delete do double\n
dynamic_cast else enum explicit export extern\n
false float for friend goto if inline int long\n
mutable namespace new operator private protected\n
public register reinterpret_cast return short\n
signed sizeof static static__cast struct switch\n
template this throw true try typedef typeid typename\n
union unsigned using virtual void volatile wchar_t while\n\n

Знаки операций\n
Знак операции — это один или более символов, определяющих действие над операндами.
Операции делятся на унарные, бинарные и тернарную по количеству участвующих в них операндов. Один и тот же знак может интерпретироваться по-разному в зависимости от контекста.\n\n

Константы\n
Константами называют неизменяемые величины.\n
Различаются целые, вещественные, символьные и строковые константы. Компилятор, выделив константу в качестве лексемы, относит ее к одному из типов по ее внешнему виду.\n\n

Комментарии\n
Комментарии используются для пояснения отдельных частей или всей программы. Отметим, что компилятор игнорирует комментарии.\n
В языке С++ используется две формы комментариев:\n
•	комментарий начинается с двух символов «прямая косая черта» // и заканчивается символом перехода на новую строку\n
•	комментарий заключается между символами-скобками /* ... */\n\n

Внимание! Вложенные комментарии-скобки стандартом не допускаются.\n
Внутри комментария можно использовать любые допустимые на данном компьютере символы.\n\n

Типы данных С++\n
Любая программа в ходе работы обрабатывает данные. Хранение и обработка данных зависит от их типа. Каждая константа, переменная, результат вычисления выражения или функции должны иметь определенный тип.\n\n

Тип данных определяет:\n
•	представление данных в памяти компьютера;\n
•	множество значений, которые могут принимать величины данного типа;\n
•	операции и функции, которые можно применять к величинам этого типа.\n\n

Все типы языка C++ можно разделить на основные и составные.\n
Основные типы данных используются для представления целых, вещественных, символьных и логических величин. К составным типам относятся массивы, перечисления, функции, структуры, ссылки, указатели, объединения и классы.\n\n

Основные типы данных\n
Для описания основных типов данных определены следующие ключевые слова:\n
•	int (целый);\n
•	char (символьный);\n
•	wchar_t (расширенный символьный);\n
•	bool (логический);\n
•	float (вещественный);\n
•	double (вещественный с двойной точностью).\n\n

Для уточнения диапазона значений и внутреннего представления стандартных типов применяются четыре спецификатора типа:\n
•	short (короткий);\n
•	long (длинный);\n
•	signed (знаковый);\n
•	unsigned (беззнаковый).\n\n

Типичные размеры значений и диапазоны представлений\n
Тип: bool\n
Размер (байт): 1\n
Диапазон значений: true, false\n
Замечания: Внутренняя форма представления значения false - 0. Любое другое значение интерпретируется как true.\n\n

Тип: signed char\n
Размер (байт): 1\n
Диапазон значений: -128 ... 127\n
Замечания: Используются для хранения 8-разрядных ASCII-символов либо любых других 8-разрядных значений.\n\n

Тип: unsigned char\n
Размер (байт): 1\n
Диапазон значений: 0 ... 255\n
Замечания: Используются для хранения 8-разрядных ASCII-символов либо любых других 8-разрядных значений.\n\n

Тип: signed short int\n
Размер (байт): 2\n
Диапазон значений: -32768 ... 32767\n
Замечания: Спецификатор signed указывает рассматривать старший бит числа как знаковый (0 - положительное число, 1 - отрицательное). По умолчанию целочисленные типы считаются знаковыми (спецификатор signed можно опускать). При использовании спецификатора unsigned старший разряд рассматривается как часть кода числа, поэтому представляются только положительные числа.\n\n

Тип: unsigned short int\n
Размер (байт): 2\n
Диапазон значений: 0 ... 65535\n
Замечания: Спецификатор signed указывает рассматривать старший бит числа как знаковый (0 - положительное число, 1 - отрицательное). По умолчанию целочисленные типы считаются знаковыми (спецификатор signed можно опускать). При использовании спецификатора unsigned старший разряд рассматривается как часть кода числа, поэтому представляются только положительные числа.\n\n

Тип: signed long int\n
Размер (байт): 4\n
Диапазон значений: -2 147 483 648 ... 2 147 483 647\n
Замечания: Спецификатор signed указывает рассматривать старший бит числа как знаковый (0 - положительное число, 1 - отрицательное). По умолчанию целочисленные типы считаются знаковыми (спецификатор signed можно опускать). При использовании спецификатора unsigned старший разряд рассматривается как часть кода числа, поэтому представляются только положительные числа.\n\n

Тип: unsigned long int\n
Размер (байт): 4\n
Диапазон значений: 0 ... 4 294 967 295\n
Замечания: Спецификатор signed указывает рассматривать старший бит числа как знаковый (0 - положительное число, 1 - отрицательное). По умолчанию целочисленные типы считаются знаковыми (спецификатор signed можно опускать). При использовании спецификатора unsigned старший разряд рассматривается как часть кода числа, поэтому представляются только положительные числа.\n\n

Тип: float\n
Размер (байт): 4\n
Диапазон значений: 3.4e-38 ... 3.4e+38\n
Замечания: Типы данных с плавающей точкой. Эти типы хранятся в памяти компьютера иначе, чем целочисленные: представление вещественного числа состоит из двух частей — мантиссы и порядка. Константы с плавающей точкой имеют по умолчанию тип double.\n\n

Тип: double\n
Размер (байт): 8\n
Диапазон значений: 1.7e-308 ... 1.7e+308\n
Замечания: Типы данных с плавающей точкой. Эти типы хранятся в памяти компьютера иначе, чем целочисленные: представление вещественного числа состоит из двух частей — мантиссы и порядка. Константы с плавающей точкой имеют по умолчанию тип double.\n\n

Тип: long double\n
Размер (байт):8\n
Диапазон значений: 3.4e-4932 ... 3.4e+4932\n
Замечания: Типы данных с плавающей точкой. Эти типы хранятся в памяти компьютера иначе, чем целочисленные: представление вещественного числа состоит из двух частей — мантиссы и порядка. Константы с плавающей точкой имеют по умолчанию тип double.\n\n

Константам, встречающимся в программе, компилятор приписывает тот или иной тип в соответствии с их видом. Можно явно указать требуемый тип с помощью соответствующих суффиксов:\n
•	Для целых типов:\n
L, l (long) и u, U (unsigned). Например, 50L будет иметь тип long. Суффиксы L и U можно использовать одновременно, например: 105LU.\n
•	Для вещественных типов:\n
F, f (float) и L, l (long). Например, константа 3e+5L будет иметь тип long double, а константа 1.82f — тип float.\n\n

Тип void\n
К основным типам языка С++ относится также тип void. Множество значений этого типа пусто. Он применяется для определения функций, которые не возвращают значения, для указания пустого списка аргументов функции, как базовый тип для указателей и в операции приведения типов.
</item>
        <!--3-->
        <item>3.ОПЕРАЦИИ (АРИФМЕТИЧЕСКИЕ, ЛОГИЧЕСКИЕ) НА ТИПАХ. СТАНДАРТНЫЕ ФУНКЦИИ. ВЫРАЖЕНИЯ.\n\n
Операции. Арифметические операции\n
1. Какие арифметические операции используются в языке C/C++?\n
В языке C++ поддерживаются следующие арифметические операции:\n
+ – сложение;\n
- – вычитание;\n
* – умножение;\n
/ – деление;\n
% – остаток от деления.\n
Все эти операции являются бинарными. Это означает, что для получения результата, нужно 2 операнда. Общий вид арифметической операции:\n
операнд1 операция операнд2\n
где операция – одна из операций +, —, *, %, /.\n\n
            2. Для каких типов данных можно применять арифметические операции?\n
Арифметические операции можно применять для:\n
•  целочисленных типов: short int, unsigned short int, int, unsigned int, long, unsigned long;\n
•  типов с плавающей запятой (вещественных типов): float, double, long double;\n
•  типов (классов), которые содержат «перегруженные» арифметические операции.\n
В арифметических операциях один из операндов может иметь целочисленный тип, а второй быть типом с плавающей запятой. В этом случае результат имеет тип с плавающей запятой.\n\n
3. Как осуществляется приведение типов в операциях +, —, *?\n
В выражениях, где используются операции +, —, *, действуют следующие правила приведения типа результата:\n
•  если оба операнда имеют целый тип, то результат также будет целого типа;\n
•  если хотя бы один из операндов имеет вещественный (с плавающей запятой) тип а другой целый тип, то результат также будет вещественного типа;\n
•  если один из операндов имеет тип float, а другой тип double, то результат будет типа double. Это связано с тем, что тип double требует больше памяти чем тип float. В этом случае происходит расширение типа float к типу double.\n\n
4. Какой приоритет и ассоциативность арифметических операций?\n
Арифметические операции имеют приоритет и ассоциативность, как изображено в следующей таблице.
Знаки операций Наименование   Ассоциативность\n
*   /   %  Бинарные, мультипликативные    Слева направо\n
+   —  Бинарные, аддитивные   Слева направо\n\n
5. Какое отличие между бинарными и унарными операциями сложения (+) и вычитания (—)?\n
Операции сложения (+) и вычитания (—) могут быть как бинарными, так и унарными.\n
Бинарные операции + и — используются в выражениях при проведении вычислений.\n
Унарные операции + и — используются для обозначения знака числа (положительное число или отрицательное число).\n
Пример.\n
int a, b;\n
a = -8; // унарная операция \'-\', обозначает знак числа\n
b = +9; // унарная операция \'+\', b = 9\n
a = b-5; // бинарная операция \'-\', используется для вычисления выражения\n\n
6. Какие особенности использования операции % (остаток от деления)?\n
Операция % используется над целыми операндами. Операция % позволяет получить остаток от деления целых операндов.\n
Пример.\n
// Операция % - взятие остатка от деления\n
int a, b;\n
int c;\n
a = 3;\n
b = 5;\n
c = a % b;   // c = 3\n
a = 8;\n
b = 4;\n
c = a % b;   // c = 0\n
c = 12 % 35; // c = 12\n
c = 35 % 12; // c = 11\n
c = -5 % -3; // c = -2\n\n
7. Какие особенности использования операции / (деление)?\n
Операция деления имеет свои особенности, которые состоят в следующем:\n
•  если два операнда имеют целочисленный тип, то результат возвращается целого типа. В этом случае происходит деление нацело. Остаток от деления урезается;\n
•  если один из операндов имеет тип с плавающей запятой, тогда результат имеет также тип с плавающей запятой.\n
Пример.\n
// Операция деления \'/\'\n
int a, b;\n
int c;\n
float x;\n
a = 8;\n
b = 3;\n
c = a / b; // c = 2\n
x = a / b; // x = 2.0\n
x = a / (float)b; // x = 2.666667\n
x = 17.0 / 3; // x = 5.666667\n
x = 17 / 3;   // x = 5.0\n\n
C++. Логические операции. Поразрядные логические операции. Операции сдвига. Операция XOR\n
1. Для каких типов можно применять логические операции, поразрядные логические операции и операции сдвига?\n
Логические операции, поразрядные логические операции и операции сдвига можно использовать только для операндов целых типов.\n
2. Какие логические операции используются в C++?\n
В языке программирования C++ используются следующие логические операции:\n
•  &amp;&amp; – логическое «И»;\n
•  || – логическое «ИЛИ»;\n
•  ! – логическое «НЕТ».\n
Результатом логических операций есть значение false или true. В языке C++ принято, что значение false считается равным 0, а значение true считается равным 1.\n
Отсюда можно сделать вывод, что false &lt; true. Например:\n
// логические операции\n
bool res;\n
res = false &lt; true; // res = true\n\n
3. Таблица истинности логических операций\n
Таблица истинности логических операций &amp;&amp; (логическое «И»), || (логическое «ИЛИ»), ! (логическое «НЕТ») имеет следующий вид:\n
a b a&amp;&amp;b a||b !a !b\n
false false false false true true\n
false true false true true false\n
true false false true false true\n
true true true true false false\n

В языке C++ принимается, что значение false равно 0, а значение true не равно 0 (любое ненулевое целочисленное значение).\n\n
4. Примеры использования логических операций в C++\n
Пример 1. Логическая операция в сочетании с логическим выражением\n
// логические операции\n
bool res;\n
int a, b;\n
// операция &amp;&amp; (AND)\n
a = 8;\n
b = 5;\n
res = a &amp;&amp; b; // res = True\n
a = 0;\n
res = a &amp;&amp; b; // res = False\n
// операция || (OR)\n
a = 0;\n
b = 0;\n
res = a || b; // res = False\n
b = 7;\n
res = a || b; // res = True\n\n
// операция ! (логическое "НЕТ")\n
a = 0;\n
res = !a; // res = True\n
a = 15;\n
res = !a; // res = False\n\n
Пример 2. Логическая операция в условных выражениях. Приведен фрагмент кода, в котором логическая операция используется в операторе условного перехода if.\n
// логические операции в условных выражениях\n
int a, b;\n
bool res;\n
a = 0;\n
b = 3;\n
res = false;\n
if (a &amp;&amp; b)\n
res = true; // res = false\n
a = 0;\n
b = 7;\n
if (a || b)\n
res = true; // res = true\n\n
5. Какие поразрядные логические операции используются в C++?\n
Язык С++ поддерживает следующие поразрядные логические операции:\n
•  &amp; – поразрядное логическое И (AND);\n
•  ^ – поразрядное сложение по модулю 2 (XOR — исключающее ИЛИ);\n
•  | – поразрядное логическое ИЛИ (OR);\n
•  ~ – поразрядная инверсия (NOT).\n
Операции &amp;, ^, | есть бинарными. Это означает, что они требуют двух операндов. Биты любого операнда сравниваются между собой по следующему правилу: бит в позиции 0 первого операнда сравнивается с битом в позиции 0 второго операнда. Затем бит в позиции 1 первого операнда сравнивается с битом в позиции 1 второго операнда. Так сравниваются все биты целочисленных операндов.\n\n
6. Таблица истинности поразрядных логических операций\n
Каждый бит результата определяется на основе двух операндов, которые являются битами, так как показано в таблице.\n
бит1 бит2 &amp; || ^ ~бит1 ~бит2\n
0 0 0 0 0 1 1\n
0 1 0 1 1 1 0\n
1 0 0 1 1 0 1\n
1 1 1 1 0 0 0\n

Инверсия требует единого операнда справа от знака ~. Результат получается поразрядной инверсией всех битов операнда.\n\n
7. Пример работы с логическими побитовыми операциями\n
Пусть даны два числа 17 и 45 типа unsigned short int. Каждое из чисел занимает в памяти 1 байт или 8 бит. Ниже приведен пример того, как происходит вычисление для каждой побитовой операции\n
  128 64 32 16 8 4 2 1\n
17 =       0 0 0 1 0 0 0 1\n
45 =       0 0 1 0 1 1 0 1\n
17&amp;45 = 0 0 0 0 0 0 0 1 = 1\n
17|45 =  0 0 1 1 1 1 0 1 = 61\n
17^45 = 0 0 1 1 1 1 0 0 = 60\n
~17 =     1 1 1 0 1 1 1 0 = 238\n

Как видно из примера, происходит выполнение заданной операции над каждым битом.\n\n
8. Какие операции сдвига используются в C++?\n
Язык С++ включают две операции поразрядного сдвига:\n
•  &lt;&lt; – сдвиг влево значения операнда на заданное количество бит. Операнд размещается слева от знака операции. Число сдвигаемых бит указывается справа от знака операции;\n
•  >> – сдвиг вправо значения операнда на заданное количество бит. Операнд размещается слева от знака операции (&lt;&lt;). Количество сдвигаемых бит размещается справа от знака операции.\n
Выдвижные биты теряются, а «входят» нулевые биты. Сдвиг операндов влево на 1, 2, 3 и более разрядов – наиболее быстрый способ умножения на 2, 4, 8, … Сдвиг операндов вправо на 1, 2, 3 и более разрядов – наиболее быстрый способ деления на 2, 4, 8, …\n
Если в программе нужно, чтобы операция умножения целочисленных операндов на 2, 4, 8 и т.д. происходила максимально быстро, то целесообразно использовать операцию сдвига влево.\n
Это касается и случаев, когда нужно максимально быстро поделить целочисленный операнд на 2, 4, 8 и т.д. В этих случаях рекомендуется использовать сдвиг вправо.\n\n
9. Примеры использования операций сдвига в программе
\\// Операции сдвига\n
int a;\n
int b;\n
int c;\n
a = 15;\n
b = -5;\n

// сдвиг влево - умножение\n
c = a &lt;&lt; 1; // c = a * 2^1 = 30\n
c = b &lt;&lt; 2; // c = b * 2^2 = -20\n

// сдвиг вправо - деление\n
c = a >> 3; // c = a / 2^3 = 1\n
c = b >> 1; // c = b / 2^1 = -3\n\n
10. Какое отличие между логическими операциями и поразрядными логическими операциями?\n
В логических операциях сравнивается значение двух операндов целиком. Каждый из операндов может иметь значение true или false. Язык C++ допускает сравнение операндов, которые являются целыми числами. В этом случае целочисленное значение 0 соответствует значению false, а ненулевое (любое другое) значение соответствует значению true.\n
Поразрядные логические операции работают строго с битами любого операнда. Бит может иметь 2 значения: 0 или 1. Поэтому, вычислению подлежат соответствующие биты каждого операнда а не значение операнда в целом.\n\n
11. Как в C++ реализовать логическую операцию XOR?\n
Как известно, язык C++ не содержит встроенной логической операции XOR (исключающее «ИЛИ»).\n
Ниже приведен фрагмент кода, который реализует операцию XOR с помощью использования операций &amp;&amp; (AND), || (OR), ! (NOT).\n
// реализация операции XOR через операции &amp;&amp; (AND), || (OR), ! (NOT)\n
bool x, y;\n
bool res;\n

...\n

res = (x || y) &amp;&amp; !(x &amp;&amp; y);\n

...\n
В вышеприведенном программном коде:\n
•  x, y – переменные, для которых вычисляется операция XOR;\n
•  res – переменная, которая есть результатом вычисления.\n

</item>
        <!--4-->
        <item>4.УСЛОВНЫЙ ОПЕРАТОР. ОПЕРАТОР МНОЖЕСТВЕННОГО ВЕТВЛЕНИЯ (ВЫБОРА).\n\n\n
Условные операторы if и switch в C++\n
Одна из основных конструкций алгоритма — разветвляющийся процесс. Он реализован в языке C++ двумя условными операторами: if и switch. Рассмотрим каждый из них.\n\n

Условный оператор if\n
Для организации вычислений в зависимости от какого-либо условия в C++ предусмотрен условный оператор if, который в общем виде записывается следующим образом:\n
if (условие) оператор_1; else оператор_2;\n
Здесь условие — это логическое выражение, переменная или константа.\n
Работает условный оператор следующем образом. Сначала вычисляется значения выражения, записанного в виде условия. Если оно имеет значение истина (true), выполняется оператор_1. В противном случае (значение ложное (false) ) оператор_2.\n
Например, чтобы сравнить значения переменных a и b нужно написать следующую часть программного кода:\n

int a, b;\n
cin>>a;\n
cin>>b;\n
if (a==b) cout&lt;&lt;"a equal b";\n
else cout&lt;&lt;"a not equal b";\n
Не путайте знак проверки равенства == и оператор присваивания =\n
Если в задаче требуется, чтобы в зависимости от значения условия выполнялся не один оператор, а несколько, их необходимо заключить в фигурные скобки, как составной оператор.\n
if (условие) { оператор_1; оператор_2; … }\n
else { оператор_1; оператор_2; … }\n
Альтернативная ветвь else в условном операторе может отсутствовать, если в ней нет необходимости.\n\n
Оператор варианта switch\n
Он необходим в тех случаях, когда в зависимости от значений переменной надо выполнить те или иные операторы:\n
switch (выражение)\n
{\n
case значение_1: операторы_1; break;\n
case значение_2: операторы_2; break;\n
case значение_3: операторы_3; break;\n
…\n
case значение_n: операторы_n; break;\n
default: операторы; break;\n
}\n
Оператор работает следующем образом. Вычисляется значение выражения. Затем выполняются операторы, помеченные значением, совпадающим со значением выражения. То есть если, выражение принимает значение_1, то выполняются операторы_1 и т.д.. Если выражение не принимает ни одного из значений, то выполняются операторы, расположенные после слова default.\n
Ветвь default может отсутствовать, тогда оператор имеет вид:\n
switch (выражение)\n
{\n
case значение_1: операторы_1; break;\n
case значение_2: операторы_2; break;\n
case значение_3: операторы_3; break;\n
…\n
case значение_n: операторы_n; break;\n
}\n
Оператор break необходим для того, чтобы осуществить выход из операторы switch. Если он не указан, то будут выполняться следующие операторы из списка, несмотря на то, что значение, которым они помечены, не совпадает со значением выражения.\n
Некоторые вещи могут быть непонятны, и поэтому для ясности давайте рассмотрим пример несложной задачи.\n\n
Задача\n
Необходимо вывести на название дня недели, соответствующее заданному числу D, при условии, что в месяце 31 день и 1-е число — понедельник.\n
Для решения задачи воспользуемся операцией %, позволяющей вычислить остаток от деления двух чисел. Программа будет выводить название дня недели в зависимости от заданного нами числа.\n

#include "stdafx.h"\n
#include &lt;iostream>\n
using namespace std;\n
int main ()\n
{\n
unsigned int D, R; //описанны целые положительные числа\n
cout&lt;&lt;"D=";\n
cin>>D;\n
R=D%7;\n
switch (R)\n
{\n
case 1: cout&lt;&lt;"Monday \n"; break;\n
case 2: cout&lt;&lt;"Theusday \n"; break;\n
case 3: cout&lt;&lt;"Wednesday \n"; break;\n
case 4: cout&lt;&lt;"Thursday \n"; break;\n
case 5: cout&lt;&lt;"Friday \n"; break;\n
case 6: cout&lt;&lt;"Saturday \n"; break;\n
case 0: cout&lt;&lt;"Sunday \n"; break;\n
}\n
system ("pause");\n
return 0;\n
}\n
</item>
        <!--5-->
        <item>5.ЦИКЛИЧЕСКИЕ ОПЕРАТОРЫ.\n\n\n\n\n
Циклы в C++\n
Иногда необходимо повторять одно и то же действие несколько раз подряд. Для этого используют циклы. В этом уроке мы научимся программировать циклы на C++, после чего посчитаем сумму всех чисел от 1 до 1000.\n
Цикл for\n
Если мы знаем точное количество действий (итераций) цикла, то можем использовать цикл for. Синтаксис его выглядит примерно так:\n
for (действие до начала цикла;\n
     условие продолжения цикла;\n
     действия в конце каждой итерации цикла) {\n
         инструкция цикла;\n
         инструкция цикла 2;\n
         инструкция цикла N;\n
}\n
Итерацией цикла называется один проход этого цикла\n
Существует частный случай этой записи, который мы сегодня и разберем:\n
for (счетчик = значение; счетчик &lt; значение; шаг цикла) {\n
    тело цикла;\n
}\n
Счетчик цикла — это переменная, в которой хранится количество проходов данного цикла.\n
Описание синтаксиса\n
•	Сначала присваивается первоначальное значение счетчику, после чего ставится точка с запятой.\n
•	Затем задается конечное значение счетчика цикла. После того, как значение счетчика достигнет указанного предела, цикл завершится. Снова ставим точку с запятой.\n
•	Задаем шаг цикла. Шаг цикла — это значение, на которое будет увеличиваться или уменьшаться счетчик цикла при каждом проходе.\n
Пример кода\n
Напишем программу, которая будет считать сумму всех чисел от 1 до 1000.\n
#include &lt;iostream>\n
using namespace std;\n

int main()\n
{\n
    int i; // счетчик цикла\n
    int sum = 0; // сумма чисел от 1 до 1000.\n
    setlocale(0, "");\n
    for (i = 1; i &lt;= 1000; i++) // задаем начальное значение 1, конечное 1000 и задаем шаг цикла - 1.\n
    {\n
        sum = sum + i;\n
    }\n
    cout &lt;&lt; "Сумма чисел от 1 до 1000 = " &lt;&lt; sum &lt;&lt; endl;\n
    return 0;\n
}\n
Если мы скомпилируем этот код и запустим программу, то она покажет нам ответ: 500500. Это и есть сумма всех целых чисел от 1 до 1000. Если считать это вручную, понадобится очень много времени и сил. Цикл выполнил всю рутинную работу за нас.\n
Заметьте, что конечное значение счетчика я задал нестрогим неравенством ( &lt;= — меньше либо равно), поскольку, если бы я поставил знак меньше, то цикл произвел бы 999 итераций, т.е. на одну меньше, чем требуется. Это довольно важный момент, т.к. здесь новички часто допускают ошибки, особенно при работе с массивами (о них будет рассказано в следующем уроке). Значение шага цикла я задал равное единице. i++ — это тоже самое, что и i = i + 1.\n
В теле цикла, при каждом проходе программа увеличивает значение переменной sum на i. Еще один очень важный момент — в начале программы я присвоил переменной sum значение нуля. Если бы я этого не сделал, программа вылетела вы в сегфолт. При объявлении переменной без ее инициализации что эта переменная будет хранить «мусор».\n
Естественно к мусору мы ничего прибавить не можем. Некоторые компиляторы, такие как gcc, инициализирует переменную нулем при ее объявлении.\n
Цикл while\n
Когда мы не знаем, сколько итераций должен произвести цикл, нам понадобится цикл while или do...while. Синтаксис цикла while в C++ выглядит следующим образом.\n
while (Условие) {\n
    Тело цикла;\n
}\n
Данный цикл будет выполняться, пока условие, указанное в круглых скобках является истиной. Решим ту же задачу с помощью цикла while. Хотя здесь мы точно знаем, сколько итераций должен выполнить цикл, очень часто бывают ситуации, когда это значение неизвестно.\n
Ниже приведен исходный код программы, считающей сумму всех целых чисел от 1 до 1000.\n
#include &lt;iostream>\n
using namespace std;\n

int main()\n
{\n
    setlocale(0, "");\n
    int i = 0; // инициализируем счетчик цикла.\n
    int sum = 0; // инициализируем счетчик суммы.\n
    while (i &lt; 1000)\n
    {\n
        i++;\n
        sum += i;\n
    }\n
    cout &lt;&lt; "Сумма чисел от 1 до 1000 = " &lt;&lt; sum &lt;&lt; endl;\n
    return 0;\n
}\n
После компиляции программа выдаст результат, аналогичный результату работы предыдущей программы. Но поясним несколько важных моментов. Я задал строгое неравенство в условии цикла и инициализировал счетчик i нулем, так как в цикле while происходит на одну итерацию больше, потому он будет выполняться, до тех пор, пока значение счетчика перестает удовлетворять условию, но данная итерация все равно выполнится. Если бы мы поставили нестрогое неравенство, то цикл бы закончился, когда переменная i стала бы равна 1001 и выполнилось бы на одну итерацию больше.\n
Теперь давайте рассмотрим по порядку исходный код нашей программы. Сначала мы инициализируем счетчик цикла и переменную, хранящую сумму чисел.
В данном случае мы обязательно должны присвоить счетчику цикла какое-либо значение, т.к. в предыдущей программе мы это значение присваивали внутри цикла for, здесь же, если мы не инициализируем счетчик цикла, то в него попадет «мусор» и компилятор в лучшем случае выдаст нам ошибку, а в худшем, если программа соберется — сегфолт практически неизбежен.\n
Затем мы описываем условие цикла — «пока переменная i меньше 1000 — выполняй цикл». При каждой итерации цикла значение переменной-счетчика i увеличивается на единицу внутри цикла.\n
Когда выполнится 1000 итераций цикла, счетчик станет равным 999 и следующая итерация уже не выполнится, поскольку 1000 не меньше 1000. Выражение sum += i является укороченной записью sum = sum + i.
После окончания выполнения цикла, выводим сообщение с ответом.\n
Цикл do while\n
Цикл do while очень похож на цикл while. Единственное их различие в том, что при выполнении цикла do while один проход цикла будет выполнен независимо от условия. Решение задачи на поиск суммы чисел от 1 до 1000, с применением цикла do while.\n
#include &lt;iostream>\n
using namespace std;\n

int main ()\n
{\n
    setlocale(0, "");\n
    int i = 0; // инициализируем счетчик цикла.\n
    int sum = 0; // инициализируем счетчик суммы.\n
    do {// выполняем цикл.\n
        i++;\n
        sum += i;\n
    } while (i &lt; 1000); // пока выполняется условие.\n
    cout &lt;&lt; "Сумма чисел от 1 до 1000 = " &lt;&lt; sum &lt;&lt; endl;\n
    return 0;\n
}\n
Принципиального отличия нет, но если присвоить переменной i значение, большее, чем 1000, то цикл все равно выполнит хотя бы один проход.
</item>
        <!--6-->
        <item>6.СИСТЕМЫ УПРАВЛЕНИЯ БАЗАМИ ДАННЫХ (СУБД).\n\n\n\n\n
Система управления базами данных сокр. СУБД (англ. Database Management System, сокр. DBMS) — совокупность программных и лингвистических средств общего или специального назначения, обеспечивающих управление созданием и использованием баз данных.\n
СУБД — комплекс программ, позволяющих создать базу данных (БД) и манипулировать данными (вставлять, обновлять, удалять и выбирать). Система обеспечивает безопасность, надёжность хранения и целостность данных, а также предоставляет средства для администрирования БД.\n\n
Основные функции СУБД\n
1.	управление данными во внешней памяти (на дисках);\n
2.	управление данными в оперативной памяти с использованием дискового кэша;\n
3.	журнализация изменений, резервное копирование и восстановление базы данных после сбоев;\n
4.	поддержка языков БД (язык определения данных, язык манипулирования данными).\n\n
Состав СУБД\n
Обычно современная СУБД содержит следующие компоненты:\n
•	ядро, которое отвечает за управление данными во внешней и оперативной памяти и журнализацию;\n
•	процессор языка базы данных, обеспечивающий оптимизацию запросов на извлечение и изменение данных и создание, как правило, машинно-независимого исполняемого внутреннего кода;\n
•	подсистему поддержки времени исполнения, которая интерпретирует программы манипуляции данными, создающие пользовательский интерфейс с СУБД;\n
•	сервисные программы (внешние утилиты), обеспечивающие ряд дополнительных возможностей по обслуживанию информационной системы.\n\n
Классификации СУБД\n
По модели данных\n
Примеры:\n
•	Иерархические\n
•	Сетевые\n
•	Реляционные\n
•	Объектно-ориентированные\n
•	Объектно-реляционные\n\n
По степени распределённости\n
•	Локальные СУБД (все части локальной СУБД размещаются на одном компьютере)\n
•	Распределённые СУБД (части СУБД могут размещаться не только на одном, но на двух и более компьютерах).\n
По способу доступа к БД\n
•	Файл-серверные\n
В файл-серверных СУБД файлы данных располагаются централизованно на файл-сервере. СУБД располагается на каждом клиентском компьютере (рабочей станции). Доступ СУБД к данным осуществляется через локальную сеть. Синхронизация чтений и обновлений осуществляется посредством файловых блокировок.\n
Преимуществом этой архитектуры является низкая нагрузка на процессор файлового сервера.\n
Недостатки: потенциально высокая загрузка локальной сети; затруднённость или невозможность централизованного управления; затруднённость или невозможность обеспечения таких важных характеристик, как высокая надёжность, высокая доступность и высокая безопасность. Применяются чаще всего в локальных приложениях, которые используют функции управления БД; в системах с низкой интенсивностью обработки данных и низкими пиковыми нагрузками на БД.\n
На данный момент файл-серверная технология считается устаревшей, а её использование в крупных информационных системах — недостатком.\n
Примеры: Microsoft Access, Paradox, dBase, FoxPro, Visual FoxPro.\n
•	Клиент-серверные\n
Клиент-серверная СУБД располагается на сервере вместе с БД и осуществляет доступ к БД непосредственно, в монопольном режиме. Все клиентские запросы на обработку данных обрабатываются клиент-серверной СУБД централизованно.\n
Недостаток клиент-серверных СУБД состоит в повышенных требованиях к серверу.\n
Достоинства: потенциально более низкая загрузка локальной сети; удобство централизованного управления; удобство обеспечения таких важных характеристик, как высокая надёжность, высокая доступность и высокая безопасность.\n
Примеры: Oracle Database, Firebird, Interbase, IBM DB2, Informix, MS SQL Server, Sybase Adaptive Server Enterprise, PostgreSQL, MySQL, Caché, ЛИНТЕР.\n
•	Встраиваемые\n
Встраиваемая СУБД — СУБД, которая может поставляться как составная часть некоторого программного продукта, не требуя процедуры самостоятельной установки. Встраиваемая СУБД предназначена для локального хранения данных своего приложения и не рассчитана на коллективное использование в сети.\n
Физически встраиваемая СУБД чаще всего реализована в виде подключаемой библиотеки. Доступ к данным со стороны приложения может происходить через SQL либо через специальные программные интерфейсы.\n
Примеры: OpenEdge, SQLite, BerkeleyDB, Firebird Embedded, Microsoft SQL Server Compact, ЛИНТЕР.\n
Стратегии работы с внешней памятью\n
СУБД с непосредственной записью\n
В таких СУБД все изменённые блоки данных незамедлительно записываются во внешнюю память при поступлении сигнала подтверждения любой транзакции. Такая стратегия используется только при высокой эффективности внешней памяти.\n
СУБД с отложенной записью\n
В таких СУБД изменения аккумулируются в буферах внешней памяти до наступления любого из следующих событий:\n
•	Контрольная точка.\n
•	Нехватка пространства во внешней памяти, отведенного под журнал. СУБД создаёт контрольную точку и начинает писать журнал сначала, затирая предыдущую информацию.\n
•	Останов. СУБД ждёт, когда всё содержимое всех буферов внешней памяти будет перенесено во внешнюю память, после чего делает отметки, что останов базы данных выполнен корректно.\n
•	Нехватка оперативной памяти для буферов внешней памяти.\n
Такая стратегия позволяет избежать частого обмена с внешней памятью и значительно увеличить эффективность работы СУБД.\n

</item>
        <!--7-->
        <item>7.ПРОЕКТИРОВАНИЕ СТРУКТУРЫ БАЗЫ ДАННЫХ.\n\n\n\n
Проектирование баз данных — процесс создания схемы базы данных и определения необходимых ограничений целостности.\n

Основные задачи проектирования баз данных\n
Основные задачи:\n
•	Обеспечение хранения в БД всей необходимой информации.\n
•	Обеспечение возможности получения данных по всем необходимым запросам.\n
•	Сокращение избыточности и дублирования данных.\n
•	Обеспечение целостности базы данных.\n\n

Основные этапы проектирования баз данных\n
Концептуальное (инфологическое) проектирование\n

Концептуальное (инфологическое) проектирование — построение семантической модели предметной области, то есть информационной модели наиболее высокого уровня абстракции. Такая модель создаётся без ориентации на какую-либо конкретную СУБД и модель данных. Термины «семантическая модель», «концептуальная модель» и «инфологическая модель» являются синонимами. Кроме того, в этом контексте равноправно могут использоваться слова «модель базы данных» и «модель предметной области» (например, «концептуальная модель базы данных» и «концептуальная модель предметной области»), поскольку такая модель является как образом реальности, так и образом проектируемой базы данных для этой реальности.\n
Конкретный вид и содержание концептуальной модели базы данных определяется выбранным для этого формальным аппаратом. Обычно используются графические нотации, подобные ER-диаграммам.\n
Чаще всего концептуальная модель базы данных включает в себя:\n
•	описание информационных объектов или понятий предметной области и связей между ними.\n
•	описание ограничений целостности, то есть требований к допустимым значениям данных и к связям между ними.\n
Логическое (даталогическое) проектирование\n
Логическое (даталогическое) проектирование — создание схемы базы данных на основе конкретной модели данных, например, реляционной модели данных. Для реляционной модели данных даталогическая модель — набор схем отношений, обычно с указанием первичных ключей, а также «связей» между отношениями, представляющих собой внешние ключи.\n
Преобразование концептуальной модели в логическую модель, как правило, осуществляется по формальным правилам. Этот этап может быть в значительной степени автоматизирован.\n
На этапе логического проектирования учитывается специфика конкретной модели данных, но может не учитываться специфика конкретной СУБД.\n
Физическое проектирование\n
Физическое проектирование — создание схемы базы данных для конкретной СУБД. Специфика конкретной СУБД может включать в себя ограничения на именование объектов базы данных, ограничения на поддерживаемые типы данных и т. п. Кроме того, специфика конкретной СУБД при физическом проектировании включает выбор решений, связанных с физической средой хранения данных (выбор методов управления дисковой памятью, разделение БД по файлам и устройствам, методов доступа к данным), создание индексов и т. д.\n
Результатом физического проектирования логической схемы выше на языке SQL может являться следующий скрипт:\n
CREATE TABLE IF NOT EXISTS Department ( -- Факультет\n
  id INT NOT NULL,\n
  name VARCHAR(45),\n
  PRIMARY KEY (id)\n
);\n\n

CREATE TABLE IF NOT EXISTS Group (\n
  id INT NOT NULL,\n
  name VARCHAR(45) ,\n
  depart_id INT NOT NULL,\n
  UNIQUE INDEX depart_id_UNIQUE (depart_id ASC),\n
  PRIMARY KEY (id, depart_id),\n
  CONSTRAINT depart_fk\n
    FOREIGN KEY (depart_id)\n
    REFERENCES Department (id)\n
);\n\n

CREATE TABLE IF NOT EXISTS Student (\n
  first_name VARCHAR(16) NOT NULL,\n
  last_name VARCHAR(45) NOT NULL,\n
  email VARCHAR(255),\n
  group_id INT NOT NULL,\n
  PRIMARY KEY (last_name, first_name, group_id),\n
  INDEX group_fk_idx (group_id ASC),\n
  CONSTRAINT group_fk\n
    FOREIGN KEY (group_id) REFERENCES Group (id)\n
);\n\n
Нормализация\n
При проектировании реляционных баз данных обычно выполняется так называемая нормализация.\n
Модели «сущность-связь»\n
Модель «сущность-связь» (англ. “Entity-Relationship model”), или ER-модель, предложенная П. Ченом в 1976 г., является наиболее известным представителем класса семантических (концептуальных, инфологических) моделей предметной области. ER-модель обычно представляется в графической форме, с использованием оригинальной нотации П. Чена, называемой ER-диаграмма, либо с использованием других графических нотаций (Crow’s Foot, Information Engineering и др.).\n
Основные преимущества ER-моделей:\n
•	наглядность;\n
•	модели позволяют проектировать базы данных с большим количеством объектов и атрибутов;\n
•	ER-модели реализованы во многих системах автоматизированного проектирования баз данных (например, ERWin).\n
Основные элементы ER-моделей:\n
•	объекты (сущности);\n
•	атрибуты объектов;\n
•	связи между объектами.\n
Сущность — объект предметной области, имеющий атрибуты.\n
Связь между сущностями характеризуется:\n
•	типом связи (1:1, 1:N, N:М);\n
•	классом принадлежности. Класс может быть обязательным и необязательным. Если каждый экземпляр сущности участвует в связи, то класс принадлежности — обязательный, иначе — необязательный.\n
Семантические модели\n
Семантическая модель (концептуальная модель, инфологическая модель) — модель предметной области, предназначенная для представления семантики предметной области на самом высоком уровне абстракции. Это означает, что устранена или минимизирована необходимость использовать понятия «низкого уровня», связанные со спецификой физического представления и хранения данных.\n
Семантическое моделирование стало предметом интенсивных исследований с конца 1970-х годов. Основным побудительным мотивом подобных исследований (то есть проблемой, которую пытались разрешить исследователи) был следующий факт. Дело в том, что системы баз данных обычно обладают весьма ограниченными сведениями о смысле хранящихся в них данных. Чаще всего они позволяют лишь манипулировать данными определенных простых типов и определяют некоторые простейшие ограничения целостности, наложенные на эти данные. Любая более сложная интерпретация возлагается на пользователя. Однако было бы замечательно, если бы системы могли обладать немного более широким объемом сведений и несколько интеллектуальнее отвечать на запросы пользователя, а также поддерживать более сложные (то есть более высокоуровневые) интерфейсы пользователя.\n
Идеи семантического моделирования могут быть полезны как средство проектирования базы данных даже при отсутствии их непосредственной поддержки в СУБД.\n
Наиболее известным представителем класса семантических моделей является модель «сущность-связь» (ER-модель).\n

</item>
        <!--8-->
        <item>8.ВИДЫ МОДЕЛЕЙ ДАННЫХ.\n\n\n\n\n\n
Виды моделей данных БД\n
Модели организации данных. Сетевые, реляционные, иерархические модели.\n
Ядром любой базы данных является модель данных. С помощью модели данных могут быть представлены объекты предметной области и взаимосвязи между ними.\n
Модель данных - это совокупность структур данных и операций их обработки. Рассмотрим три основных типа моделей данных: иерархическую, сетевую и реляционную.\n
Виды моделей данных БД\n
Иерархическую модель БД изображают в виде дерева. Элементы дерева вершины представляют совокупность данных, например логические записи.\n
Иерархическая модель представляет собой совокупность элементов, расположенных в порядке их подчинения от общего к частному и образующих перевернутое по структуре дерево (граф).\n
К основным понятиям иерархической структуры относятся уровень, узел и связь. Узел – это совокупность атрибутов данных, описывающих некоторый объект. На схеме иерархического дерева узлы представляются вершинами графа. Каждый узел на более низком уровне связан только с одним узлом, находящимся на более высоком уровне. Иерархическое дерево имеет только одну вершину, не подчиненную никакой другой вершине и находящуюся на самом верхнем - первом уровне. Зависимые (подчиненные) узлы находятся на втором, третьем и т. д. уровнях. Количество деревьев в базе данных определяется числом корневых записей. К каждой записи базы данных существует только один иерархический путь от корневой записи.\n
Сетевые модели БД соответствуют более широкому классу объектов управления, хотя требуют для своей организации и дополнительных затрат.\n
В сетевой структуре при тех же основных понятиях (уровень, узел, связь) каждый элемент может быть связан с любым другим элементом.\n
Реляционная модель БД представляет объекты и взаимосвязи между ними в виде таблиц, а все операции над данными сводятся к операциям над этими таблицами. На этой модели базируются практически все современные СУБД. Эта модель более понятна, "прозрачна" для конечного пользователя организации данных.\n
Реляционная модель данных объекты и связи между ними представляет в виде таблиц, при этом связи тоже рассматриваются как объекты. Все строки, составляющие таблицу в реляционной базе данных, должны иметь первичный ключ. Все современные средства СУБД поддерживают реляционную модель данных.\n
Эта модель характеризуются простотой структуры данных, удобным для пользователя табличным представлением и возможностью использования формального аппарата алгебры отношений и реляционного исчисления для обработки данных.\n
Каждая реляционная таблица представляет собой двумерный массив и обладает следующими свойствами:\n
1. Каждый элемент таблицы соответствует одному элементу данных.\n
2. Все столбцы в таблице однородные, т.е. все элементы в столбце имеют одинаковый тип и длину.\n
3. Каждый столбец имеет уникальное имя.\n
4. Одинаковые строки в таблице отсутствуют.\n
5. Порядок следования строк и столбцов может быть произвольным.\n
В последние годы все большее признание и развитие получают объектно-ориентированные базы данных (ООБД), толчок к появлению которых дали объектно-ориентированное программирование и использование персональных компьютеров для обработки и представления практически всех форм информации, воспринимаемых человеком. В ООБД модель данных более близка сущностям реального мира. Объекты можно сохранить и использовать непосредственно, не раскладывая их по таблицам.\n
</item>
        <!--9-->
        <item>9.СОЗДАНИЕ БАЗЫ ДАННЫХ. ПРИМЕРЫ В СРЕДЕ ACCESS.\n\n\n\n\n
Создание базы данных в MS Access: пошаговая инструкция\n
СОДЕРЖАНИЕ\n
•	Описание MS Access\n
•	Определения основных понятий\n
•	Создание БД\n
•	Создание и заполнение таблиц\n
•	Создание и редактирование схем данных\n
•	Выполнение запросов\n
•	Создание формы\n
•	Формирование отчета\n
В современном мире нужны инструменты, которые бы позволяли хранить, систематизировать и обрабатывать большие объемы информации, с которыми сложно работать в Excel или Word.\n
Подобные хранилища используются для разработки информационных сайтов, интернет-магазинов и бухгалтерских дополнений. Основными средствами, реализующими данный подход, являются MS SQL и MySQL.\n
Продукт от Microsoft Office представляет собой упрощенную версию в функциональном плане и более понятную для неопытных пользователей. Давайте рассмотрим пошагово создание базы данных в Access.\n\n

Описание MS Access\n
Microsoft Access – это система управления базами данных (СУБД), реализующая полноценный графический интерфейс пользователя, принцип создания сущностей и связей между ними, а также структурный язык запросов SQL. Единственный минус этой СУБД – невозможность работать в промышленных масштабах. Она не предназначена для хранения огромных объемов данных. Поэтому MS Access используется для небольших проектов и в личных некоммерческих целях.\n
Но прежде чем показывать пошагово создание БД, нужно ознакомиться с базовыми понятиями из теории баз данных.\n\n
Определения основных понятий\n
Без базовых знаний об элементах управления и объектах, использующихся при создании и конфигурации БД, нельзя успешно понять принцип и особенности настройки предметной области. Поэтому сейчас я постараюсь простым языком объяснить суть всех важных элементов. Итак, начнем:\n
•	Предметная область – множество созданных таблиц в базе данных, которые связаны между собой с помощью первичных и вторичных ключей.\n
•	Сущность – отдельная таблица базы данных.\n
•	Атрибут – заголовок отдельного столбца в таблице.\n
•	Кортеж – это строка, принимающая значение всех атрибутов.\n
•	Первичный ключ – это уникальное значение (id), которое присваивается каждому кортежу.\n
•	Вторичный ключ таблицы «Б» – это уникальное значение таблицы «А», использующееся в таблице «Б».\n
•	SQL запрос – это специальное выражение, выполняющее определенное действие с базой данных: добавление, редактирование, удаление полей, создание выборок.\n
Теперь, когда в общих чертах есть представление о том, с чем мы будем работать, можно приступить к созданию БД.\n\n
Создание БД\n
Для наглядности всей теории создадим тренировочную базу данных «Студенты-Экзамены», которая будет содержать 2 таблицы: «Студенты» и «Экзамены». Главным ключом будет поле «Номер зачетки», т.к. данный параметр является уникальным для каждого студента. Остальные поля предназначены для более полной информации об учащихся.\n
Итак, выполните следующее:\n
•	Запустите MS Access.\n
•	Нажмите на кнопку «Новая база данных».\n
•	В появившемся окне введите название БД и выберите «Создать».\n

Все, теперь осталось только создать, заполнить и связать таблицы. Переходите к следующему пункту.\n\n
Создание и заполнение таблиц\n
После успешного создания БД на экране появится пустая таблица. Для формирования ее структуры и заполнения выполните следующее:\n
1.	Нажмите ПКМ по вкладке «Таблица1» и выберите «Конструктор».\n

2.	Теперь начинайте заполнять названия полей и соответствующий им тип данных, который будет использоваться.\n

Внимание! Первым полем принято устанавливать уникальное значение (первичный ключ). Для него предпочтительно числовое значение.\n
1.	После создания необходимых атрибутов сохраните таблицу и введите ее название.\n
2.	Снова нажмите ПКМ по вкладке с уже новым название и выберите «Режим таблицы».\n

3.	Заполните таблицу необходимыми значениями.\n

Совет! Для тонкой настройки формата данных перейдите на ленте во вкладку «Режим таблицы» и обратите внимание на блок «Форматирование и тип данных». Там можно кастомизировать формат отображаемых данных.\n\n
Создание и редактирование схем данных\n
Перед тем, как приступить к связыванию двух сущностей, по аналогии с предыдущим пунктом нужно создать и заполнить таблицу «Экзамены». Она имеет следующие атрибуты: «Номер зачетки», «Экзамен1», «Экзамен2», «Экзамен3».\n
Для выполнения запросов нужно связать наши таблицы. Иными словами, это некая зависимость, которая реализуется с помощью ключевых полей. Для этого нужно:\n
1.	Перейти во вкладку «Работа с базами данных».\n
2.	Нажать на кнопку «Схема данных».\n
3.	Если схема не была создана автоматически, нужно нажать ПКМ на пустой области и выбрать «Добавить таблицы».\n

4.	Выберите каждую из сущностей, поочередно нажимая кнопку «Добавить».\n
5.	Нажмите кнопку «ОК».\n
Конструктор должен автоматически создать связь, в зависимости от контекста. Если же этого не случилось, то:\n
3.	Перетащите общее поле из одной таблицы в другую.\n
4.	В появившемся окне выберите необходимы параметры и нажмите «ОК».\n

5.	Теперь в окне должны отобразиться миниатюры двух таблиц со связью (один к одному).\n

Выполнение запросов\n
Что же делать, если нам нужны студенты, которые учатся только в Москве? Да, в нашей БД только 6 человек, но что, если их будет 6000? Без дополнительных инструментов узнать это будет сложно.\n
Именно в этой ситуации к нам на помощь приходят SQL запросы, которые помогают изъять лишь необходимую информацию.\n\n
Виды запросов\n
SQL синтаксис реализует принцип CRUD (сокр. от англ. create, read, update, delete — «создать, прочесть, обновить, удалить»). Т.е. с помощью запросов вы сможете реализовать все эти функции.\n\n
На выборку\n
В этом случае в ход вступает принцип «прочесть». Например, нам нужно найти всех студентов, которые учатся в Харькове. Для этого нужно:\n
1.	Перейти во вкладку «Создание».\n
2.	Нажать кнопку «Конструктор запросов» в блоке «Другие».\n
3.	В новом окне нажмите на кнопку SQL.\n

4.	В текстовое поле введите команду: SELECT * FROM Студенты WHERE Адрес = «Харьков»; где «SELECT *» означает, что выбираются все студенты, «FROM Студенты» — из какой таблицы, «WHERE Адрес = «Харьков»» — условие, которое обязательно должно выполняться.\n
5.	Нажмите кнопку «Выполнить».\n

6.	На выходе мы получаем результирующую таблицу.\n

А что делать, если нас интересуют студенты из Харькова, стипендии у которых больше 1000? Тогда наш запрос будет выглядеть следующим образом:\n
SELECT * FROM Студенты WHERE Адрес = «Харьков» AND Стипендия > 1000;\n
а результирующая таблица примет следующий вид:\n\n

На создание сущности\n
Кроме добавления таблицы с помощью встроенного конструктора, иногда может потребоваться выполнение этой операции с помощью SQL запроса. В большинстве случаев это нужно во время выполнения лабораторных или курсовых работ в рамках университетского курса, ведь в реальной жизни необходимости в этом нет. Если вы, конечно, не занимаетесь профессиональной разработкой приложений. Итак, для создания запроса нужно:\n
1.	Перейти во вкладку «Создание».\n
2.	Нажать кнопку «Конструктор запросов» в блоке «Другие».\n
3.	В новом окне нажмите на кнопку SQL, после чего в текстовое поле введите команду:\n
CREATE TABLE Преподаватели\n
(КодПреподавателя INT PRIMARY KEY,\n
Фамилия CHAR(20),\n
Имя CHAR (15),\n
Отчество CHAR (15),\n
Пол CHAR (1),\n
Дата_рождения DATE,\n
Основной_предмет CHAR (200));\n
где «CREATE TABLE» означает создание таблицы «Преподаватели», а «CHAR», «DATE» и «INT» — типы данных для соответствующих значений.\n

1.	Кликните по кнопке «Выполнить».\n
2.	Откройте созданную таблицу.\n

Внимание! В конце каждого запроса должен стоять символ «;». Без него выполнение скрипта приведет к ошибке.\n
На добавление, удаление, редактирование\n
Здесь все гораздо проще. Снова перейдите в поле для создания запроса и введите следующие команды:\n
1.	для заполнения кортежа:\n
INSERT INTO Преподаватели\n
VALUES (1, ‘Иванова’, ‘Иванна’, ‘Ивановна’, ‘Ж’, ’05-06-1981′, ‘География’);\n
2.	для редактирования записи:\n
UPDATE Преподаватели SET Имя = ‘Анна’;\n

3.	для удаления:\n
DELETE * FROM Преподаватели WHERE Имя=’Анна’;.\n\n

Создание формы\n
При огромном количестве полей в таблице заполнять базу данных становится сложно. Можно случайно пропустить значение, ввести неверное или другого типа. В данной ситуации на помощь приходят формы, с помощью которых можно быстро заполнять сущности, а вероятность допустить ошибку минимизируется. Для этого потребуются следующие действия:\n
4.	Откройте интересующую таблицу.\n
5.	Перейдите во вкладку «Создание».\n
6.	Нажмите на необходимый формат формы из блока «Формы».\n

Совет! Рекомендуется использовать «Разделенную форму» – кроме самого шаблона, в нижней части будет отображаться миниатюра таблицы, которая сделает процесс редактирования еще более наглядным.\n
7.	С помощью навигационных кнопок переходите к следующей записи и вносите изменения.\n

Все базовые функции MS Access 2007 мы уже рассмотрели. Остался последний важный компонент – формирование отчета.\n\n
Формирование отчета\n
Отчет – это специальная функция MS Access, позволяющая оформить и подготовить для печати данные из базы данных. В основном это используется для создания товарных накладных, бухгалтерских отчетов и прочей офисной документации.\n
Если вы никогда не сталкивались с подобной функцией, рекомендуется воспользоваться встроенным «Мастером отчетов». Для этого сделайте следующее:\n
•	Перейдите во вкладку «Создание».\n
•	Нажмите на кнопку «Мастер отчетов» в блоке «Отчеты».\n

•	Выберите интересующую таблицу и поля, нужные для печати.\n

•	Добавьте необходимый уровень группировки.\n

•	Выберите тип сортировки каждого из полей.\n

•	Настройте вид макета для отчета.\n

•	Выберите подходящий стиль оформления.\n

Внимание! В официальных документах допускается только стандартный стиль оформления.\n
•	Просмотрите созданный отчет.\n

Если отображение вас не устраивает, его можно немного подкорректировать. Для этого:\n
1.	Нажмите ПКМ на вкладке отчета и выберите «Конструктор».\n
2.	Вручную расширьте интересующие столбцы.\n
3.	Сохраните изменения.\n
</item>
        <!--10-->
        <item>10.МОДЕЛИ И ИХ СВОЙСТВА. ДАТА MINING.\n\n\n\n\n\n\n\n
Основные понятия\n
Знания есть не только у человека, но и у накопленных данных, которые подвергаются анализу. Такие знания содержатся в огромной объеме информации, которую человек не в силах исследовать самостоятельно. В связи с этим существует вероятность пропустить гипотезы, которые могут принести значительную выгоду.\n
Для обнаружения «скрытых» знаний применяется специальные методы автоматического анализа, при помощи которых приходиться практически добывать знания из «завалов» информации. За этим направлением закрепился термин «добыча данных (DataMining)» или «интеллектуальный анализ данных».\n
Существует множество определений DataMining, которые друг друга дополняют. Вот некоторые из них.\n
DataMining – это процесс обнаружения в базах данных нетривиальных и практически полезных закономерностей. (BaseGroup)\n
DataMining – это процесс выделения, исследования и моделирования больших объемов данных для обнаружения неизвестных до этого структур(patterns) с целью достижения преимуществ в бизнесе. (SAS Institute)\n
DataMining – это процесс, цель которого – обнаружить новые значимые корреляции, образцы и тенденции в результате просеивания большого объема хранимых данных с использованием методик распознавания образцов плюс применение статистических и математических методов. (GartnerGroup)\n
DataMining – это исследование и обнаружение «машиной» (алгоритмами, средствами искусственного интеллекта) в сырых данных скрытых знаний, которые ранее не были известны, нетривиальны, практически полезны, доступны для интерпретации человеком. (А.Баргесян «Технологии анализа данных»)\n
DataMining – это процесс обнаружения полезных знаний о бизнесе. (Н.М.Абдикеев «КБА»)\n
Свойства обнаруживаемых знаний\n
Рассмотрим свойства обнаруживаемых знаний.\n
1.	Знания должны быть новые, ранее неизвестные. Затраченные усилия на открытие знаний, которые уже известны пользователю, не окупаются. Поэтому ценность представляют именно новые, ранее неизвестные знания.\n
2.	Знания должны быть нетривиальны. Результаты анализа должны отражать неочевидные, неожиданные закономерности в данных, составляющие так называемые скрытые знания. Результаты, которые могли бы быть получены более простыми способами (например, визуальным просмотром), не оправдывают привлечение мощных методов DataMining.\n
3.	Знания должны быть практически полезны. Найденные знания должны быть применимы, в том числе и на новых данных, с достаточно высокой степенью достоверности. Полезность заключается в том, чтобы эти знания могли принести определенную выгоду при их применении.\n
4.	Знания должны быть доступны для понимания человеку. Найденные закономерности должны быть логически объяснимы, в противном случае существует вероятность, что они являются случайными. Кроме того, обнаруженные знания должны быть представлены в понятном для человека виде.\n
В DataMining для представления полученных знаний служат модели. Виды моделей зависят от методов их создания. Наиболее распространенными являются: правила, деревья решений, кластеры и математические функции.\n\n
Задачи DataMining\n
Напомним, что в основу технологии DataMining положена концепция шаблонов, представляющих собой закономерности. В результате обнаружения этих, скрытых от невооруженного глаза закономерностей решаются задачи DataMining. Различным типам закономерностей, которые могут быть выражены в форме, понятной человеку, соответствуют определенные задачи DataMining.\n
Единого мнения относительно того, какие задачи следует относить к DataMining, нет. Большинство авторитетных источников перечисляют следующие: классификация,
кластеризация, прогнозирование, ассоциация, визуализация, анализ и обнаружение отклонений, оценивание, анализ связей, подведение итогов.\n
Цель описания, которое следует ниже, - дать общее представление о задачах DataMining, сравнить некоторые из них, а также представить некоторые методы, с помощью которых эти задачи решаются. Наиболее распространенные задачи DataMining - классификация,кластеризация, ассоциация, прогнозирование и визуализация. Таким образом, задачи подразделяются по типам производимой информации, это наиболее общая классификация задач DataMining.\n\n
Классификация (Classification)\n
Задача разбиения множества объектов или наблюдений на априорно заданные группы, называемые классами, внутри каждой из которых они предполагаются похожими друг на друга, имеющими примерно одинаковые свойства и признаки. При этом решение получается на основе анализа значений атрибутов (признаков).\n
Классификация является одной из важнейших задач DataMining. Она применяется в маркетинге при оценке кредитоспособности заемщиков, определении лояльности клиентов, распознавании образов, медицинской диагностике и многих других приложениях. Если аналитику известны свойства объектов каждого класса, то когда новое наблюдение относится к определенному классу, данные свойства автоматически распространяются и на него.\n
Если число классов ограничено двумя, то имеет место бинарная классификация, к которой могут быть сведены многие более сложные задачи. Например, вместо определения таких степеней кредитного риска, как «Высокий», «Средний» или «Низкий», можно использовать всего две - «Выдать» или «Отказать».\n
Для классификации в DataMining используется множество различных моделей: нейронные сети, деревья решений, машины опорных векторов, метод k-ближайших соседей, алгоритмы покрытия и др., при построении которых применяется обучение с учителем, когда выходная переменная (метка класса) задана для каждого наблюдения. Формально классификация производится на основе разбиения пространства признаков на области, в пределах каждой из которых многомерные векторы рассматриваются как идентичные. Иными словами, если объект попал в область пространства, ассоциированную с определенным классом, он к нему и относится.\n\n
Кластеризация (Clustering)\n
Краткое описание. Кластеризация является логическим продолжением идеи классификации. Это задача более сложная, особенность кластеризации заключается в том, что классы объектов изначально не предопределены. Результатом кластеризации является разбиение объектов на группы.\n
Пример метода решения задачи кластеризации: обучение "без учителя" особого вида нейронных сетей - самоорганизующихся карт Кохонена.\n\n
Ассоциация (Associations)\n
Краткое описание. В ходе решения задачи поиска ассоциативных правил отыскиваются закономерности между связанными событиями в наборе данных.
Отличие ассоциации от двух предыдущих задач DataMining: поиск закономерностей осуществляется не на основе свойств анализируемого объекта, а между несколькими событиями, которые происходят одновременно. Наиболее известный алгоритм решения задачи поиска ассоциативных правил – алгоритм Apriori.\n\n
Последовательность (Sequence) или последовательная ассоциация (sequentialassociation)\n
Краткое описание. Последовательность позволяет найти временные закономерности между транзакциями. Задача последовательности подобна ассоциации, но ее целью является установление закономерностей не между одновременно наступающими событиями, а между событиями, связанными во времени (т.е. происходящими с некоторым определенным интервалом во времени). Другими словами, последовательность определяется высокой вероятностью цепочки связанных во времени событий. Фактически, ассоциация является частным случаем последовательности с временным лагом, равным нулю. Эту задачу DataMining также называют задачей нахождения последовательных шаблонов (sequentialpattern).\n
Правило последовательности: после события X через определенное время произойдет событие Y.\n
Пример. После покупки квартиры жильцы в 60% случаев в течение двух недель приобретают холодильник, а в течение двух месяцев в 50% случаев приобретается телевизор. Решение данной задачи широко применяется в маркетинге и менеджменте, например, при управлении циклом работы с клиентом (CustomerLifecycleManagement).\n\n

Регрессия, прогнозирование (Forecasting)\n
Краткое описание. В результате решения задачи прогнозирования на основе особенностей исторических данных оцениваются пропущенные или же будущие значения целевых численных показателей.\n
Для решения таких задач широко применяются методы математической статистики, нейронные сети и др.\n\n

Дополнительные задачи\n
Определение отклонений или выбросов (DeviationDetection), анализ отклонений или выбросов\n
Краткое описание. Цель решения данной задачи - обнаружение и анализ данных, наиболее отличающихся от общего множества данных, выявление так называемых нехарактерных шаблонов.\n\n
Оценивание (Estimation)\n
Задача оценивания сводится к предсказанию непрерывных значений признака.\n
Анализ связей (LinkAnalysis)\n
Задача нахождения зависимостей в наборе данных.\n
Визуализация (Visualization, GraphMining)\n
В результате визуализации создается графический образ анализируемых данных. Для решения задачи визуализации используются графические методы, показывающие наличие закономерностей в данных.\n
Пример методов визуализации - представление данных в 2-D и 3-D измерениях.\n\n
Подведение итогов (Summarization)\n
Задача, цель которой - описание конкретных групп объектов из анализируемого набора данных.\n
Достаточно близким к вышеупомянутой классификации является подразделение задач DataMining на следующие: исследования и открытия, прогнозирования и классификации, объяснения и описания.\n
Автоматическое исследование и открытие (свободный поиск)\n
Пример задачи: обнаружение новых сегментов рынка.\n
Для решения данного класса задач используются методы кластерного анализа.\n
Прогнозирование и классификация\n
Пример задачи: предсказание роста объемов продаж на основе текущих значений.\n
Методы: регрессия, нейронные сети, генетические алгоритмы, деревья решений.\n
Задачи классификации и прогнозирования составляют группу так называемого индуктивного моделирования, в результате которого обеспечивается изучение анализируемого объекта или системы. В процессе решения этих задач на основе набора данных разрабатывается общая модель или гипотеза.\n\n
Объяснение и описание\n
Пример задачи: характеристика клиентов по демографическим данным и историям покупок.\n
Методы: деревья решения, системы правил, правила ассоциации, анализ связей.\n
Если доход клиента больше, чем 50 условных единиц, и его возраст - более 30 лет, тогда класс клиента - первый.\n
Сравнение кластеризации и классификации\n
Характеристика	Классификация	Кластеризация\n
Контролируемость обучения	Контролируемое	Неконтролируемое\n
Стратегии	Обучение с учителем	Обучение без учителя\n
Наличие метки класса Обучающее множество сопровождается меткой, указывающей класс, к которому относится наблюдение	Метки класса обучающего
множества неизвестны\n
Основание для классификации	Новые данные классифицируются на основании обучающего множества	Дано множество данных с целью
установления существования классов или кластеров данных\n\n

Сферы применения DataMining\n
Следует отметить, что на сегодняшний день наибольшее распространение технология DataMining получила при решении бизнес-задач. Возможно, причина в том, что именно в этом направлении отдача от использования инструментов DataMining может составлять, по некоторым источникам, до 1000% и затраты на ее внедрение могут достаточно быстро окупиться.\n
Мы будем рассматривать четыре основные сферы применения технологии DataMining подробно: наука, бизнес, исследования для правительства и Web-направление.\n
Применение DataMining для решения бизнес-задач. Основные направления: банковское дело, финансы, страхование, CRM, производство, телекоммуникации, электронная коммерция, маркетинг, фондовый рынок и другие.\n
1.	Выдавать ли кредит клиенту\n
2.	Сегментация рынка\n
3.	Привлечение новых клиентов\n
4.	Мошенничество с кредитными карточками\n
Применение DataMining для решения задач государственного уровня. Основные направления: поиск лиц, уклоняющихся от налогов; средства в борьбе с терроризмом.\n
Применение DataMining для научных исследований. Основные направления: медицина, биология, молекулярная генетика и генная инженерия, биоинформатика, астрономия, прикладная химия, исследования, касающиеся наркотической зависимости, и другие.\n
Применение DataMining для решения Web-задач. Основные направления: поисковые машины (search engines), счетчики и другие.\n\n
Электронная коммерция\n
В сфере электронной коммерции DataMining применяется для формирования рекомендательных систем и решения задач классификации посетителей Web-сайтов.\n
Такая классификация позволяет компаниям выявлять определенные группы клиентов и проводить маркетинговую политику в соответствии с обнаруженными интересами и потребностями клиентов. Технология DataMining для электронной коммерции тесно связана с технологией WebMining.\n\n
Основные задачи DataMining в промышленном производстве:\n
· комплексный системный анализ производственных ситуаций;\n
· краткосрочный и долгосрочный прогноз развития производственных ситуаций;\n
· выработка вариантов оптимизационных решений;\n
· прогнозирование качества изделия в зависимости от некоторых параметров технологического процесса;\n
· обнаружение скрытых тенденций и закономерностей развития производственныхпроцессов;\n
· прогнозирование закономерностей развития производственных процессов;\n
· обнаружение скрытых факторов влияния;\n
· обнаружение и идентификация ранее неизвестных взаимосвязей между производственными параметрами и факторами влияния;\n
· анализ среды взаимодействия производственных процессов и прогнозирование изменения ее характеристик;\n
· выработку оптимизационных рекомендаций по управлению производственнымипроцессами;\n
· визуализацию результатов анализа, подготовку предварительных отчетов и проектов допустимых решений с оценками достоверности и эффективности возможных реализаций.\n\n
Маркетинг\n
В сфере маркетинга DataMining находит очень широкое применение.\n
Основные вопросы маркетинга "Что продается?", "Как продается?", "Кто является потребителем?"\n
В лекции, посвященной задачам классификации и кластеризации, подробно описано использование кластерного анализа для решения задач маркетинга, как, например, сегментация потребителей.\n
Другой распространенный набор методов для решения задач маркетинга - методы и алгоритмы поиска ассоциативных правил.\n
Также успешно здесь используется поиск временных закономерностей.\n\n
Розничная торговля\n
В сфере розничной торговли, как и в маркетинге, применяются:\n
· алгоритмы поиска ассоциативных правил (для определения часто встречающихся наборов товаров, которые покупатели покупают одновременно). Выявление таких правил помогает размещать товары на прилавках торговых залов, вырабатывать стратегии закупки товаров и их размещения на складах и т.д.\n
· использование временных последовательностей, например, для определения необходимых объемов запасов товаров на складе.\n
· методы классификации и кластеризации для определения групп или категорий клиентов, знание которых способствует успешному продвижению товаров.\n\n
Фондовый рынок\n
Вот список задач фондового рынка, которые можно решать при помощи технологии DataMining: · прогнозирование будущих значений финансовых инструментов и индикаторов по их прошлым значениям;\n
· прогноз тренда (будущего направления движения - рост, падение, флэт) финансового инструмента и его силы (сильный, умеренно сильный и т.д.);\n
· выделение кластерной структуры рынка, отрасли, сектора по некоторому набору характеристик;\n
· динамическое управление портфелем;\n
· прогноз волатильности;\n
· оценка рисков;\n
· предсказание наступления кризиса и прогноз его развития;\n
· выбор активов и др.\n
Кроме описанных выше сфер деятельности, технология DataMining может применяться в самых разнообразных областях бизнеса, где есть необходимость в анализе данных и накоплен некоторый объем ретроспективной информации.\n\n
Применение DataMining в CRM\n
Одно из наиболее перспективных направлений применения DataMining – использование данной технологии в аналитическом CRM.\n
CRM (CustomerRelationshipManagement) - управление отношениями с клиентами.\n
При совместном использовании этих технологий добыча знаний совмещается с "добычей денег" из данных о клиентах.\n
Важным аспектом в работе отделов маркетинга и отдела продаж является составление целостного представления о клиентах, информация об их особенностях, характеристиках, структуре клиентской базы. В CRM используется так называемое профилирование клиентов, дающее полное представление всей необходимой информации о клиентах.\n
Профилирование клиентов включает следующие компоненты: сегментация клиентов, прибыльность клиентов, удержание клиентов, анализ реакции клиентов. Каждый из этих компонентов может исследоваться при помощи DataMining, а анализ их в совокупности, как компонентов профилирования, в результате может дать те знания, которые из каждой отдельной характеристики получить невозможно.\n\n
WebMining\n
WebMining можно перевести как "добыча данных в Web".\n
Интеллект готов "открыть новую главу" в стремительном развитии электронного бизнеса. Способность определять интересы и предпочтения каждого посетителя, наблюдая за его поведением, является серьезным и критичным преимуществом конкурентной борьбы на рынке электронной коммерции.\n
Системы WebMining могут ответить на многие вопросы, например, кто из посетителей является потенциальным клиентом Web-магазина, какая группа клиентов Web-магазина приносит наибольший доход, каковы интересы определенного посетителя или группы посетителей.\n\n
</item>
        <!--11-->
        <item>11.РЕЛЯЦИОННЫЕ ХРАНИЛИЩА ДАННЫХ (ROLAP).\n\n\n\n\n
ROLAP (реляционная OLAP) — OLAP-системы, которые имеют прямой доступ к существующим базам данных или используют данные, выгруженные в собственные локальные таблицы.\n
Общие сведения\n
Аналитические запросы в ROLAP строятся над виртуальным многомерным представлением данных, и их выполнение происходит на уровне реляционной базы данных, то есть выполняются SQL-запросы над реляционной системой. Основными составляющими архитектуры баз данных являются таблица фактов (fact table) и таблицы измерений (dimension tables). Таблица фактов является основной таблицей базы данных. В ней обычно содержатся сведения об объектах или событиях, совокупность которых будет подвергнута анализу. Таблицы измерений содержат постоянные либо редко изменяемые данные. Они содержат как минимум одно описательное поле и целочисленное ключевое поле для однозначной идентификации измеряемой величины. Таблица измерений обязательно должна находиться в отношении «один ко многим» с таблицей фактов; если каждое измерение находится в одной таблице измерений, то такая схема называется «звезда» (star schema). Если же хотя бы одно из измерений находится в нескольких взаимосвязанных таблицах, то такая схема построения называется «снежинка» (snowflake schema).\n
Условия применения\n
Если многомерная модель реализуется в виде реляционной базы данных, необходимо ее представлять как длинные и «узкие» таблицы фактов и сравнительно небольшие и «широкие» таблицы измерений. Таблицы фактов содержат числовые значения ячеек гиперкуба, а остальные таблицы определяют содержащую их многомерную совокупность измерений. Часть информации можно получать с помощью динамической агрегации данных, распределенных по нормализованным структурам, отличающимся по своей архитектуре от «звезды», но в этом случае включающие агрегацию запросы при высоконормализованной структуре БД могут выполняться довольно медленно. Представление многомерной информации с помощью звездообразных реляционных моделей устраняет проблему оптимизации хранения разреженных матриц, остро стоящую перед многомерными СУБД , в которых проблема разреженности решается специальным выбором схемы. Хотя для хранения каждой ячейки используется целая запись, включающая, кроме непосредственно значений, вторичные ключи — ссылки на таблицы измерений, несуществующие значения просто не включаются в таблицу фактов.\n
Оценка качества\n
ROLAP-системы имеют свои преимущества и недостатки в сравнении с многомерными системами.\n
Достоинства\n
•	реляционные СУБД могут работать с очень большими БД и имеют развитые функции администрирования. При использовании ROLAP размер хранилища не является настолько важным параметром, как в случае с MOLAP\n
•	при оперативной аналитической обработке содержимого хранилища данных инструменты ROLAP позволяют производить анализ непосредственно над хранилищем, ведь обычно корпоративные хранилища данных реализуются с помощью реляционных СУБД\n
•	при изменяющейся размерности задачи, когда изменения в структуру измерений вносятся достаточно часто, ROLAP системы с динамическим представлением размерности предстают наилучшим решением, так как в них такие манипуляции не требуют физической реорганизации БД.\n
•	Системы ROLAP могут функционировать на гораздо менее мощных клиентских станциях, поскольку основная вычислительная нагрузка приходится на сервер, где выполняются сложные аналитические SQL-запросы, формируемые системой\n
•	реляционные СУБД обеспечивают значительно более высокий уровень защиты данных и хорошие возможности разграничения прав доступа\n
Недостатки\n
•	Ограниченные возможности расчета значений функционального типа.\n
•	Меньшая производительность, чем у MOLAP. Для обеспечения сравнимой с MOLAP производительности реляционные системы требуют тщательной проработки схемы БД и специальной настройки индексов. Но в результате такой работы производительность хорошо настроенных реляционных систем при использовании схемы «звезда» сравнима с производительностью систем на основе многомерных БД.\n

</item>
        <!--12-->
        <item>12.ТЕХНОЛОГИЯ OLAP. СУЩНОСТЬ МНОГОМЕРНОГО ПРЕДСТАВЛЕНИЯ ДАННЫХ.\n\n\n\n
OLAP (англ. online analytical processing, интерактивная аналитическая обработка) — технология обработки данных, заключающаяся в подготовке суммарной (агрегированной) информации на основе больших массивов данных, структурированных по многомерному принципу. Реализации технологии OLAP являются компонентами программных решений класса Business Intelligence.\n
Основоположник термина OLAP — Эдгар Кодд, предложил в 1993 году «12 правил аналитической обработки в реальном времени» (по аналогии с ранее сформулированными «12 правил для реляционных баз данных»).\n\n

Действие OLAP \n
Причина использования OLAP для обработки запросов — скорость. Реляционные базы данных хранят сущности в отдельных таблицах, которые обычно хорошо нормализованы. Эта структура удобна для операционных баз данных (системы OLTP), но сложные многотабличные запросы в ней выполняются относительно медленно.
OLAP-структура, созданная из рабочих данных, называется OLAP-куб. Куб создаётся из соединения таблиц с применением схемы звезды или схемы снежинки. В центре схемы звезды находится таблица фактов, которая содержит ключевые факты, по которым делаются запросы. Множественные таблицы с измерениями присоединены к таблице фактов. Эти таблицы показывают, как могут анализироваться агрегированные реляционные данные. Количество возможных агрегирований определяется количеством способов, которыми первоначальные данные могут быть иерархически отображены.\n
Например, все клиенты могут быть сгруппированы по городам или регионам страны (Запад, Восток, Север и так далее), таким образом, 50 городов, восемь регионов и две страны составят три уровня иерархии с 60-ю членами. Также клиенты могут быть объединены по отношению к продукции; если существуют 250 продуктов по 20 категориям, три группы продукции и три производственных подразделения, то количество агрегатов составит 16 560. При добавлении измерений в схему количество возможных вариантов быстро достигает десятков миллионов и более.\n
OLAP-куб содержит базовые данные и информацию об измерениях (агрегаты). Куб потенциально содержит всю информацию, которая может потребоваться для ответов на любые запросы. При огромном количестве агрегатов зачастую полный расчёт происходит только для некоторых измерений, для остальных же производится «по требованию».\n
Существуют три типа OLAP:\n
o	многомерная OLAP (Multidimensional OLAP — MOLAP);\n
o	реляционная OLAP (Relational OLAP — ROLAP);\n
o	гибридная OLAP (Hybrid OLAP — HOLAP).\n
MOLAP — классическая форма OLAP, так что её часто называют просто OLAP. Она использует суммирующую базу данных и создаёт требуемую многомерную схему данных с сохранением как базовых данных, так и агрегатов.\n
ROLAP работает напрямую с реляционной базой данных, факты и таблицы с измерениями хранятся в реляционных таблицах, и для хранения агрегатов создаются дополнительные реляционные таблицы.\n
HOLAP использует реляционные таблицы для хранения базовых данных и многомерные таблицы для агрегатов.\n
Особым случаем ROLAP является «ROLAP реального времени» (Real-time ROLAP — R-ROLAP). В отличие от ROLAP в R-ROLAP для хранения агрегатов не создаются дополнительные реляционные таблицы, а агрегаты рассчитываются в момент запроса. При этом многомерный запрос к OLAP-системе автоматически преобразуется в SQL-запрос к реляционным данным.\n
Каждый тип хранения имеет определённые преимущества, хотя есть разногласия в их оценке у разных производителей. MOLAP лучше всего подходит для небольших наборов данных, он быстро рассчитывает агрегаты и возвращает ответы, но при этом генерируются огромные объёмы данных. ROLAP считается более масштабируемым решением, притом более экономичным к пространству хранения, но с ограничениями по возможностям аналитической обработки. HOLAP находится посреди этих двух подходов, он достаточно хорошо масштабируется, и позволяет преодолеть ряд ограничений. Архитектура R-ROLAP позволяет производить многомерный анализ OLTP-данных в режиме реального времени.\n
Сложность в применении OLAP состоит в создании запросов, выборе базовых данных и разработке схемы, в результате чего большинство продуктов OLAP поставляются вместе с огромным количеством предварительно настроенных запросов. Другая проблема — в базовых данных, они должны быть полными и непротиворечивыми.\n
Реализации OLAP\n
Исторически первой многомерной системой управления базами данных, по существу являющейся OLAP-реализацией, считается система Express, разработанная в 1970-м году компанией IRI (позднее права на продукт были приобретены корпорацией Oracle и превращён в OLAP-опцию для Oracle Database). Термин OLAP ввёл Эдгар Кодд в публикации в журнале Computerworld в 1993 году, в которой он предложил 12 принципов аналитической обработки, по аналогии с 12 правилами для реляционных баз данных, сформулированными им же десятилетием ранее, в качестве референтного продукта, удовлетворяющего предложенным принципам, Кодд указал систему Essbase компании Arbor (поглощённой в 1997 году компанией Hyperion, которую, в свою очередь, в 2007-м году купила Oracle). Примечательно, что впоследствии публикация была изъята из архивов Computerworld из-за возможного конфликта интересов, так как Кодд позднее оказывал консультационные услуги для Arbor.\n
С точки зрения реализации, делятся на «физическую OLAP» и «виртуальную» (реляционную, англ. Relational OLAP, ROLAP). «Физическая», в свою очередь, в зависимости от реализации подразделяется на многомерную (англ. Multidimensional OLAP, MOLAP) и гибридную — (англ. Hybrid OLAP, HOLAP).\n
В первом случае наличествует программа, выполняющая на этапе предварительной загрузки данных в OLAP предварительный расчёт агрегатов (вычислений по нескольким исходным значениям, например «итог за месяц»), которые затем сохраняются в специальную многомерную базу данных, обеспечивающую быстрое извлечение и экономичное хранение.\n
Гибридная реализация является комбинацией: сами данные хранятся в реляционной базе данных, а агрегаты — в многомерной.\n
В ROLAP-реализациях все данные хранятся и обрабатываются в реляционных системах управления базами данных, а агрегаты могут не существовать вообще или создаваться по первому запросу к базе данных или кэше аналитического программного обеспечения.\n
С точки зрения пользователя, все варианты выглядят похожими по возможностям. Наибольшее применение OLAP находит в продуктах для финансового планирования, хранилищах данных, решениях класса Business Intelligence.\n
Среди коммерческих продуктов выделяют: Microsoft SQL Server Analysis Services, Essbase, PowerPlay, BusinessObjects, MicroStrategy, SAP BW, Cartesis Magnitude, Oracle Database OLAP Option, TM1. Существует несколько свободных решений, среди них отмечаются Mondrian и Palo.\n

</item>
        <!--13-->
        <item>13.АЛГОРИТМЫ ИНТЕЛЛЕКТУАЛЬНОГО АНАЛИЗА ДАННЫХ.\n\n\n\n
Алгоритм интеллектуального анализа данных представляет собой механизм, создающий модель интеллектуального анализа данных. Чтобы создать модель, алгоритм сначала анализирует набор данных, осуществляя поиск определенных закономерностей и трендов. Алгоритм использует результаты этого анализа для определения параметров модели интеллектуального анализа данных. Затем эти параметры применяются ко всему набору данных, чтобы выявить пригодные к использованию закономерности и получить подробную статистику.\n
Ниже перечислены алгоритмы интеллектуального анализа данных, реализованные в Microsoft SQL Server 2008 R2 (указание на Майкрософт говорит о том, что это ее реализации алгоритмов, а приводимые английские названия понадобятся нам в дальнейшем):\n\n
1.	Упрощенный алгоритм Байеса (Майкрософт) - MicrosoftNaiveBayes;\n
Упрощенный алгоритм Байеса является алгоритмом классификации на основе Байеса теоремах и может использоваться как для произвольного, так и для прогнозного моделирования. Слово «упрощенный» в его названии указывает на то, что алгоритм использует методы Байеса, но не учитывает возможные зависимости.\n
Данный алгоритм требует меньшего количества вычислений, чем другие алгоритмы Microsoft, и может применяться для быстрого формирования моделей интеллектуального анализа данных для обнаружения отношений между входными и прогнозируемыми столбцами. Этот алгоритм можно использовать для первоначального исследования данных, а затем применить результаты для создания дополнительных моделей интеллектуального анализа с другими алгоритмами, требующими большего количества вычислений и являющимися более точными.\n\n
2.	Алгоритм дерева принятия решений (Майкрософт) - MicrosoftDecisionTrees;\n
Алгоритм дерева принятия решений (Microsoft) представляет собой алгоритм регрессии и классификации для использования в прогнозном моделировании дискретных и непрерывных атрибутов.\n
Для дискретных атрибутов алгоритм осуществляет прогнозирования на основе связи между входными столбцами в наборе данных. Он использует значения этих столбцов (известные как состояния) для прогнозирования состояний столбца, который обозначается как прогнозируемый. Алгоритм идентифицирует входные столбцы, которые коррелированы с прогнозируемым столбцом. Например, в сценарии для прогнозирования того, какие заказчики, скорее всего, приобретут велосипед, если девять из десяти молодых заказчиков покупают велосипед, но только двое из более старших заказчиков делают это, то алгоритм заключает, что возраст является хорошим прогнозом приобретения велосипеда. Дерево решений осуществляет прогнозирование на основе этой тенденции в направлении конкретного результата.\n
Для непрерывных атрибутов алгоритм использует линейную регрессию для определения места разбиения дерева решений.\n
Если несколько столбцов установлены как прогнозируемые или если входные данные содержат вложенную таблицу, которая задана как прогнозируемая, то алгоритм строит отдельное дерево решений для каждого прогнозируемого столбца\n\n
3.	Алгоритм временных рядов (Майкрософт) - MicrosoftTimeSeries;\n
Алгоритм временных рядов ( Microsoft ) предоставляет несколько алгоритмов, оптимизированных для прогноза непрерывных значений, таких как продажи продуктов, во времени. В отличие от других алгоритмов Microsoft , таких как деревья принятия решений, модель временных рядов не требует дополнительных столбцов новых сведений, чтобы прогнозировать тренд. С помощью модели временных рядов можно прогнозировать тенденции на основе только исходного набора данных, использованного для создания модели. При прогнозировании можно вводить в модель новые данные и автоматически задействовать их при анализе тенденций.\n
Сочетание исходных данных и прогнозируемых данных называется рядом.\n
Важной характеристикой алгоритма временных рядов ( Microsoft ) является его способность выполнять перекрестный прогноз. При обучении алгоритма двумя отдельными, но связанными друг с другом рядами можно использовать итоговую модель для прогнозирования исхода одного ряда на основе поведения другого ряда. Например, наблюдаемые продажи одного продукта могут оказать влияние на прогнозируемые продажи другого продукта. Перекрестные прогнозы также полезны при создании общей модели, которую можно применить к нескольким рядам. Например, прогнозы для определенного региона нестабильны, так как в ряду недостаточно данных хорошего качества. Общую модель можно обучить на среднем значении всех четырех регионов, а затем применить модель к отдельным рядам, чтобы подготовить более стабильные прогнозы для каждого региона.\n\n
4.Алгоритм кластеризации (Майкрософт) - MicrosoftClustering;\n
Алгоритм кластеризации Microsoft является алгоритмом сегментации или кластеризации , который выполняет итерацию вариантов в наборе данных, чтобы сгруппировать их в кластеры, содержащие подобные характеристики. Такие группирования полезно использовать для просмотра данных, выявления в них аномалий и создания прогнозов.\n
Модели кластеризации определяют связи в наборе данных, который невозможно логически получить с помощью случайного наблюдения. Например, можно логически догадаться, что люди, добирающиеся на работу на велосипеде, не обязательно живут далеко от работы. Алгоритм может найти другие не очевидные характеристики велосипедистов. На следующей диаграмме кластер А соответствует людям, добирающимся до работы на машине, а кластер Б — людям, добирающимся до работы на велосипеде.\n
Алгоритм кластеризации отличается от других алгоритмов интеллектуального анализа данных, например алгоритма дерева принятия решений Microsoft , в котором не требуется назначать прогнозируемый столбец, необходимый для создания модели кластеризации. Алгоритм кластеризации обучает модель строго на основе связей, существующих в данных и на основе кластеров, идентифицированных алгоритмом.\n\n
5.Алгоритм кластеризации последовательностей (Майкрософт) - MicrosoftSequenceClustering;\n
Алгоритм кластеризации последовательностей Microsoft — это уникальный алгоритм сочетающий в себе анализ последовательностей и кластеризацию. Данный алгоритм можно использовать для просмотра данных, содержащих события, которые могут быть связаны в последовательность. Алгоритм находит самые распространенные последовательности и выполняет кластеризацию для поиска идентичных последовательностей. Ниже описаны типы последовательностей, которые можно использовать в качестве данных для машинного обучения, чтобы получить сведения о стандартных проблемах или бизнес-сценариях:\n
•	Сведения о посещениях и схемах щелчков, которые создаются, когда пользователи переходят по веб-сайту или просматривают его.\n
•	Журналы, в которых перечислены события, предшествовавшие инциденту, такие как сбой жесткого диска или взаимоблокировка сервера.\n
•	Записи транзакций, описывающие порядок, в котором клиент добавляет в корзину товары, выбранные в интернет-магазине.\n
•	Записи, следящие за взаимодействием с клиентом или пациентом во времени для прогнозирования отмены услуг или других нежелательных итогов.\n
Этот алгоритм во многом напоминает алгоритм кластеризации Microsoft . Однако вместо поиска кластеров вариантов, содержащих похожие атрибуты, алгоритм кластеризации последовательностей Microsoft находит кластеры вариантов, содержащие похожие пути в последовательности.\n\n
6.Алгоритм взаимосвязей Майкрософт - MicrosoftAssociationRules;\n
Алгоритм взаимосвязей Microsoft часто используется для механизмов выработки рекомендаций. Механизм рекомендаций рекомендует продукты пользователям на основе элементов, которые они уже купили или к которым проявили интерес. Алгоритм взаимосвязей Microsoft удобно использовать для анализа потребительской корзины.
Модели взаимосвязей построены на наборах данных, содержащих идентификаторы для отдельных вариантов и элементов этих вариантов. Группа элементов в варианте называется набор элементов. Модель взаимосвязей состоит из рядов наборов элементов и правил, описывающих, как эти элементы группируются в вариантах. Правила, определяемые алгоритмом, могут использоваться для прогнозирования вероятных будущих покупок покупателей на основе элементов, уже имеющихся в корзине покупателя. На следующей диаграмме представлен ряд правил в наборе элементов.\n
Алгоритм взаимосвязей Microsoft потенциально может находить множество правил внутри набора данных. Для описания набора элементов и формируемых ими правил алгоритм использует два параметра: мощность несущего множества и вероятность. Например, если X и Y представляют два элемента, которые могут находиться в корзине для покупок, то параметр несущего множества будет равен количеству вариантов в наборе данных, содержащих сочетание элементов X и Y. Используя параметр несущего множества в сочетании с пользовательскими параметрами MINIMUM_SUPPORT и MAXIMUM_SUPPORT , алгоритм управляет количеством создаваемых наборов элементов. Параметр вероятности, называемый также достоверностью, представляет часть вариантов в наборе данных, содержащих X и Y. Используя параметр вероятности в сочетании с параметром MINIMUM_PROBABILITY , этот алгоритм управляет количеством сформированных правил.\n\n
7.	Алгоритм нейронной сети (Майкрософт) - MicrosoftNeuralNetwork;\n
Алгоритм нейронной сети Microsoft представляет собой реализацию архитектуры распространенной и адаптируемой нейронной сети для машинного обучения. Алгоритм работает путем тестирования каждого возможного состояния входного атрибута с каждым возможным состоянием прогнозируемого атрибута и использует обучающие данные для вычисления вероятностей каждого сочетания. Эти вероятности можно использовать для задач классификации или регрессии, а также для прогнозирования исхода на основе входных атрибутов. Нейронную сеть можно также использовать для анализа взаимосвязей.\n
При создании модели интеллектуального анализа данных с помощью алгоритма нейронной сети Microsoft можно включить несколько выходных данных, а алгоритм создаст несколько сетей. Количество сетей, содержащихся в одной модели интеллектуального анализа данных, зависит от числа состояний (или значений атрибута) во входных столбцах, а также от числа прогнозируемых столбцов, используемых в модели интеллектуального анализа данных, и числа состояний в этих столбцах.\n\n
8.	Алгоритм линейной регрессии (Майкрософт) - MicrosoftLinearRegression;\n
Алгоритм линейной регрессии Microsoft является разновидностью алгоритма дерева принятия решений Microsoft, помогающего рассчитать линейную связь между зависимой и независимой переменной, а затем использовать эту связь при прогнозировании.\n
Связь принимает вид формулы линии, представляющей ряд данных. Например, линия на следующей диаграмме является наилучшим линейным представлением данных.\n
Каждой точке на диаграмме соответствует ошибка, связанная с ее расстоянием от линии регрессии. Коэффициенты a и b в уравнении регрессии регулируют угол и положение линии регрессии. Регрессивное уравнение можно получать с помощью подбора коэффициентов a и b до тех пор, пока сумма ошибок, связанных с этими точками, не станет минимальной.\n
Существуют другие типы регрессии, в которых используется несколько переменных, а также нелинейные методы регрессии. Однако линейная регрессия является полезным и широко известным методом моделирования ответа на изменение в каком-либо базовом факторе.\n\n
9.	Алгоритм логистической регрессии (Майкрософт) - MicrosoftLogisticRegression.\n
Логистическая регрессия является известным статистическим методом, применяемым для моделирования двоичных результатов.\n
Существуют различные варианты внедрения логистической регрессии в статистических исследованиях. Такие варианты различаются по методам обучения, реализованным в них. Алгоритм логистической регрессии Microsoft реализован на основе вариации алгоритма нейронной сети Microsoft . Этот алгоритм обладает многими качествами нейронных сетей, но более прост в обучении.\n
Одним из преимуществ логистической регрессии является гибкость алгоритма, способного принимать входные данные любого рода и поддерживать несколько различных аналитических задач.\n
•	Использование демографических данных для составления прогнозов о результатах, например оценка риска некоторого заболевания.\n
•	Исследование и взвешивание факторов, влияющих на результат. Например, поиск факторов, побуждающих клиентов совершить повторное посещение магазина.\n
•	Классификация документов, электронной почты и других объектов, имеющих множество атрибутов.\n
</item>
        <!--14-->
        <item>14.ПРОЦЕССЫ ЖИЗНЕННОГО ЦИКЛА ПРОГРАММНЫХ СРЕДСТВ.\n\n\n\n\n
1.Основные процессы жизненного цикла.\n
1.1.Процесс заказа.\n
Процесс заказа определяет работы и задачи заказчика. Процесс заказа состоит из определения потребностей заказчика в системе, программном продукте или программной услуге, подготовки и выпуска заявки на подряд, выбора поставщика и управления процессом заказа до завершения приемки системы, программного продукта или программной услуги.\n
1.2.Процесс поставки.\n
Процесс поставки определяет работы и задачи поставщика. Процесс поставки начинается с решения о подготовке предложения в ответ на заявку на подряд, присланную заказчиком, или с подписания договора с заказчиком на поставку системы, ПП или программной услуги. Затем определяются процедуры и ресурсы, необходимые для управления и обеспечения проекта, включая разработку проектных планов и их выполнение.\n
1.3.Процесс разработки.\n
Процесс разработки определяет работы и задачи разработчика. Данный процесс включает работы по анализу требований, проектированию, программированию, сборке, тестированию, вводу в действие и приемке программного продукта или системы.\n
1.4.Процесс эксплуатации.\n
Процесс эксплуатации определяет работы и задачи оператора. Данный процесс включает эксплуатацию программного продукта и поддержку пользователей в процессе эксплуатации.\n
1.5.Процесс сопровождения.\n
Процесс сопровождения определяет работы и задачи персонала сопровождения и реализуется при модификациях программного продукта. Цель процесса – изменение существующего ПП при сохранении его целостности. Процесс охватывает вопросы переносимости и снятия ПП с эксплуатации.\n\n
2.Вспомогательные процессы жизненного цикла.\n
2.1	Процесс документирования.\n
Процесс документирования является процессом формализованного описания информации, созданной в процессе или работе жизненного цикла. Он включает планирование, проектирование, разработку, выпуск, редактирование, распространение и сопровождение документов по программному продукту.\n
2.2 Процесс управления конфигурацией.\n
Процесс управления конфигурацией является процессом применения административных и технических процедур на всем протяжении ЖЦ ПС для определения состояния (базовой линии) программных объектов в системе, управления их изменениями и выпуском.\n
2.3	Процесс обеспечения качества\n
Процесс обеспечения качества является процессом обеспечения гарантий того, что программные продукты и процессы в жизненном цикле проекта соответствуют требованиям и планам. Данный процесс должен быть независимым от субъектов, участвующих в проекте. Это позволяет достичь объективности процесса. При обеспечении качества могут использоваться результаты процессов верификации, аттестации, совместного анализа, аудита и решения проблем\n
2.4	Процесс верификации.\n
Процесс верификации является процессом определения того, что программные продукты функционируют в полном соответствии с требованиями и условиями, реализованными в предшествующих работах.\n
Данное определение является не совсем понятным для лиц, некомпетентных в области верификации. Кроме того, оно сужает применимость верификации только до программных продуктов. Для пояснения данного определения следует рассмотреть само понятие верификации. Термин верификация (verification) обозначает подтверждение с помощью экспертизы и представления объективных доказательств того, что конкретные требования полностью реализованы. В процессе разработки верификация связана с экспертизой результатов данной работы с целью определения их соответствия установленным на входе данной работы требованиям. Таким образом, верификация может применяться не только к программным продуктам, но и к любым другим результатам работы. Например, верификации могут подвергаться требования, системная и программная архитектура, документация, методы, планы и т.п.\n
В этой связи более понятным и близким к истине является следующее определение процесса верификации. Процесс верификации – это процесс определения того, что результаты работы соответствуют требованиям или условиям, установленным на входе данной работы.\n
Процесс верификации может включать анализ, проверку и тестирование.\n
Объектами анализа и проверки могут являться, например, документация и исходные тексты программных модулей. Объектами тестирования могут являться исполнимые коды программных модулей, компонентов, промежуточных и конечного программных продуктов.\n
Данный процесс называется процессом независимой верификации, если организация–исполнитель не зависит от поставщика, разработчика, оператора или персонала сопровождения.\n
2.5	Процесс аттестации и его структура.\n
Процесс аттестации является процессом определения полноты соответствия установленных требований, созданной системы или программного продукта их функциональному назначению. Чтобы пояснить это определение, следует рассмотреть понятие аттестации.\n
Термин аттестация (validation) обозначает подтверждение экспертизой и представлением объективных доказательств того, что конкретные требования к конкретным объектам полностью реализованы. В процессе разработки аттестация связана с экспертизой продукта в целях определения его соответствия потребностям пользователя (то есть исходным требованиям к проекту).\n
Аттестации (проверке на соответствие исходным требованиям) могут подвергаться любые промежуточные продукты процесса разработки. Аттестация может проводиться на начальных этапах работы и как часть работы по обеспечению приемки ПС.\n
Данный процесс называется процессом независимой аттестации, если организация–исполнитель не зависит от поставщика, разработчика, оператора или персонала сопровождения.\n
2.6	Процесс совместного анализа.\n
Процесс совместного анализа является процессом оценки состояний и результатов работ по проекту. Совместные анализы проводятся в течение всего договора и применяются как на уровне управления проектом, так и на уровне его технической реализации. Данный процесс может выполняться двумя любыми сторонами, участвующими в договоре, когда одна сторона (анализирующая) проверяет другую (анализируемую).\n
2.7	Процесс аудита.\n
Процесс аудита является процессом определения соответствия требованиям, планам и условиям договора. Данный процесс может выполняться двумя сторонами, участвующими в договоре, когда одна сторона (ревизующая) проверяет другую сторону (ревизуемую).\n
2.8	Процесс решения проблем.\n
Процесс решения проблем является процессом анализа и решения проблем (включая обнаруженные несоответствия), которые обнаружены в ходе выполнения разработки, эксплуатации, сопровождения или других процессов.\n\n
3. Организационные процессы жизненного цикла.\n
3.1 Процесс управления.\n
Процесс управления состоит из общих работ и задач, которые могут быть использованы любой стороной, управляющей соответствующим процессом. За управление продуктом, проектом, работами и задачами основных и вспомогательных процессов отвечает администратор.\n
3.2 Процесс создания инфраструктуры\n
Процесс создания инфраструктуры является процессом установления и сопровождения инфраструктуры, необходимой для любого другого процесса. Инфраструктура содержит технические и программные средства, инструментальные средства, методики, стандарты и условия для разработки, эксплуатации или сопровождения.\n
3.3 Процесс обучения\n
Процесс обучения является процессом обеспечения первоначального и продолженного обучения персонала работам по заказу, поставке, разработке, эксплуатации или сопровождению программного проекта.\n
3.4 Процесс усовершенствования\n
Процесс усовершенствования является процессом установления, оценки, измерения, контроля и улучшения любого процесса жизненного цикла программных средств.\n</item>
        <!--15-->
        <item>15.ПРОЕКТИРОВАНИЕ ПРОГРАММНЫХ СРЕДСТВ.\n\n\n\n\n
Проектирование программных средств\n
Проектирование ПС в основном рассматривается как двух-шаговый процесс:\n
– Архитектурное проектирование – декомпозиция структуры (статической) и организации (динамической) компонент;\n
– Детализация архитектуры – описывает специфическое поведение и характеристики отдельных компонент.\n
Выходом этого процесса является набор моделей и артефактов, содержащих результаты решений, принятых по способам реализации требований в программном коде.\n
Принципы проектирования\n
В качестве основных принципов проектирования выделим следующие:\n
Абстракция\n
Абстракция – отвлечение в процессе познания от несущественных сторон, свойств, связей объекта (предмета или явления) с целью выделения их существенных, закономерных признаков; абстрагирование; теоретическое обобщение как результат такого отвлечения.\n
Абстракция – модель, упрощающая поставленную проблему до рамок, значимых для заданного контекста.\n
В контексте проектирования программных систем существует два механизма абстракции – параметризация и детализация. При этом, абстракция через детализацию может быть: процедурной (связанной с поведением), абстракцией данных (связанной с информацией) и абстракцией контроля (связанной с управлением системой и обрабатываемой ею информацией).\n
Связанность и соединение\n
Связанность – определяет силу взаимосвязи между модулями. Соединение – определяет взаимосвязь элементов внутри модуля, внутренние связи.\n
Декомпозиция и разбиение на модули\n
Декомпозиция и разбиение на модули сложных программных систем производится с целью получения более мелких и относительно независимых программных компонентов, каждый из которых несет различную функциональность.\n
Инкапсуляция\n
Предполагает группировку и упаковку элементов и внутренних деталей абстракции в отношении реализации с тем, чтобы эти детали были недоступны пользователям элементов. В качестве «пользователя» одного компонента может выступать другой компонент. Более того, при использовании объектно-ориентированного подхода, наследники компонентов могут не иметь доступа ко внутренним деталям реализации компонента, который является их предком.\n
Разделение интерфейса и реализации\n
Данная техника предполагает отделение компонента через специфицирование интерфейса, известного и доступного клиентам (или другим компонентам), от непосредственных деталей реализации.\n
Достаточность, полнота и простота\n
Создаваемые программные компоненты должны обладать всеми необходимыми характеристиками, определенными абстракцией (моделью), но не должны включать функциональность, отсутствующую в модели.\n
Структура и архитектура программного обеспечения\n
Архитектура программного обеспечения (англ. software architecture) – это структура программы или вычислительной системы, которая включает программные компоненты, видимые снаружи свойства этих компонентов, а также отношения между ними.\n
Архитектура ПО является реализацией нефункциональных требований к системе, в то время как проектирование ПО является реализацией функциональных требований.\n
Архитектура ПО обычно содержит несколько видов, которые аналогичны различным типам чертежей в строительстве зданий. В онтологии, установленной ANSI / IEEE 1471—2000, виды являются экземплярами точки зрения, где точка зрения существует для описания архитектуры с точки зрения заданного множества заинтересованных лиц.\n
Примеры видов:\n
- Функциональный/логический вид\n
- Вид код/модуль\n
- Вид разработки (development)/структурный\n
- Вид параллельности выполнения/процесс/поток\n
- Физический вид/вид развертывания\n
- Вид с точки зрения действий пользователя\n
- Вид с точки зрения данных\n
На сегодняшний день сформировался взгляд на архитектуру, как на приложение общих принципов организации программных компонент, что привело к накоплению множества подходов и созданию различных архитектурных «фреймворков», то есть систематизированных комплексов методов, практик и инструментов, призванных формализовать имеющийся в индустрии опыт.\n
Фреймворк (англ. framework — каркас, структура) – структура программной системы или программное обеспечение, облегчающее разработку и объединение разных компонентов большого программного проекта. В отличие от библиотек, которые объединяют набор подпрограмм близкой функциональности, фреймворк содержит в себе большое количество разных по назначению библиотек. Некоторые авторы используют слово «каркас» в качестве основного. С их точки зрения можно говорить о каркасном подходе как о подходе к построению программ, где любая конфигурация программы строится из двух частей: первая, постоянная часть – каркас, не меняющийся от конфигурации к конфигурации и несущая в себе гнезда, в которых размещается вторая, переменная часть – сменные модули (или точки расширения).\n
Фреймворк реализуется как множество конкретных и абстрактных классов, а также определений способов их взаимоотношения. Конкретные классы обычно реализуют взаимные отношения между классами. Абстрактные классы представляют собой точки расширения, в которых каркасы могут быть использованы или адаптированы. Точка расширения — это та часть фреймворка, для которого не приведена реализация. Соответственно каркас концептуальной модели состоит из концептуальных классов, а каркас программной системы из классов языка программирования общего назначения. Процесс создания фреймворка заключается в выборе подмножества задач проблемы и их реализаций. В ходе реализаций общие средства решения задач заключаются в конкретных классах, а изменяемые средства выносятся в точки расширения.\n
Примеры такой систематизации в форме фреймворков:\n
TOGAF [TOGAF81, 2003] – The Open Group Architecture Framework (на момент первичного написания данной главы доступен в версии 8.1, впервые опубликованной в декабре 2003 года; в 2009 году вышла версия TOGAF 9)\n
Модель Захмана – Zachman Framework.\n
Руководство по архитектуре электронного правительства E-Gov Enterprise Architecture Guidance [E-Gov, 2002]\n
Архитектурные структуры и точки зрения\n
Принцип сужения предметной области с использованием точки зрения [пособие по ТССА] широко используется в программной инженерии. Система может рассматриваться с разных точек зрения – поведенческой, структурной, логической, физической и т.п. Следовательно, можно получить множество различных архитектурных представлений. Архитектурное представление может быть определено, как частные аспекты программной архитектуры, рассматривающие специфические свойства программной системы. Дизайн системы – комплекс архитектурных представлений, достаточный для реализации системы и удовлетворения требований, предъявляемых к системе.\n
Архитектурная структура – применение архитектурной точки зрения и представления к конкретной системе и описания тех деталей, которые необходимы для реализации системы, но отсутствуют в используемом представлении. Таким образом, представление, концентрируясь на заданном подмножестве свойств является составной частью и/или результатом точки зрения, а архитектурная структура – дальнейшей детализацией в отношении проектируемой системы. В качестве примера архитектурных точек зрения можно рассматривать модель Захмана.\n
Архитектурные стили\n
Архитектурный стиль – это мета-модель или шаблон проектирования макро-архитектуры – на уровне модулей, «крупноблочного» взгляда. Архитектурный стиль – набор ограничений, определяющих семейство архитектур, которые удовлетворяют этим ограничениям.\n
Шаблоны проектирования\n
Архитектурный стиль определяет макро-архитектуру системы, а шаблоны проектирования задают микроархитектуру, то есть определяют частные аспекты деталей архитектуры.\n
Чаще всего говорят о следующих группах шаблонов проектирования:\n
– Шаблоны создания (Creational patterns) - builder, factory, prototype, singleton\n
– Структурные шаблоны (Structural patterns) - adapter, bridge, composite, decorator, facade, flyweight, proxy\n
– Шаблоны поведения (Behavioral patterns) - command, interpreter, iterator, mediator, memento, observer, state, strategy, template, visitor\n

</item>
        <!--16-->
        <item>16.МОДУЛЬНОЕ ПРОГРАММИРОВАНИЕ.\n\n\n\n\n
Мо́дульное программи́рование — это организация программы как совокупности небольших независимых блоков, называемых модулями, структура и поведение которых подчиняются определённым правилам. Использование модульного программирования позволяет упростить тестирование программы и обнаружение ошибок. Аппаратно-зависимые подзадачи могут быть строго отделены от других подзадач, что улучшает мобильность создаваемых программ.\n
Мо́дуль — функционально законченный фрагмент программы. Во многих языках (но далеко не обязательно) оформляется в виде отдельного файла с исходным кодом или поименованной непрерывной её части. Некоторые языки предусматривают объединение модулей в пакеты.\n\n
Модульность программного кода\n
Принцип модульности является средством упрощения задачи проектирования ПС и распределения процесса разработки ПС между группами разработчиков. При разбиении ПС на модули для каждого модуля указывается реализуемая им функциональность, а также связи с другими модулями. Удобство использования модульной архитектуры заключается в возможности обновления (замены) модуля, без необходимости изменения остальной системы.\n
Роль модулей могут играть структуры данных, библиотеки функций, классы, сервисы и др. программные единицы, реализующие некоторую функциональность и предоставляющие интерфейс к ней.\n
Программный код часто разбивается на несколько файлов, каждый из которых компилируется отдельно от остальных. Такая модульность программного кода позволяет значительно уменьшить время перекомпиляции при изменениях, вносимых лишь в небольшое количество исходных файлов, и упрощает групповую разработку. Также это возможность замены отдельных компонентов (таких как jar-файлы, so или dll библиотеки) конечного программного продукта, без необходимости пересборки всего проекта (например, разработка плагинов к уже готовой программе).\n
Одним из методов написания модульных программ является объектно-ориентированное программирование. ООП обеспечивает высокую степень модульности благодаря таким свойствам, как инкапсуляция, полиморфизм и позднее связывание.\n\n
Модульная система модулей\n
Несмотря на то, что модульное программирование никак не связано с деталями конкретного языка (и даже в случае отсутствия явной поддержки со стороны языка может применяться при достаточной дисциплине со стороны программистов), большинство языков выдвигают на верхний уровень свою собственную природу системы модулей, словно перенос системы модулей с одного языка на другой был бы невозможен.\n
В 2000 году Ксавье Лерой предложил делать системы модулей модульными, то есть параметризуемыми описанием конкретного ядра языка со своей системой типов. В качестве примера он продемонстрировал обобщённую реализацию языка модулей ML (как наиболее развитой системы модулей из известных на данный момент) и примеры её инстанцирования на традиционный для неё язык ML и на язык Си.\n
Реализация Лероя сама построена посредством языка модулей ML, а именно в виде функтора, параметризованного данными о ядре языка и описанием его механизма проверки согласования типов. Это значит, что при написании компилятора некоторого языка достаточно описать ядро языка и передать его данному функтору (как библиотечной функции) — в результате получится компилятор расширения известного языка системой модулей ML.\n\n
История концепции модулей\n
История концепции модулей как единиц компиляции восходит к языкам Фортран II и Кобол, то есть, к концу 1950-х годов. В 1976 году появилась публикация, в которой была развита концепция модульности — о языке Mesa (англ.), который был разработан в Xerox PARC. В 1977 году подробно ознакомился с этой концепцией учёный Никлаус Вирт, общаясь с разработчиками в Xerox PARC. Эти идеи были использованы Виртом при создании языка Модула-2, публикация о котором вышла в 1977 году.\n
Термин «модуль» в программировании начал использоваться в связи с внедрением модульных принципов при создании программ. В 1970-х годах под модулем понимали какую-либо процедуру или функцию, написанную в соответствии с определёнными правилами. Например: «модуль должен быть простым, замкнутым (независимым), обозримым (от 50 до 100 строк), реализующим только одну функцию задачи, имеющим одну входную и одну выходную точку».\n
Первым основные свойства программного модуля более-менее чётко сформулировал Д. Парнас (David Parnas) в 1972 году: «Для написания одного модуля должно быть достаточно минимальных знаний о тексте другого». Таким образом, в соответствии с определением, модулем могла быть любая отдельная процедура (функция) как самого нижнего уровня иерархии (уровня реализации), так и самого верхнего уровня, на котором происходят только вызовы других процедур-модулей.\n
Таким образом, Парнас первым выдвинул концепцию скрытия информации (англ. information hiding) в программировании. Однако существовавшие в языках 70-х годов только такие синтаксические конструкции, как процедура и функция, не могли обеспечить надёжного скрытия информации, из-за повсеместного применения глобальных переменных.\n
Решить эту проблему можно было только разработав новую синтаксическую конструкцию, которая не подвержена влиянию глобальных переменных. Такая конструкция была создана и названа модулем. Изначально предполагалось, что при реализации сложных программных комплексов модуль должен использоваться наравне с процедурами и функциями как конструкция, объединяющая и надёжно скрывающая детали реализации определённой подзадачи.\n
Таким образом, количество модулей в комплексе должно определяться декомпозицией поставленной задачи на независимые подзадачи. В предельном случае модуль может использоваться даже для заключения в него всего лишь одной процедуры, если необходимо, чтобы выполняемое ею локальное действие было гарантировано независимым от влияния других частей программы при любых изменениях.\n
Впервые специализированная синтаксическая конструкция модуля была предложена Н. Виртом в 1975 г. и включена в его новый язык Modula . Насколько сильно изменяются свойства языка, при введении механизма модулей, свидетельствует следующее замечание Н.Вирта, сделанное им по поводу более позднего языка Модула-2: «Модули — самая важная черта, отличающая язык Модула-2 от его предшественника Паскаля».\n\n
Реализация в языках программирования\n
Языки, формально поддерживающие концепцию модулей: IBM S/360 Assembler, Кобол, RPG, ПЛ/1, Ада, D, F (англ.), Фортран, Haskell, Blitz BASIC, OCaml, Паскаль, ML, Модула-2, Оберон, Компонентный Паскаль, Zonnon, Erlang, Perl, Python и Ruby. В IBM System использовались «модули» от языков RPG, Кобол и CL, когда программировалась в среде ILE.\n
Модульное программирование может быть осуществлено, даже когда синтаксис языка программирования не поддерживает явное задание имён модулям.\n
Программные инструменты могут создавать модули исходного кода, представленные как части групп — компонентов библиотек, которые составляются с программой компоновщиком.\n
Стандартный Паскаль не предусматривает механизмов раздельной компиляции частей программы с последующей их сборкой перед выполнением. Вполне понятно стремление разработчиков коммерческих компиляторов Паскаля включать в язык средства, повышающие его модульность.\n
Модуль в Паскале — это автономно компилируемая программная единица, включающая в себя различные компоненты раздела описаний (типы, константы, переменные, процедуры и функции) и, возможно, некоторые исполняемые операторы инициирующей части.\n
По своей организации и характеру использования в программе модули Паскаля близки к модулям-пакетам (PACKAGE) языка программирования Ада. В них так же, как и в пакетах Ады, явным образом выделяется некоторая «видимая» интерфейсная часть, в которой сконцентрированы описания глобальных типов, констант, переменных, а также приводятся заголовки процедур и функций. Появление объектов в интерфейсной части делает их доступными для других модулей и основной программы. Тела процедур и функций располагаются в исполняемой части модуля, которая может быть скрыта от пользователя.\n
Модули представляют собой прекрасный инструмент для разработки библиотек прикладных программ и мощное средство модульного программирования. Важная особенность модулей заключается в том, что компилятор размещает их программный код в отдельном сегменте памяти. Длина сегмента не может превышать 64 Кбайт, однако количество одновременно используемых модулей ограничивается лишь доступной памятью, что позволяет создавать большие программы.\n
</item>
        <!--16-->
        <item>16.МОДЕЛИ ПРОГРАММИРОВАНИЯ\n\n\n\n\n
Парадигма программирования — это совокупность идей и понятий, определяющая стиль написания программ. В программировании под парадигмой принято понимать обобщение о том, как должна быть организована работа программы. Парадигма, в первую очередь, определяется базовой программной единицей и самим принципом достижения модульности программы. В качестве этой единицы выступают определение (декларативное, функциональное программирование), действие (императивное программирование), правило (продукционное программирование), диаграмма переходов (автоматное программирование) и другие сущности. В современной индустрии программирования очень часто парадигма программирования определяется набором инструментов программиста, а именно, языком программирования и используемыми библиотеками.\n
Парадигма программирования определяет то, в каких терминах программист описывает логику программы. Например, в императивном программировании программа описывается как последовательность действий, а функциональном программировании представляется в виде выражения и множества определений функций (слово определение (англ. definition) следует понимать в математическом смысле). В популярном объектно-ориентированном программировании программу принято рассматривать как набор взаимодействующих объектов. ООП есть по сути императивное программирование, дополненное принципом инкапсуляции данных и методов в объект (принцип модульности) и наследованием (принципом повторного использования разработанного функционала).\n\n

Императивное и функциональное программирование\n
Императивное программирование — это парадигма программирования, которая, в отличие от декларативного программирования, описывает процесс вычисления в виде инструкций, изменяющих состояние программы. Императивная программа очень похожа на приказы, выражаемые повелительным наклонением в естественных языках, то есть это последовательность команд, которые должен выполнить компьютер.\n
Первыми императивными языками были машинные коды — родной язык программирования для компьютера. В этих языках инструкции были крайне просты, что снижало нагрузку на компьютеры, однако затрудняло написание крупных программ. Императивные языки программирования противопоставляются функциональным и логическим языкам программирования.\n
Императивное программирование наиболее пригодно для реализации небольших подзадач, где очень важна скорость исполнения на современных компьютерах. Кроме этого, работа с внешними устройствами, как правило, описывается в терминах последовательного исполнения операций, что делает такие задачи идеальными кандидатами на императивную реализацию.\n\n

Функциональное программирование — раздел дискретной математики и парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании).\n
Противопоставляется парадигме императивного программирования, которая описывает процесс вычислений как последовательное изменение состояний (в значении, подобном таковому в теории автоматов). При необходимости, в функциональном программировании вся совокупность последовательных состояний вычислительного процесса представляется явным образом, например, как список.\n
Функциональное программирование предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы. Соответственно, не предполагает оно и изменяемость этого состояния (в отличие от императивного, где одной из базовых концепций является переменная, хранящая своё значение и позволяющая менять его по мере выполнения алгоритма).\n
На практике отличие математической функции от понятия «функции» в императивном программировании заключается в том, что императивные функции могут опираться не только на аргументы, но и на состояние внешних по отношению к функции переменных, а также иметь побочные эффекты и менять состояние внешних переменных.\n\n

Логическое и процедурное программирование\n
Логическое программирование — парадигма программирования, а также раздел дискретной математики, изучающий методы и возможности этой парадигмы, основанная на выводе новых фактов из данных фактов согласно заданным логическим правилам.\n
Логическое программирование возникло как упрощение функционального программирования для математиков и лингвистов, решающих задачи символьной обработки. Вместо описания алгоритма решения задачи описывается мир задачи, какие имеются объекты, их свойства и отношения между ними. За основу описания берутся отношения между объектами. Логическая программа представляет собой набор отношений, которые называются фактами, и правил, на основании которых могут быть получены новые отношения. Она не задает никакого процесса вычислений. Это своего рода база данных (БД) о предметной области задачи. Ее применение инициализируется запросом. Поиск ответа на запрос заключается в попытке логического вывода запроса на основании фактов и правил, имеющихся в БД. Поиск решения выполняется специальной программой - интерпретатором.\n\n

Преимущества логического программирования:\n
- задача программиста – описание логической модели предметной области в терминах объектов, их свойств и отношений между ними (без деталей): описание данных и логики их обработки ~ аналогия с ООП;\n
- удобство описания отношений между объектами (реляционная модель);\n
- компактность кода (обработка структурированных данных, лог. правила);\n
- возможность перебора и поиска различных решений, заложенная в язык;\n
- легкость понимания (описание отд. Правил), отладки программ (trace);\n
- легкость описания сложных структур данных (деревья, списки и т.п.);\n
- эффективный метод вычислений – рекурсия\n
- отсутствие указателей, операторов присваивания и безусловного перехода;\n
- множество областей для применения: автоматический перевод, обработка текстов, экспертные системы, САПР, Data-minig системы, автоматическое управление, СУБД, символьные вычисления.\n\n

Процедурное программирование - есть отражение фон Неймановской архитектуры компьютера. Программа, написанная на процедурном языке, представляет собой последовательность команд, определяющих алгоритм решения задачи. Основная идея процедурного программирования - использование памяти для хранения данных. Основная команда- присвоение, с помощью которой определяется и меняется память компьютера. Программа производит преобразование содержимого памяти, изменяя его от исходного состояния к результирующему.\n
Различают следующие языки процедурного программирования:\n
Язык Фортран создан в начале 50-х годов 20-го века для программирования научно-технических задач;\n
Кобол – создан в конце 60-х годов 20-го века для решения задач обработки больших объемов данных, хранящихся на различных носителях данных;\n
Алгол (1960 год) – это многоцелевой расширенный язык программирования. В нем впервые введены понятия “блочная структура программы” и “динамическое распределение памяти”;\n
В середине 60-х годов 20-го века был создан специализированный язык программирования для начинающих – BASIC. Характеризуется простотой освоения и наличием универсальных средств для решения научных, технических и экономических задач, а также задач, например, игровых.\n
Все перечисленные выше языки были ориентированы на различные классы задач, но они в той или иной мере были привязаны к конкретной архитектуре ЭВМ.\n\n

Структурное программирование\n
Структурное программирование — одно из крупнейших достижений в технологии программирования. Хотя самое общее и довольно смутное представление о структурном программировании имеется почти у всех, общепринятого четкого его определения нет. Структурное программирование ставит своей целью писать программы минимальной сложности, заставить программиста мыслить ясно, облегчить восприятие программы.\n
Текст программы должен быть таким, чтобы его можно было читать «сверху - вниз».\n

Структура тела модулей и используемые базовые конструкции программирования должны быть потенциально устойчивыми к аппаратурным сбоям, искажениям исходных данных и к ошибкам в программах.\n
Каждая структура характеризуется единственной точкой передачи управления в структуру (единственный вход) и единственной точкой выхода из структуры.\n
Эти конструкции имеют систематизирующее и дисциплинирующее значение. Простота исходных конструкций структурного программирования предотвращает появление сложных информационных связей и запуганных передач управления.\n
При повышении структурированности модулей снижается сложность программ, возрастает их наглядность, что способствует сокращению числа ошибок. Однако за повышение качества программ приходится расплачиваться дополнительной памятью и временем их реализации на ЭВМ.\n
Структурность программы зависит от используемого языка программирования. Современные программные средства разработки программ являются «наилучшими» языками структурного программирования. Из распространенных языков программирования самыми подходящими считаются Паскаль, Basic, FoxBASE. Структурное программирование, например, на языке Ассемблер почти невозможно. Сам факт использования языка Ассемблера указывает на то, что программа написана в основном в терминах машинного языка.\n
Структурное программирование ориентировано на общение с людьми, а не с машиной, способствует написанию программ, представляющих собой простое и ясное решение задачи.\n
Важно, чтобы программист, еще только приступая к программированию логики, мыслил в терминах основных базовых структурных конструкций.\n\n

Рекурсия и автоматное программирование\n
В программировании рекурсия — вызов функции (процедуры) из неё же самой, непосредственно (простая рекурсия) или через другие функции (сложная или косвенная рекурсия), например, функция A вызывает функцию B, а функция B — функцию A. Количество вложенных вызовов функции или процедуры называется глубиной рекурсии. Рекурсивная программа позволяет описать повторяющееся или даже потенциально бесконечное вычисление, причём без явных повторений частей программы и использования циклов.\n
Структурно рекурсивная функция на верхнем уровне всегда представляет собой команду ветвления (выбор одной из двух или более альтернатив в зависимости от условия (условий), которое в данном случае уместно назвать «условием прекращения рекурсии»), имеющей две или более альтернативные ветви, из которых хотя бы одна является рекурсивной и хотя бы одна — терминальной. Рекурсивная ветвь выполняется, когда условие прекращения рекурсии ложно, и содержит хотя бы один рекурсивный вызов — прямой или опосредованный вызов функцией самой себя. Терминальная ветвь выполняется, когда условие прекращения рекурсии истинно; она возвращает некоторое значение, не выполняя рекурсивного вызова. Правильно написанная рекурсивная функция должна гарантировать, что через конечное число рекурсивных вызовов будет достигнуто выполнение условия прекращения рекурсии, в результате чего цепочка последовательных рекурсивных вызовов прервётся и выполнится возврат.\n\n

Автоматное программирование — это парадигма программирования, при использовании которой программа или её фрагмент осмысливается как модель какого-либо формального автомата.\n
В зависимости от конкретной задачи в автоматном программировании могут использоваться как конечные автоматы, так и автоматы более сложной структуры.\n
Определяющими для автоматного программирования являются следующие особенности:\n
- временной период выполнения программы разбивается на шаги автомата, каждый из которых представляет собой выполнение определённой (одной и той же для каждого шага) секции кода с единственной точкой входа; такая секция может быть оформлена, например, в виде отдельной функции и может быть разделена на подсекции, соответствующие отдельным состояниям или категориям состояний;\n
- передача информации между шагами автомата осуществляется только через явно обозначенное множество переменных, называемых состоянием автомата; между шагами автомата программа (или её часть, оформленная в автоматном стиле) не может содержать неявных элементов состояния, таких как значения локальных переменных в стеке, адреса возврата из функций, значение текущего счётчика команд и т. п.; иначе говоря, состояние программы на любые два момента входа в шаг автомата могут различаться между собой только значениями переменных, составляющих состояние автомата (причём такие переменные должны быть явно обозначены в качестве таковых).\n
Полностью выполнение кода в автоматном стиле представляет собой цикл (возможно, неявный) шагов автомата.\n\n

Обобщенное программирование\n
Обобщённое программирование рассматривается как методология программирования, основанная на разделении структур данных и алгоритмов через использование абстрактных описаний требований. Абстрактные описания требований являются расширением понятия абстрактного типа данных. Вместо описания отдельного типа в обобщённом программировании применяется описание семейства типов, имеющих общий интерфейс и семантическое поведение. Набор требований, описывающий интерфейс и семантическое поведение, называется концепцией (англ. concept). Таким образом, написанный в обобщённом стиле алгоритм может применяться для любых типов, удовлетворяющих его своими концепциями. Такая возможность называется полиморфизмом.\n
Говорят, что тип моделирует концепцию (является моделью концепции), если он удовлетворяет её требованиям. Концепция является уточнением другой концепции, если она дополняет последнюю. Требования к концепциям содержат следующую информацию:\n
Допустимые выражения (англ. valid expressions) — выражения языка программирования, которые должны успешно компилироваться для типов, моделирующих концепцию.\n
Ассоциированные типы (англ. associated types) — вспомогательные типы, имеющие некоторое отношение к моделирующему концепцию типу.\n
Инварианты (англ. invariants) — характеристики типов времени исполнения, которые должны быть постоянно верны. Обычно выражаются в виде предусловий и постусловий. Невыполнение предусловия влечёт непредсказуемость соответствующей операции и может привести к ошибкам.\n
Гарантии сложности (англ. complexity guarantees) — максимальное время выполнения допустимого выражения или максимальные требования к различным ресурсам в ходе выполнения этого выражения.\n\n

Мета программирование\n
Мета программирование — вид программирования, связанный с созданием программ, которые порождают другие программы как результат своей работы (в частности, на стадии компиляции их исходного кода), либо программ, которые меняют себя во время выполнения (самомодифицирующийся код). Первое позволяет получать программы при меньших затратах времени и усилий на кодирование, чем если бы программист писал их вручную целиком, второе позволяет улучшить свойства кода (размер и быстродействие). При этом подходе код программы не пишется вручную, а создается автоматически программой-генератором на основе другой, более простой программы.\n
Такой подход приобретает смысл, если при программировании вырабатываются различные дополнительные правила (более высокоуровневые парадигмы, выполнение требований внешних библиотек, стереотипные методы реализации определенных функций и пр.). При этом часть кода теряет содержательный смысл и становится лишь механическим выполнением правил. Когда эта часть становится значительной, возникает мысль задавать вручную лишь содержательную часть, а остальное добавлять автоматически. Это и проделывает генератор.\n\n
Реализуется двумя основными методами:\n
Шаблоны (наиболее известные случаи применения — препроцессор Си и шаблоны в C++)\n
Решают задачу, если соблюдение «правил» сводится к вставке в программу повторяющихся (или почти повторяющихся) кусков кода. Помимо этого, обладают ещё рядом достоинств: например, помогают повторному использованию. См. также: полиморфизм
Синтаксические макросы. Позволяют генерировать код как шаблоны С++, но имеют больше возможностей для кодогенерации, так как умеют работать с объектной моделью программы, в отличие от шаблонов С++. Реализованы в нескольких языках программирования: Nemerle, Scala, Лисп и других.\n
Внеязыковые средства (пример: генераторы синтаксических и лексических анализаторов lex, yacc, bison)\n
Применяются в случаях, если простых средств вроде шаблонов недостаточно. Язык генератора составляется так, чтобы автоматически или с минимальными усилиями со стороны программиста реализовывать правила парадигмы или необходимые специальные функции. Фактически, это — более высокоуровневый язык программирования, а генератор — не что иное, как транслятор. Генераторы пишутся, как правило, для создания специализированных программ, в которых очень значительная часть стереотипна, либо для реализации сложных парадигм.\n
</item>
        <!--17-->
        <item>17.ТЕСТИРОВАНИЕ И ОТЛАДКА ПРОГРАММНОГО СРЕДСТВА.\n\n\n\n\n
Недостаточно выполнить проектирование и кодирование программного продукта, также необходимо обеспечить его соответствие требованиям и спецификациям. Многократно проводимые исследования показали, что чем раньше обнаруживаются те или иные несоответствия или ошибки, тем больше вероятность их исправления и ниже его стоимость. Современные технологии разработки ПО предусматривают раннее обнаружение ошибок за счет выполнения контроля результатов всех этапов и стадий разработки. На начальных этапах контроль осуществляют вручную или с использованием CASE-средств, на последних - он принимает форму тестирования.\n
Тестирование- это процесс выполнения программы, целью которого является выявление ошибок. Никакое тестирование не может доказать отсутствие ошибок в сложном ПО, поскольку выполнение полного тестирования становится невозможным и имеется вероятность, что остались невыявленные ошибки. Соблюдение основных правил тестирования и научно обоснованный подбор тестов может уменьшить их количество. Процесс разработки согласно современной модели жизненного цикла ПО предполагает три стадии тестирования: автономное тестирование компонентов ПО; комплексное тестирование разрабатываемого ПО; системное или оценочное тестирование на соответствие основным критериям качества. Для повышения качества тестирования рекомендуется соблюдать следующие основные принципы:\n\n
а) предполагаемые результаты должны быть известны до тестирования;\n
б) следует избегать тестирования программы автором;\n
в) необходимо досконально изучать результаты каждого теста;\n
г) необходимо проверять действия программы на неверных данных;\n
д) необходимо проверять программу на неожиданные побочные эффекты на неверных данных.\n\n
Вероятность наличия необнаруженных ошибок в части программы пропорциональна количеству ошибок уже найденных в этой части. Удачным считают тест, который обнаруживает хотя бы одну ошибку. Формирование набора тестов имеет большое значение, поскольку тестирование является одним из наиболее трудоемких этапов создания ПО. Доля стоимости тестирования в общей стоимости разработки возрастает при увеличении сложности ПО и повышении требований к их качеству.\n
Существуют два принципиально различных подхода к формированию тестовых наборов: структурный и функциональный. Структурный подход базируется на том, что известна структура тестируемого ПО, в том числе его алгоритмы («стеклянный ящик»). Тесты строятся для проверки правильности реализации заданной логики в коде программы. Функциональный подход основывается на том, что структура ПО не известна («черный ящик»). В этом случае тесты строят, опираясь на функциональные спецификации. Этот подход называют также подходом, управляемым данными, так как при его использовании тесты строят на базе различных способов декомпозиции множества данных. Наборы тестов, полученные в соответствии с методами этих подходов, объединяют, обеспечивая всестороннее тестирование ПО.\n
Ручной контроль используют на ранних этапах разработки. Все проектные решения анализируются с точки зрения их правильности и целесообразности как можно раньше, пока их можно легко пересмотреть. Различают статический и динамический подходы к ручному контролю. При статическомподходе анализируют структуру, управляющие и информационные связи программы, ее входные и выходные данные. При динамическом - выполняют ручное тестирование (вручную моделируют процесс выполнения программы на заданных исходных данных). Исходными данными для таких проверок являются: техническое задание, спецификации, структурная и функциональная схемы программного продукта, схемы отдельных компонентов, а для более поздних этапов - алгоритмы и тексты программ, а также тестовые наборы. Доказано, что ручной контроль способствует существенному увеличе-нию производительности и повышению надежности программ и с его помощью можно находить от 30 до 70 % ошибок логического проектирования и кодирования. Основными методами ручного контроля являются: инспекции исходного текста, сквозные просмотры, проверка за столом, оценки программ.\n
В основе структурного тестирования лежит концепция максимально полного тестирования всех маршрутов, предусмотренных алгоритмом (последовательности операторов программы, выполняемых при конкретном варианте исходных данных). Недостатки: построенные тестовые наборы не обнаруживают пропущенных маршрутов и ошибок, зависящих от заложенных данных; не дают гарантии, что программа правильна.\n
Другим способом проверки программ является функциональное тестирование: программа рассматривается как «черный ящик», целью тестирования является выяснение обстоятельств, когда поведение программы не соответствует спецификации. Для обнаружения всех ошибок необходимо выполнить исчерпывающее тестирование (при всех возможных наборах данных), что для большинства случаев невозможно. Поэтому обычно выполняют «разумное» или «приемлемое» тестирование, ограничивающееся прогонами программы на небольшом подмножестве всех возможных входных данных. При функциональном тестировании различают следующие методы формирования тестовых наборов: эквивалентное разбиение; анализ граничных значений; анализ причинно-следственных связей; предположение об ошибке.\n
При комплексном тестировании используют тесты, построенные по методам эквивалентных классов, граничных условий и предположении об ошибках, поскольку структурное тестирование для него не применимо. Одним из самых сложных является вопрос о завершении тестирования, так как невозможно гарантировать, что в программе не осталось ошибок. Часто тестирование завершают потому, что закончилось время, отведенное на его выполнение. Его сворачивают, обходясь минимальным тестированием, которое предполагает:\n тестирование граничных значений,\n тщательную проверку руководства,\n тестирование минимальных конфигураций технических средств,\n возможности редактирования команд и повторения их в любой последовательности,\n устойчивости к ошибкам пользователя.\n
После завершения комплексного тестирования приступают к оценочному тестированию, целью которого является поиск несоответствий техническому заданию. Оценочное тестирование включает тестирование: удобства использования, на предельных объемах, на предельных нагрузках, удобства эксплуатации, защиты, производительности, требований к памяти, конфигурации оборудования, совместимости, удобства установки, удобства обслуживания, надежности, восстановления, документации, процедуры.\n\n
Отладка- это процесс локализации (определения оператора программы, выполнение которого вызвало нарушение вычислительного процесса) и исправления ошибок, обнаруженных при тестировании ПО. Для исправления ошибки необходимо определить ее причину. Отладка требует от программиста глубоких знаний специфики управления используемыми техническими средствами, операционной системы, среды и языка программирования, реализуемых процессов, природы и специфики ошибок, методик отладки и соответствующих программных средств;\n психологически дискомфортна (нужно искать собственные ошибки в условиях ограниченного времени);\n оставляет возможность взаимовлияния ошибок в разных частях программы.\n Четко сформулированные методики отладки отсутствуют. Различают:\n\n
а) синтаксические ошибки – сопровождаются комментарием с указанием их местоположения, фиксируются компилятором (транслятором) при выполнении синтаксического и частично семантического анализа;\n
б) ошибки компоновки - обнаруживаются компоновщиком (редактором связей) при объединении модулей программы;\n
в) ошибки выполнения - обнаруживаются аппаратными средствами, операционной системой или пользователем при выполнении программы, проявляются разными способами и в свою очередь делятся на группы:\n\n
1) ошибки определения исходных данных (ошибки передачи, ошибки преобразования, ошибки перезаписи и ошибки данных);\n
2) логические ошибки проектирования (неприменимый метод, неверный алгоритм, неверная структура данных, другие) и кодирования (ошибки некорректного использования переменных, вычислений, межмодульного интерфейса, реализации алгоритма, другие);\n
3) ошибки накопления погрешностей результатов вычислений (игнорирование ограничений разрядной сетки и способов уменьшения погрешности).\n
Отладка программы в любом случае предполагает обдумывание и логическое осмысление всей имеющейся информации об ошибке. Большинство ошибок можно обнаружить по косвенным признакам посредством тщательного анализа текстов программ и результатов тестирования без получения дополнительной информации с помощью следующих методов:\n
а) ручного тестирования (при обнаружении ошибки нужно выполнить те-стируемую программу вручную, используя тестовый набор, при работе с ко-торым была обнаружена ошибка);\n
б) индукции (основан на тщательном анализе симптомов ошибки, которые могут проявляться как неверные результаты вычислений или как сообщение об ошибке);\n
в) дедукции (вначале формируют множество причин, которые могли бы вызвать данное проявление ошибки, а затем анализируя причины, исключают те, которые противоречат имеющимся данным);\n
г) обратного прослеживания (для точки вывода неверного результата строится гипотеза о значениях основных переменных, которые могли бы привести к получению данного результата, а затем, исходя из этой гипотезы, делают предположения о значениях переменных в предыдущей точке).\n
Для получения дополнительной информации об ошибке выполняют добавочные тесты и используют специальные методы и средства: отладочный вывод;\n интегрированные средства отладки;\n независимые отладчики.\n\n
Общая методика отладки программных продуктов, написанных для выполнения в операционных системах MS DOS и Win32:\n
1 этап - изучение проявления ошибки;\n
2 этап – определение локализации ошибки;\n
3 этап - определение причины ошибки;\n
4 этап — исправление ошибки;\n
5 этап - повторное тестирование.\n\n
Процесс отладки можно существенно упростить, если следовать основным рекомендациям структурного подхода к программированию:\n
а) программу наращивать «сверху-вниз», от интерфейса к обрабатывающим подпрограммам, тестируя ее по ходу добавления подпрограмм;
б) выводить пользователю вводимые им данные для контроля и проверять их на допустимость сразу после ввода;\n
в) предусматривать вывод основных данных во всех узловых точках алгоритма (ветвлениях, вызовах подпрограмм).\n

</item>
        <!--18-->
        <item>18.ОБЪЕКТНО-ОРИЕНТИРОВАННОЕ ПРОГРАММИРОВАНИЕ\n\n\n\n\n\n\n
Объектно-ориентированное программирование (ООП) — это парадигма разработки программных систем, в которой приложения состоят из объектов.\n
Основная задача ООП — сделать сложный код проще. Для этого программу разбивают на независимые блоки, которые мы называем объектами.
Объект — это не какая-то космическая сущность. Объекты — это сущности, у которых есть свойства и поведение. Обычно объекты являются экземплярами какого-нибудь класса.\n
Это всего лишь набор данных и функций — таких же, как в традиционном функциональном программировании. Можно представить, что просто взяли кусок программы и положили его в коробку и закрыли крышку. Вот эта коробка с крышками — это объект.
Программисты договорились, что данные внутри объекта будут называться свойствами, а функции — методами. Но это просто слова, по сути, это те же переменные и функции.\n
Объект можно представить как независимый электроприбор у вас на кухне. Чайник кипятит воду, плита греет, блендер взбивает, мясорубка делает фарш. Внутри каждо-го устройства куча всего: моторы, контроллеры, кнопки, пружины, предохранители — но вы о них не думаете. Вы нажимаете кнопки на панели каждого прибора, и он дела-ет то, что от него ожидается. И благодаря совместной работе этих приборов у вас получается ужин.\n
Объекты характеризуются четырьмя словами: инкапсуляция, абстракция, наследование и полиморфизм.\n\n
Инкапсуляция — объект независим: каждый объект устроен так, что нужные для него данные живут внутри этого объекта, а не где-то снаружи в программе. Например, если у меня есть объект «Пользователь», то у меня в нём будут все данные о пользователе: и имя, и адрес, и всё остальное. И в нём же будут методы «Проверить адрес» или «Подписать на рассылку».\n\n
Абстракция — у объекта есть «интерфейс»: у объекта есть методы и свойства, к которым мы можем обратиться извне этого объекта. Так же, как мы можем нажать кнопку на блендере. У блендера есть много всего внутри, что заставляет его работать, но на главной панели есть только кнопка. Вот эта кнопка и есть абстрактный интер-фейс.\n
В программе мы можем сказать: «Удалить пользователя». На языке ООП это будет «пользователь.удалить()» — то есть мы обращаемся к объекту «пользователь» и вызываем метод «удалить». Кайф в том, что нам не так важно, как именно будет про-исходить удаление: ООП позволяет нам не думать об этом в момент обращения.\n
Например, над магазином работают два программиста: один пишет модуль заказа, а второй — модуль доставки. У первого в объекте «заказ» есть метод «отменить». И вот второму нужно из-за доставки отменить заказ. И он спокойно пишет: «заказ.отменить()». Ему неважно, как другой программист будет реализовывать отме-ну: какие он отправит письма, что запишет в базу данных, какие выведет предупреждения.\n\n
Наследование — способность к копированию. ООП позволяет создавать много объектов по образу и подобию другого объекта. Это позволяет не копипастить код по двести раз, а один раз нормально написать и потом много раз использовать.\n
Например, у вас может быть некий идеальный объект «Пользователь»: в нём вы прописываете всё, что может происходить с пользователем. У вас могут быть свойства: имя, возраст, адрес, номер карты. И могут быть методы «Дать скидку», «Проверить заказ», «Найти заказы», «Позвонить».\n
На основе этого идеального пользователя вы можете создать реального «Покупателя Ивана». У него при создании будут все свойства и методы, которые вы задали у иде-ального покупателя, плюс могут быть какие-то свои, если захотите.\n
Идеальные объекты программисты называют классами.\n\n
Полиморфизм — единый язык общения. В ООП важно, чтобы все объекты общались друг с другом на понятном им языке. И если у разных объектов есть метод «Удалить», то он должен делать именно это и писаться везде одинаково. Нельзя, чтобы у одного объекта это было «Удалить», а у другого «Стереть».\n
При этом внутри объекта методы могут быть реализованы по-разному. Например, удалить товар — это выдать предупреждение, а потом пометить товар в базе данных как удалённый. А удалить пользователя — это отменить его покупки, отписать от рассылки и заархивировать историю его покупок. События разные, но для программиста это неважно. У него просто есть метод «Удалить()», и он ему доверяет.\n
Такой подход позволяет программировать каждый модуль независимо от остальных. Главное — заранее продумать, как модули будут общаться друг с другом и по каким правилам. При таком подходе вы можете улучшить работу одного модуля, не затрагивая остальные — для всей программы неважно, что внутри каждого блока, если пра-вила работы с ним остались прежними.\n\n
Плюсы и минусы ООП\n
У объектно-ориентированного программирования много плюсов, и именно поэтому этот подход использует большинство современных программистов.\n
•	Визуально код становится проще, и его легче читать. Когда всё разбито на объекты и у них есть понятный набор правил, можно сразу понять, за что отвечает каждый объ-ект и из чего он состоит.\n
•	Меньше одинакового кода. Если в обычном программировании одна функция считает повторяющиеся символы в одномерном массиве, а другая — в двумерном, то у них большая часть кода будет одинаковой. В ООП это решается наследованием.\n
•	Сложные программы пишутся проще. Каждую большую программу можно разложить на несколько блоков, сделать им минимальное наполнение, а потом раз за разом подробно наполнить каждый блок.\n
•	Увеличивается скорость написания. На старте можно быстро создать нужные компоненты внутри программы, чтобы получить минимально работающий прототип.\n\n
А теперь про минусы:\n
•	Сложно понять и начать работать. Подход ООП намного сложнее обычного функционального программирования — нужно знать много теории, прежде чем будет написана хоть одна строчка кода.\n
•	Требует больше памяти. Объекты в ООП состоят из данных, интерфейсов, методов и много другого, а это занимает намного больше памяти, чем простая переменная.\n
•	Иногда производительность кода будет ниже. Из-за особенностей подхода часть вещей может быть реализована сложнее, чем могла бы быть. Поэтому бывает такое, что ООП-программа работает медленнее, чем функциональная (хотя с современными мощностями процессоров это мало кого волнует).
</item>
        <!--19-->
        <item>19.ОСНОВНЫЕ ПРИНЦИПЫ АРХИТЕКТУРЫ ПО.\n\n\n\n\n\n
Архитектура программного обеспечения (англ. software architecture) — совокупность важнейших решений об организации программной системы. Архитектура включает:\n
•	выбор структурных элементов и их интерфейсов, с помощью которых составлена система, а также их поведения в рамках сотрудничества структурных элементов;\n
•	соединение выбранных элементов структуры и поведения во всё более крупные системы;\n
•	архитектурный стиль, который направляет всю организацию — все элементы, их интерфейсы, их сотрудничество и их соединение.\n
Документирование архитектуры программного обеспечения (ПО) упрощает процесс коммуникации между разработчиками, позволяет зафиксировать принятые проектные решения и предоставить информацию о них эксплуатационному персоналу системы, повторно использовать компоненты и шаблоны проекта в других.\n
Общепринятого определения «архитектуры программного обеспечения» не существует. Так, сайт Software Engineering Institute приводит более 150 определений этого понятия.\n
 Область компьютерных наук с момента своего образования столкнулась с проблемами, связанными со сложностью программных систем. Ранее проблемы сложности решались разработчиками путём правильного выбора структур данных, разработки алгоритмов и применения концепции разграничения полномочий. Хотя термин «архитектура программного обеспечения» является относительно новым для индустрии разработки ПО, фундаментальные принципы этой области неупорядоченно применялись пионерами разработки ПО начиная с середины 1980-х. Первые попытки осознать и объяснить программную архитектуру системы были полны неточностей и страдали от недостатка организованности, часто это была просто диаграмма из блоков, соединенных линиями. В 1990-е годы наблюдается попытка определить и систематизировать основные аспекты данной дисциплины. Первоначальный набор шаблонов проектирования, стилей проектирования, передового опыта (best practices), языков описания и формальная логика были разработаны в течение этого времени.\n
Основополагающей идеей дисциплины программной архитектуры является идея снижения сложности системы путём абстракции и разграничения полномочий. На сегодняшний день до сих пор нет согласия в отношении чёткого определения термина «архитектура программного обеспечения».\n
Являясь в настоящий момент своего развития дисциплиной без четких правил о «правильном» пути создания системы, проектирование архитектуры ПО все ещё является смесью науки и искусства. Аспект «искусства» заключается в том, что любая коммерческая система подразумевает наличие применения или миссии. С точки зрения пользователя программной архитектуры, программная архитектура дает направление для движения и решения задач, связанных со специальностью каждого такого пользователя, например, заинтересованного лица, разработчика ПО, группы поддержки ПО, специалиста по сопровождению ПО, специалиста по развертыванию ПО, тестера, а также конечных пользователей. В этом смысле архитектура программного обеспечения на самом деле объединяет различные точки зрения на систему. Тот факт, что эти несколько различных точек зрения могут быть объединены в архитектуре программного обеспечения, является аргументом в защиту необходимости и целесообразности создания архитектуры ПО ещё до этапа разработки ПО.\n\n
История\n
Начало архитектуре программного обеспечения как концепции было положено в научно-исследовательской работе Эдсгера Дейкстры в 1968 году и Дэвида Парнаса в начале 1970-х. Эти ученые подчеркнули, что структура системы ПО имеет важное значение, и что построение правильной структуры — критически важно. Популярность изучения этой области возросла с начала 1990-х годов вместе с научно-исследовательской работой по исследованию архитектурных стилей (шаблонов), языков описания архитектуры, документирования архитектуры, и формальных методов.\n
В развитии архитектуры программного обеспечения как дисциплины играют важную роль научно-исследовательские учреждения. Мэри Шоу и Дэвид Гэрлан из университета Carnegie Mellon написали книгу под названием «Архитектура программного обеспечения: перспективы новой дисциплины в 1996 году», в которой выдвинули концепции архитектуры программного обеспечения, такие как компоненты, соединители (connectors), стили и так далее. В калифорнийском университете институт Ирвайна по исследованию ПО в первую очередь исследует архитектурные стили, языки описания архитектуры и динамические архитектуры.\n
Первым стандартом программной архитектуры является стандарт IEEE 1471: ANSI / IEEE 1471—2000: Рекомендации по описанию преимущественно программных систем. Он был принят в 2007 году, под названием ISO ISO / IEC 42010:2007.\n\n
Языки описания архитектуры\n
Языки описания архитектуры (ADLS) используются для описания архитектуры программного обеспечения. Различными организациями было разработано несколько различных ADLS, в том числе AADL (стандарт SAE), Wright (разработан в университете Carnegie Mellon), Acme (разработан в университете Carnegie Mellon), xADL (разработан в UCI), Darwin (разработан в Imperial College в Лондоне), DAOP-ADL (разработан в Университете Малаги), а также ByADL (Университет L’Aquila, Италия). Общими элементами для всех этих языков являются понятия компонента, коннектора и конфигурации. Также, помимо специализированных языков, для описания архитектуры часто используется унифицированный язык моделирования UML.\n\n
Виды (views)\n
Архитектура ПО обычно содержит несколько видов, которые аналогичны различным типам чертежей в строительстве зданий. В онтологии, установленной ANSI / IEEE 1471—2000, виды являются экземплярами точки зрения, где точка зрения существует для описания архитектуры с точки зрения заданного множества заинтересованных лиц.\n
Архитектурный вид состоит из 2 компонентов:\n
•	Элементы\n
•	Отношения между элементами\n\n
Архитектурные виды можно поделить на 3 основных типа:\n
1.	Модульные виды (англ. module views) — показывают систему как структуру из различных программных блоков.\n
2.	Компоненты-и-коннекторы (англ. component-and-connector views) — показывают систему как структуру из параллельно запущенных элементов (компонентов) и способов их взаимодействия (коннекторов).\n
3.	Размещение (англ. allocation views) — показывает размещение элементов системы во внешних средах.\n\n
Примеры модульных видов:\n
•	Декомпозиция (англ. decomposition view) — состоит из модулей в контексте отношения «является подмодулем»\n
•	Использование (англ. uses view) — состоит из модулей в контексте отношения «использует» (т.е. один модуль использует сервисы другого модуля)\n
•	Вид уровней (англ. layered view) — показывает структуру, в которой связанные по функциональности модули объединены в группы (уровни)\n
•	Вид классов/обобщений (англ. class/generalization view) — состоит из классов, связанные через отношения «наследуется от» и «является экземпляром»\n\n
Примеры видов компонентов-и-коннекторов:\n
•	Процессный вид (англ. process view) — состоит из процессов, соединённых операциями коммуникации, синхронизации и/или исключения\n
•	Параллельный вид (англ. concurrency view) — состоит из компонентов и коннекторов, где коннекторы представляют собой «логические потоки»\n
•	Вид обмена данными (англ. shared-data (repository) view) — состоит из компонентов и коннекторов, которые создают, сохраняют и получают постоянные данные\n
•	Вид клиент-сервер (англ. client-server view) — состоит из взаимодействующих клиентов и серверов, а также коннекторов между ними (например, протоколов и общих сообщений)\n\n
Примеры видов размещения:\n
•	Развертывание (англ. deployment view) — состоит из программных элементов, их размещения на физических носителях и коммуникационных элементов\n
•	Внедрение (англ. implementation view) — состоит из программных элементов и их соответствия файловым структурам в различных средах (разработческой, интеграционной и т.д.)\n
•	Распределение работы (англ. work assignment view) — состоит из модулей и описания того, кто ответственен за внедрение каждого из них
Хотя было разработано несколько языков для описания архитектуры программного обеспечения, в настоящий момент нет согласия по поводу того, какой набор видов должен быть принят в качестве эталона. В качестве стандарта «для моделирования программных систем (и не только)» был создан язык UML.\n\n
Архитектурные шаблоны\n
Для удовлетворения проектируемой системы различным атрибутам качества применяются различные архитектурные шаблоны (паттерны). Каждый шаблон имеет свои задачи и свои недостатки.\n\n
Примеры архитектурных шаблонов:\n
•	Многоуровневый шаблон (Layered pattern). Система разбивается на уровни, которые на диаграмме изображаются один над другим. Каждый уровень может вызывать только уровень на 1 ниже него. Таким образом разработку каждого уровня можно вести относительно независимо, что повышает модифицируемость системы. Недостатками данного подхода являются усложнение системы и снижение производительности.\n
•	Шаблон посредника (Broker pattern). Когда в системе присутствует большое количество модулей, их прямое взаимодействие друг с другом становится слишком сложным. Для решения проблемы вводится посредник (например, шина данных), по которой модули общаются друг с другом. Таким образом, повышается функциональная совместимость модулей системы. Все недостатки вытекают из наличия посредника: он понижает производительность, его недоступность может сделать недоступной всю систему, он может стать объектом атак и узким местом системы.\n
•	Шаблон «Модель-Представление-Контроллер» (Model-View-Controller pattern). Т.к. требования к интерфейсу меняются чаще всего, то возникает потребность часто его модифицировать, при этом сохраняя корректное взаимодействие с данными (чтение, сохранение). Для этого в шаблоне Model-View-Controller (MVC) интерфейс отделён от данных. Это позволяет менять интерфейсы, равно как и создавать их разные варианты. В MVC система разделена на:\n
o	Модель, хранящую данные\n
o	Представление, отображающее часть данных и взаимодействующее с пользователем\n
o	Контроллер, являющийся посредником между видами и моделью\n
Однако, концепция MVC имеет и свои недостатки. В частности, из-за усложнения взаимодействия падает скорость работы системы.\n
•	Клиент-серверный шаблон (Client-Server pattern). Если есть ограниченное число ресурсов, к которым требуется ограниченный правами доступ большого числа потребителей, то удобно реализовать клиент-серверную архитектуру. Такой подход повышает масштабируемость и доступность системы. Но при этом сервер может стать узким местом системы, при его недоступности становится недоступна вся система.\n\n
Базовые фреймворки для архитектуры ПО\n
Существуют следующие фреймворки (англ. software architecture frameworks), относящиеся к области архитектуры ПО:\n
•	4+1\n
•	RM-ODP (Reference Model of Open Distributed Processing)\n
•	Service-Oriented Modeling Framework (SOMF)\n
Такие примеры архитектур, как фреймворк Захмана (Zachman Framework), DoDAF и TOGAF, относятся к области архитектуры предприятия (enterprise architectures).\n
</item>
        <!--20-->
        <item>Уругвай</item>
        <!--21-->
        <item>21.МЕТОДЫ ДИЗАЙНА.\n\n\n\n\n\n
Дизайн (от англ. design — проектировать, чертить, задумать, а также проект, план, рисунок), термин, обозначающий вид деятельности по проектированию предметного мира.\n
По сути дизайн  это творческий метод, процесс и результат художественно-технического проектирования промышленных изделий, их комплексов и систем, ориентированный на достижение наиболее полного соответствия создаваемых объектов и окружающей среды, возможностям и потребностям человека, как утилитарным, так и эстетическим.\n
В основе дизайна чего угодно лежат три компонента:\n
•	Эстетика\n
•	Эмпатия\n
•	Инструменты\n
Эстетика основывается на традиционных принципах визуального дизайна. Ключевые компоненты визуального дизайна — это система сеток, типографика, теория цвета и движение. Суть эстетики не в том, чтобы объекты дизайна просто выделялись и бросались в глаза. Эстетика — это визуальный язык; мастерство передавать идеи посредством образов.\n
Эмпатия — это понимание людей, для которых мы проектируем. В продуктовой дизайне мы используем для этого термины пользовательское исследование (user research) и проектированием пользовательского опыта (user experience design). Не важно, насколько круто вы передаете свои идеи через дизайн, если вы не знаете, с кем вы говорите, и о чем они хотят разговаривать. Дизайн никогда не существует в вакууме. В его основе всегда есть проблема и цель.\n
И наконец, нужно знать инструменты дизайна. Их существует огромное множество: от салфетки, на которой вы накидали первоначальную идею, до программного обеспечения.\n
Цель дизайна — формирование гармоничной предметной среды, наиболее полно удовлетворяющей материальные и духовные потребности человека.\n
Проектирование — это последовательное продуманное планирование действий для достижения поставленных целей.\n
Проектирование входит в логическую цепочку работы над проектом:\n
•	Определение проектной идеи\n
•	Разработка и описание идеи\n
•	Проектирование\n
•	Реализация\n
В ходе проектирования и разработки большую роль играет:\n
•	аналитическая деятельность самого дизайнера\n
•	критика профессионалов\n
•	мнение заказчика\n
•	мнение потребителя\n
Проектный анализ - это система мер, обеспечивающих отражение дизайнерских идей в форме проектного материала. Стремление к улучшению проекта заставляет автора в течение всего проектирования постоянно проверять и перепроверять его. А так же сверять получившееся с первоначальной идеей. И если надо – вносить исправления.\n
В проектном анализе необходимо проанализировать формальные качества работы:\n
•	гармоничность\n
•	колористическую согласованность\n
•	ритмические и пропорциональные связи\n
Дизайнеру надо уметь представлять любую задуманную проектную модель в виде предельно упрощенной условной схеме. Условная схема помогает избавиться от набегающих по ходу работы ошибок и искажений и проясняет положительные и отрицательные стороны идеи.\n
В процессе «обрастания» дизайн-концепции реальными размерами, конструкциями исходная идея часто искажается, заслоняется случайными впечатлениями и подробностями.\n\n
Методы дизайн-проектирования\n
Метод аналогий. Метод познания и творчества, базирующийся на отыскании и использовании сходства, подобия.\n
Различают аналогии:\n
•	тривиальные – общеизвестные\n
•	эвристические – неожиданные, поисковые\n
Можно исполь¬зовать аналогии следующих типов:\n
•	Прямые. Данные аналогии можно найти в биологических системах\n
•	Субъективные. Конструктор старается представить себе, что он испытывал бы, если бы был тем или иным предметом, например, столом или шкафом.\n
•	Символические. Метафоры и сравнения, в которых характеристики одного предмета отождествляются с характеристиками другого\n
•	Фантастические. Представление вещей такими, какими они не являются, но какими мы хотели бы их видеть\n
Метод агрегатирования. Художественное конструирование, основанное на том, что изделие рассматривается как конструкция, расчлененная на самостоятельные узлы, сочетания которых могут выполнять ту или иную одну функцию, а при перекомпоновке их рабочие функции изменятся.
Метод ассоциации. Способ формирования проектной идеи на основе сравнения далеких друг от друга явлений, предметов, качеств.\n
Метод «Вживание в роль». Осмысление задач проектирования с учетом прогнозируемой реакции потребителя.\n
Метод «Мозговой штурм». Метод стимуляции продуктивности творческой деятельности за счет ее освобождения от ограничений. Каждый член коллектива выска¬зывается на заданную тему и выдви¬гает идеи, не оценивая их как истин¬ные или ложные, какими бы невыполнимыми они ни казались, не подвергая их аналитическому разбору, побуждая друг друга к поиску разного рода ассоциаций.\n
</item>
        <!--22-->
        <item>22.ОЦЕНКА С ЭРГОНОМИЧЕСКИМИ РЕКОМЕНДАЦИЯМИ.\n\n\n\n\n
Эргономическая оценка программного продукта\n\n
Эргономика включается в процессы разработки и тестирования программного продукта как часть системы качества. Разработка пользовательского интерфейса (ПИ) ведется параллельно дизайну программного продукта в целом и в основном предшествует его осуществлению.\n
Графический интерфейс пользователя ( англ. graphical user interface, GUI – система средств для взаимодействия пользователя с компьютером, основанная на представлении всех доступных пользователю системных объектов и функций в виде графических компонентов экрана (окон, значков, меню, кнопок, списков и т. п.).\n
Эргономические цели и показатели качества программного продукта. С точки зрения эргономики, самое важное в программе — создать такой пользовательский интерфейс, который сделает работу эффективной и производительной, а также обеспечит удовлетворенность пользователя от работы с программой. Эффективность работы должна быть нацелена на показатели:\n\n
Точность работы определяется тем, в какой степени произведенный пользователем продукт (результат работы), соответствует предъявленным к нему требованиям.\n
Функциональная полнота отражает степень использования первичных и обработанных данных, списка необходимых процедур обработки или отчетов.\n
Завершенность работы описывает степень исполнения производственной задачи средним пользователем за определенный срок или период.\n
Производительность работы отражает объем затраченных ресурсов при выполнении задачи, как вычислительных, так и психофизиологических.\n
Дизайн ПИ должен обеспечивать минимизацию усилий пользователя при выполнении работы и приводить к: сокращению длительности операций чтения, редактирования и поиска информации, уменьшению времени навигации и выбора команды, повышению общей продуктивности пользователя.\n
Удовлетворенность пользователя от работы. Высокая удовлетворенность от работы достигается в случае: Прозрачной для пользователя навигации, ясности и четкости понимания пользователем текстов и значения икон, скорости обучения при работе с программой, наличия вспомогательных средств поддержки пользователя (поисковых, справочных, нормативных).\n
Принципы реализации пользовательского интерфейса. Стилевая гибкость: возможность использовать различные интерфейсы (“skins”), возможность развивать приложение без разрушения (т.е. оставаясь в рамках) существующего интерфейса.\n
Масштабируемость: возможность легко настраивать и расширять как интерфейс, так и само приложение при увеличении числа пользователей, рабочих мест, объема и характеристик данных.\n
Адаптивность к действиям пользователя: приложение должно допускать возможность ввода данных и команд множеством разных способов (клавиатура, мышь, другие устройства).\n
Цветность: следует позволять пользователю самому выбрать цветовую гамму.\n
Использование звука: система, завершив какую-либо длительную операцию, должна издавать звук. Звук в интерфейсе не есть вещь абсолютно необходимая.\n
Эстетичность. Предмет должен приятно ощущаться на бессознательном уровне. Для этого: избегайте ярких цветов, Избегайте острых углов, нужно сделать дизайн максимально более легким и воздушным.\n
Выделение элементов интерфейса яркостью. Для привлечения внимания существует несколько способов выделения яркостью: Движение (мигание или изменение позиции); Цвет; Форма (символ, шрифт, форма символа); Оттенение (различная текстура объектов); Окружение (подчеркивание, рамки, инвертированное изображение).\n
</item>
        <!--23-->
        <item>23.РАЗВИТИЕ ЯЗЫКОВ WEB-ПРОГРАММИРОВАНИЯ.\n\n\n\n\n\n
Веб-программирование — раздел программирования, ориентированный на разработку веб-приложений (программ, обеспечивающих функционирование динамических сайтов Всемирной паутины).\n
Языки веб-программирования — это языки, которые в основном предназначены для работы с веб-технологиями. Языки веб-программирования можно условно разделить на две пересекающиеся группы: клиентские и серверные.\n\n
 Клиентские языки\n
Как следует из названия, программы на клиентских языках обрабатываются на стороне пользователя, как правило, их выполняет браузер. Это и создает главную проблему клиентских языков — результат выполнения программы (скрипта) зависит от браузера пользователя. То есть, если пользователь запретил выполнять клиентские программы, то они исполняться не будут, как бы ни желал этого программист. Кроме того, может произойти такое, что в разных браузерах или в разных версиях одного и того же браузера один и тот же скрипт будет выполняться по-разному. С другой стороны, если программист возлагает надежды на серверные программы, то он может упростить их работу и снизить нагрузку на сервер за счет программ, исполняемых на стороне клиента, поскольку они не всегда требуют перезагрузку (генерацию) страницы.\n\n
Серверные языки\n
Когда пользователь дает запрос на какую-либо страницу (переходит на неё по ссылке или вводит адрес в адресной строке своего браузера), то вызванная страница сначала обрабатывается на сервере, то есть выполняются все программы, связанные со страницей, и только потом возвращается к посетителю по сети в виде файла. Этот файл может иметь расширения HTML, PHP, ASP, ASPX, Perl, SSI, XML, DHTML, XHTML.\n
Работа программ уже полностью зависима от сервера, на котором расположен сайт, и от того, какая версия того или иного языка поддерживается. К серверным языкам программирования можно отнести PHP, Perl, Python, Ruby, любой .NET язык программирования (технология ASP.NET), Java, Groovy, Javascript.\n
Важной стороной работы серверных языков является возможность организации непосредственного взаимодействия с системой управления базами данных (или СУБД) — сервером базы данных, в которой упорядоченно хранится информация, которая может быть вызвана в любой момент.\n\n
История появления\n
С середины годов, 1990-х веб-разработка была одной из наиболее динамично развивающихся отраслей в мире. В 1995 году меньше, было чем 1000 веб-разработки компании в Соединенных Штатах, но к 2005 году насчитывалось более 30000 таких компаний, только США. в Сети развития промышленности ожидается рост на 20% к 2010 году. Рост этой отрасли толкают крупных желающих компаний, продавать товары и услуги для своих клиентов и автоматизировать. Вместо стоимости в десятки тысяч долларов, как это в было случае раннего создания веб-сайтов, теперь можно разработать простой веб-сайт для менее тысячи долларов, в зависимости от сложности и содержания. объема веб-компании. Малые разработки сайта теперь имеют возможность сделать веб-дизайн доступным небольшим компаниям и частным лицам и дают толчок росту индустрии веб-разработки. что касается веб-разработки инструментов и платформ, существует множество систем для получения доступной бесплатной помощи. Известным примером является LAMP (Linux, Apache, MySQL, PHP), которая обычно распространяется бесплатно. Уже одно это обстоятельство является фактором создания новых сайтов ежедневно, тем самым способствуя увеличению популярности развития Веб. Другим фактором стало использование WYSIWYG Web.\n
С использованием таких программ практически каждый может разработать веб-страницу в считанные минуты. HyperText Markup Language (HTML), или другие Языки программирования не требуются, но рекомендуется в профессиональном программировании.\n
Примерами глубоких преобразований в области связи с торговлей на базе веб-разработки является электронная торговля. Интернет-аукцион сайтов, таких как eBay изменили образ потребителя потреблять и приобретать товары услуги. Интернет-реселлеры, такие как Amazon.com и Buy.com (среди многих, многих других), превратили торговые сделки в простую операцию для многих потребителей. Другой хороший пример трансформационной связи, связанный с развития веб-блогов, это работа веб-приложений, таких как MovableType, WordPress. Open Source Content систем, такие как Alfresco, Typo3, Xoops, Joomla!, Drupal распространили в веб-разработке новые формы взаимодействия и общения.\n
Кроме того, разработка сайтов перешла на новый этап в Интернете. в сайты. Компьютерные Сети уже не просто инструмент для работы и торговли, но и площадка для общения. Сайты, тем или иным предоставляют пользователям платформу для свободного общения.\n\n
Язык HTML\n
Язык HTML был разработан британским учёным Тимом Бернерсом-Ли приблизительно в 1986--1991 годах в стенах Европейского Центра ядерных исследований в Женеве (Швейцария).\n
HTML создавался как язык для обмена научной и технической документацией, пригодный для использования людьми, не являющимися специалистами в области вёрстки. HTML успешно справлялся с проблемой сложности SGML путём определения небольшого набора структурных и семантическихэлементов -- дескрипторов.\n\n

Данный язык прост в освоении и является классическим языком. С помощью него написаны многие сайты можно даже сказать что 90% сайтов написано с его использованием. С годами данный язык совершенствовался и совершенствуется по сей день.\n
HTML 2.0 - Стандарт был утвержден в ноябре 1944 г. организацией IETF (Internet Engineering Task Force ). В нем были расширены возможности предыдущей версии языка и он получил широкое распространение как у профессионалов, так и любителей.\n
HTML 3.0 - Проект версии языка был опубликован в марте 1995 г. В нем были произведены радикальные изменения предыдущих версий включены дополнительные возможности, включая таблицы, математические выражения и т.д. Это стало причиной того, что он не стал официальной спецификацией и был заменен спецификациейHTML 3.2.\n
HTML 3.2 (кодовое наименование проекта: “Wilbur”) - Был опубликован и начал широко использоватья с мая 1996 г., получил официальное утвержден в 1997 г. Получил популярность из-за совместимости с HTML 2.0.\n
HTML 4.0 (кодовое наименование проекта: “Cougar ”) - последняя версия языка. В нем реализованы многие распространенные концепции Web -дизайна и приняты некоторые средства HTML 3.2. Самым значительным отличием HTML 4.0 от предыдущих версий является кодировка Unicode , тег “ Object”, позволяющий работать с мультимедиа ( в т.ч. с видеоклипами и звуком) и др.\n
HTML5 вводит несколько новых элементов и атрибутов, которые отражают типичное использование разметки на современных веб-сайтах. Некоторые из них -- семантические замены для использования универсальных блочных (&lt;div>) и строчных (&lt;span>) элементов, например, &lt;nav> (блок навигации по сайту), &lt;footer>(обычно относится к нижней части страницы или последней строке HTML кода) или &lt;audio> и &lt;video> вместо &lt;object>\n
На данный момент последней версией является HTML 5.\n\n

Язык JavaScript
JavaScript является языком сценариев (скриптов), который применяют в основном для создания на Web-страницах интерактивных элементов. Его можно использовать для построения меню, проверки правильности заполнения форм, смены изображений или для чего-то еще, что можно сделать на Web-странице. Если взглянуть на Google Maps или службу GMail компании Google, то можно понять, на что способен сегодня язык JavaScript.\n
Так как JavaScript является в настоящее время единственным языком сценариев, который поддерживают все основные браузеры Web (Internet Explorer, Firefox, Netscape, Safari,Opera, Camino и т.д.), то он используется очень широко.\n
Код JavaScript обычно выполняется Web-браузером клиента, и в этом случае он называется сценарием на стороне клиента. Но код JavaScript можно выполнять также на Web-сервере для формирования документов HTML, воплощая тем самым сценарий на стороне сервера. Хотя использование JavaScript обычно ограничивается сценариями на стороне клиента, он является также очень мощным серверным языком.\n
При создании кода JavaScript требуется фактически только текстовый редактор и Web-браузер. Знание HTML и CSS будет играть определенно положительную роль, и если вы захотите использовать навыки JavaScript на Web-сайте, то понадобится также Web-сайт. Если у вас уже есть Web-сайт, то отлично! Если нет, то существует множество бесплатных серверов, которые можно использовать для размещения своих страниц. Что касается текстового редактора, то в Windows имеется редактор NotePad. Хотя этого будет достаточно для редактирования JavaScript, HTML и CSS, более мощный редактор, такой, например, как EditPlus или другой, может оказаться более удобным. Ну, а теперь можно перейти к созданию сценария JavaScript!\n
Прежде всего, необходимо узнать, как добавить сценарий JavaScript на страницу HTML. Это можно сделать одним из двух способов: поместить теги Script на Web-странице и расположить код JavaScript внутри этих тегов, или поместить весь код JavaScript в отдельный файл и связаться с ним с помощью тега Script. Любой из этих методов вполне допустим, но они имеют разное назначение. Если имеется небольшой код, который будет использоваться только на одной странице, то размещение его между тегами Script будет хорошим решением. Если, однако, имеется большой фрагмент кода, который будет использоваться на нескольких страницах, то, наверно, лучше поместить этот код JavaScript в отдельный файл и соединиться с ним. Это делается для того, чтобы не нужно было загружать этот код всякий раз при посещении различных страниц. Код загружается один раз, и браузер сохраняет его для последующего использования. Это похоже на то, как используются каскадные таблицы стилей (CSS).\n

</item>
        <!--24-->
        <item>24.СОСТАВНЫЕ ЭЛЕМЕНТЫ HTML-ДОКУМЕНТА. ТИПЫ ДАННЫХ HTML.\n\n\n\n\n
1. Составные элементы HTML-документа\n
1.1 Элементы и теги\n
HTML — это теговый язык разметки документов. Иными словами, любой документ на языке HTML представляет собой набор элементов, причем начало и конец каждого элемента обозначается специальными пометками, называемыми тегами.\n
Элементы — это структуры, которые описывают отдельные составляющие HTML-документа. Элемент состоит из трех частей: начального тега, содержимого и конечного тега. Тег — это специальный текст, заключенный в угловые скобки "&lt;" и ">". Конечный тег имеет то же имя, что начальный тег, но начинается с косой черты "/". Например, элемент EM (выделение текста) выглядит так:\n
<EM>выделяемый текст</EM>\n
Имена элементов могут быть набраны в любом регистре, т. е. &lt;EM> и &lt;em> равнозначны.\n
Элементы должны либо следовать друг за другом, либо быть вложены один в другой. Если начальный тег <EM> расположен внутри элемента <P>…</P>, то и конечный тег </EM> должен быть расположен внутри этого элемента.\n
Конечные теги некоторых элементов могут быть опущены. Например, конечный тег элемента LI (пункт списка) не обязателен, поскольку начало очередного пункта списка означает конец предыдущего пункта:\n
&lt;UL>\n
  &lt;LI>Первый пункт списка без конечного тега\n
  &lt;LI>Второй пункт списка с необязательным конечным тегом&lt;/LI>\n
  &lt;LI>Третий пункт списка без конечного тега\n
&lt;/UL>\n
Мы, однако, рекомендуем указывать конечный тег элемента даже в тех случаях, когда стандарт позволяет его опустить. Для этого есть две причины:\n
•	при использовании каскадных таблиц стилей отсутствие конечного тега элементов часто приводит к непредсказуемым результатам;\n
•	в соответствии со стандартом XHTML, описанным ниже, каждый элемент должен иметь конечный тег.\n
Некоторые элементы, такие, как BR (новая строка), не имеют конечного тега, поскольку не имеют содержимого.\n\n
1.2. Атрибуты\n
Атрибуты элемента определяют его свойства. Например, элемент IMG (графический образ) имеет атрибут src, указывающий расположение графического файла, и атрибут alt, задающий альтернативный текст на тот случай, если обозреватель не отображает графику:\n
&lt;IMG src="mylogo.gif" alt="Юрий Лукач">\n
Атрибуты всегда включаются в начальный тег элемента и имеют вид:\n
имя_атрибута="значение_атрибута"\n
Значение атрибута может быть заключено в одинарные или двойные кавычки. Кавычки можно опустить, если значение атрибута состоит только из латинских букв (A-Za-z), цифр (0-9), дефисов ("-"), подчеркиваний ("_"), двоеточий (":") и точек (".").\n
Имена атрибутов могут быть набраны в любом регистре, но их значения могут зависеть от регистра. Мы для определенности всюду в дальнейшем пишем имена элементов прописными буквами, а именами атрибутов строчными.\n\n
1.3. Специальные символы\n
Ряд символов в языке HTML зарезервирован и должен представляться специальным образом:\n
левая угловая скобка ("&lt;")	"&amp;lt";\n
правая угловая скобка (">")	"&amp;gt";\n
амперсант ("&amp;")	"&amp;amp";\n
двойная кавычка (\") "&amp;quot;"\n
Для некоторых символов, отсутствующих на клавиатуре, также есть специальные обозначения. Например, символ авторского права © представляется как "&amp;copy";.\n
При желании авторы могут пользоваться и числовой кодировкой символов в стандарте Unicode. При этом символ может быть задан своим десятичным кодом (&amp;#код;) или шестнадцатеричным кодом (&amp;#xкод;). Например &#169; представляет символ авторского права ©, а &#x410; – русскую букву А.\n\n
1.4. Комментарии\n
HTML-документы могут содержать комментарии, которые не влияют на отображение документа, а только поясняют его содержимое при просмотре HTML-текста. Комментарии в HTML имеют довольно сложный синтаксис, поэтому мы рекомендует следовать следующим четким правилам:\n
•	начинайте комментарий с символов "&lt;!--",\n
•	завершайте комментарий символами "-->",\n
•	не используйте внутри комментария символов "--".\n\n
Пример комментариев:\n
        &lt;!-- это комментарий -->\n
        &lt;!-- а вот еще комментарий,\n
             занимающий более одной строки -->\n\n

2. Типы данных HTML\n
Значения атрибутов в языке HTML могут иметь различные типы данных. Основными типами данных являются следующие.\n\n
CDATA - Значения атрибутов типа CDATA являются цепочками символов, включая, возможно, специальные символы. Обычно (но не всегда) значения типа CDATA зависят от регистра.\n\n
ID и NAME - Значения атрибутов должны состоять только из латинских букв, цифр, дефисов, подчеркиваний, двоеточий и точек. Эти значения зависят от регистра. Они отличаются тем, что NAME может содержать специальные символы, а ID не может.\n\n
IDREF и IDREFS - Значения указывают на идентификаторы, т. е. на значения атрибута id других элементов. Значение типа IDREF — это единственный идентификатор, а значение типа IDREFS — это список идентификаторов, разделенных пробелами. IDREF и IDREFS зависят от регистра.\n\n
Число - Числовые значения атрибутов — это десятичные числа, состоящие хотя бы из одной цифры.\n\n
Текст - Текстовые значения атрибутов — это значения типа CDATA, представляющие собой осмысленный текст.\n\n
URI - Значения атрибутов типа URI(Любой ресурс в Сети имеет уникальный адрес, по которому этот ресурс может быть найден. протокол://авторизация/путь?запрос) — это унифицированные идентификаторы ресурсов (полные или относительные).\n\n
Цвет - Цветовые значения атрибутов могут задаваться либо шестнадцатеричным числом с префиксом "#" вида "#rrggbb", задающим RGB-код цвета, либо одним из 16-ти символических имен. Имена цветов не зависят от регистра.\n\n
Пиксели - Значения этого типа — целые числа, задающие количество пикселей.\n\n
Размер - Значения этого типа — либо целые числа, задающие количество пикселей, либо доли в процентах от размера по горизонтали или вертикали: например, 50% означает половину всего размера, а 50 означает 50 пикселей.\n\n
Кратный размер - Кратный размер — это либо целое число, задающее количество пикселей, либо доля в процентах от размера по горизонтали или вертикали, либо относительный размер вида i*, где i — целое число. При распределении пространства обозреватель сначала выделяет место для размеров, заданных в числах и процентах, а затем разделяет оставшееся пространство между элементами с относительными размерами. Элементу размером 3* будет выделено пространство в три раза большее, чем элементу размером 1*. Значение * эквивалентно 1* и часто означает "заполнить оставшееся пространство".\n\n
Кратные размеры - Значения этого типа — список кратных размеров, разделенных запятыми.\n\n
Тип файла - Значения атрибутов этого типа задают типы файлов MIME (audio, image, message) для связанных или вложенных ресурсов.\n\n
Типы файлов - Значения этого типа — список типов файлов, разделенных запятыми.\n\n
Код языка - Код языка не зависит от регистра и не должен содержать пробелов (атрибут lang значение ru для русского языка).\n\n
Кодировка и Кодировки - Значение типа Кодировка — это единственное имя таблицы кодировки, а значение типа Кодировки — это список имен, разделенных пробелами или запятыми. Они не зависят от регистра (параметр charset, п-р: charset=”utf-8”).\n\n
Символ - Значение символьного атрибута — это единственный символ Unicode, который может быть также специальным символом.\n\n
Дата-время - Значения атрибутов этого типа задают дату и время в формате ГГГГ-ММ-ДДТчч:мм:ссУВЗ, УВЗ — указатель временной зоны. Буква Т отделяет дату от времени. Если какой-либо из компонентов времени неизвестен, то используется00. Указатель временной зоны может принимать следующие значения:\n\n
· Z (прописная), указывающая на время по Гринвичскому меридиану (UTC, Universal Coordinated Time);\n
· +чч:мм, положительная разница с временем UTC в часах и минутах;\n
· -чч:мм, отрицательная разница с временем UTC в часах и минутах.\n\
Типы ссылок - Значения атрибутов этого типа представляют собой список типов ссылок, разделенных пробелами. Тип ссылки не зависит от регистра и не может содержать пробелов. (Например, в HTML 4.0 пропущен очень популярный тип ссылки Made, обеспечивающий контакт с автором документа: &lt;LINK rev="Made" href="mailto:somebody@somewhere.com">).\n\n
Устройства - Значения атрибутов этого типа представляют собой список имен устройств для отображения документа, разделенных пробелами. Имена устройств зависят от регистра (print – принтер, screen – графический дисплей)\n\n
Сценарий - Значения атрибутов этого типа — это сценарии клиента, которые обычно представляют собой вызов функции или несколько операторов на интерпретируемом языке. Синтаксис сценария определяется синтаксическими правилами соответствующего языка программирования.\n\n
Таблица стилей - Значения атрибутов этого типа — таблицы стилей на языке CSS.\n\n
Фрейм - Значения атрибутов этого типа задают имена фреймов. Они должны начинаться с латинской буквы (A-Za-z), за исключением следующих специальных значений (_blank - Загрузить документ в новое безымянное окно. _self - Загрузить документ в окно текущего фрейма. _parent - Загрузить документ в окно предка текущего фрейма._top - Загрузить документ в полное текущее окно, отменяя тем самым все фреймы).\n
</item>
        <!--25-->
        <item>25.ОБЩИЕ АТРИБУТЫ ЭЛЕМЕНТОВ HTML. БЛОЧНЫЕ И СТРОЧНЫЕ ЭЛЕМЕНТЫ.\n\n\n\n
Общие атрибуты HTML\n
В этом разделе находятся атрибуты HTML-тегов, которые для большинства из них являются общими. Вообще, полностью общими для всех тегов данные атрибуты стали только с версии HTML 5, до этого каждый их них поддерживал только определенное количество атрибутов из данного списка. Поэтому, чтобы узнать, поддерживает ли конкретный тег определенный атрибут, например в HTML 4.01, — необходимо перейти на страницу его описания.\n\n
Общие атрибуты\n
•	accesskey — устанавливает клавишу быстрого доступа для фокусировки на элементе.\n
•	class — задает имя класса или классов элемента, используемых в CSS (Каскадные таблицы стилей).\n
•	dir — указывает направление текста внутри элемента.\n
•	id — задает имя идентификатора элемента, который может использоваться в качестве «якоря» для перехода к нему по ссылке (&lt;A>) или в таблицах стилей.\n
•	lang — указывает язык, на котором написан текст внутри элемента.\n
•	style — используется для применения встроенных стилей в CSS.\n
•	tabindex — устанавливает порядок табуляции между элементами (клавиша Tab).\n
•	title — выводит всплывающую подсказку при наведении курсора мыши на элемент.\n

Блочные и строчные элементы\n
Выделяют две основные категории HTML-элементов, которые соответствуют типам их содержимого и поведению в структуре веб-страницы — блочные и строчные элементы. С помощью блочных элементов можно создавать структуру веб-страницы, строчные элементы используются для форматирования текстовых фрагментов (за исключением элементов &lt;area> и &lt;img>).\n
Разделение элементов на блочные и строчные используется в спецификации HTML до версии 4.01. В HTML5 эти понятия заменены более сложным набором категорий контента, согласно которым каждый HTML-элемент должен следовать правилам, определяющим, какой контент для него допустим.\n\n
Модель визуального форматирования CSS в деталях\n\n
1. Модель визуального форматирования\n
HTML-документ организован в виде дерева элементов и текстовых узлов. Модель визуального форматирования CSS представляет собой алгоритм, который обрабатывает HTML-документ и выводит его на экран устройства.\n
Каждый блок в дереве представляет соответствующий элемент или псевдоэлемент, а текст (буквы, цифры, пробелы), находящийся между открывающим и закрывающим тегами, представляет содержимое текстовых узлов.\n
Чтобы создать дерево блоков, CSS сначала использует каскадирование и наследование, позволяющие назначить вычисленное значение для каждого css-свойства каждому элементу и текстовому узлу в исходном дереве.\n
Затем для каждого элемента CSS генерирует ноль или более блоков в соответствии со значением свойства display этого элемента. Как правило, элемент генерирует один основной блок, который представляет самого себя и содержит свое содержимое. Некоторые значение свойства display, например, display: list-item;, генерируют блок основного блока и блок дочернего маркера. Другие, например, display: none;, приводят к тому, что элемент и/или его потомки вообще не генерируют блоки.\n
Положение блоков на странице определяется следующими факторами:\n
o	размером элемента (с учётом того, заданы они явно или нет);\n
o	типом элемента (строчный или блочный);\n
o	схемой позиционирования (нормальный поток, позиционированные или плавающие элементы);\n
o	отношениями между элементами в DOM (родительский — дочерний элемент);\n
o	внутренними размерами содержащихся изображений;\n
o	внешней информацией (например, размеры окна браузера).\n\n
2. Блочные элементы и блочные контейнеры\n
Блочные элементы — элементы высшего уровня, которые форматируются визуально как блоки, располагаясь на странице в окне браузера вертикально. Значения свойства display, такие как block, list-item и table делают элементы блочными. Блочные элементы генерируют основной блок, который содержит только блок элемента. Элементы со значением display: list-item генерируют дополнительные блоки для маркеров, которые позиционируются относительно основного блока.\n
&lt;address>, &lt;article>, &lt;aside>,\n
&lt;blockquote>,\n
&lt;dd>, &lt;div>, &lt;dl>, &lt;dt>, &lt;details>,\n
&lt;fieldset>, &lt;figcaption>, &lt;figure>, &lt;footer>, &lt;form>,\n
&lt;h1>-&lt;h6>, &lt;header>, &lt;hr>,\n
&lt;li>, &lt;legend>,\n
&lt;nav>, &lt;noscript>,\n
&lt;ol>, &lt;output>, &lt;optgroup>, &lt;option>,\n
&lt;p>, &lt;pre>,\n
&lt;section>, &lt;summary>,\n
&lt;table>,\n
&lt;ul>\n
Блочные элементы могут размещаться непосредственно внутри элемента &lt;body>. Они создают разрыв строки перед элементом и после него, образуя прямоугольную область, по ширине занимающую всю ширину веб-страницы или блока-родителя.\n
Блочные элементы могут содержать как строчные, так и блочные элементы, но не оба типа элементов сразу. При необходимости, строки текста, принадлежащие блочному контейнеру, могут быть обёрнуты анонимными контейнерами, которые будут вести себя внутри блока как элементы со значением display: block;, а строчные элементы обёрнуты элементом &lt;p>. Блочные элементы могут содержаться только в пределах блочных элементов.\n
Элемент &lt;p> относится к блочным элементам, но он не должен содержать внутри себя другой элемент &lt;p>, а также любой другой блочный элемент.\n
Анонимные блоки уровня блока\n
Как говорилось выше, блочные элементы могут содержать только блочные или только строчные элементы. В случае смешанного контента, когда блочный элемент одновременно содержит текстовое содержимое и другой блочный элемент, алгоритм визуального форматирования добавляет дополнительную обёртку для текстового содержимого — так называемый анонимный блок. Анонимный блок не связан ни с одним элементом. Поскольку такой контейнер не имеет названия, то к нему нельзя применить CSS-стили для оформления. Анонимные блоки наследуют свойства окружающего блока, а не наследуемые свойства принимают первоначальное значение.\n\n

3. Строчные элементы и строчные контейнеры
Встроенные (строчные) элементы генерируют внутристрочные контейнеры. Они не формируют новые блоки контента. Значения свойства display, такие как inline и inline-table делают элементы строчными.\n
&lt;a>, &lt;area>,\n
&lt;b>, &lt;bdo>, &lt;bdi>,\n
&lt;cite>, &lt;code>,\n
&lt;dfn>, &lt;del>,\n
&lt;em>,\n
&lt;i>, &lt;iframe>, &lt;img>, &lt;ins>,\n
&lt;kbd>,\n
&lt;label>,\n
&lt;map>, &lt;mark>,\n
&lt;s>, &lt;samp>, &lt;small>, &lt;span>, &lt;strong>, &lt;sub>, &lt;sup>,\n
&lt;time>,\n
&lt;q>,\n
&lt;ruby>,\n
&lt;u>,\n
&lt;var>\n\n

Строчные элементы могут содержать только данные и другие строчные элементы. Исключение составляет элемент &lt;a>, который согласно спецификации HTML5 может оборачивать целые абзацы, списки, таблицы, заголовки и целые разделы при условии, что они не содержат другие интерактивные элементы — другие ссылки и кнопки.\n
Анонимные блоки уровня строки\n
Любой текст, содержащийся непосредственно внутри блочного элемента и не внутри строчного элемента, рассматривается как анонимный строчный элемент. Также как и анонимные блоки уровня блока они наследуют свойства родительского блока, а не наследуемые свойства принимают первоначальное значение.\n\n
4. Строчно-блочные элементы\n
Существует еще одна группа элементов, которые браузер обрабатывает как строчно-блочные {display: inline-block;}. Такие элементы являются встроенным, но для них можно задавать поля, отступы, ширину и высоту.\n
&lt;audio>,\n
&lt;button>,\n
&lt;canvas>,\n
&lt;embed>,\n
&lt;input>,\n
&lt;keygen>,\n
&lt;meter>,\n
&lt;object>,\n
&lt;progress>,\n
&lt;select>,\n
&lt;textarea>,\n
&lt;video>.\n
</item>
        <!--26-->
        <item>26.	СОЗДАНИЕ ТАБЛИЦ В HTML-ДОКУМЕНТАХ. ОСНОВНЫЕ АТРИБУТЫ ТАБЛИЦ, СТРОК, ЯЧЕЕК.\n\n\n\n
HTML-таблицы упорядочивают и выводят на экран данные с помощью строк или столбцов. Таблицы состоят из ячеек, образующихся при пересечении строк и столбцов. Ячейки таблиц могут содержать любые HTML-элементы, такие как заголовки, списки, текст, изображения, элементы форм, а также другие таблицы. Каждой таблице можно добавить связанный с ней заголовок, расположив его перед таблицей или после неё.\n
Таблицы больше не используются для вёрстки веб-страниц и компоновки отдельных элементов, потому что такой приём не обеспечивает гибкость структуры и адаптивность сайта, существенно увеличивая HTML-разметку.\n
Для всех элементов таблицы доступны ‎глобальные атрибуты, а также собственные атрибуты.\n\n
Создание таблиц в HTML\n
1. Как создать таблицу\n
Таблица создаётся при помощи парного тега <table></table>. Данный тег является контейнером для элементов таблицы и все элементы должны находиться внутри него. Например, с помощью данной разметки можно создать таблицу, состоящую из двух столбцов и двух строк:\n
&lt;table>\n
\t\t\t\t&lt;tr>&lt;th>текст заголовка&lt;/th>&lt;th>текст заголовка&lt;/th>&lt;/tr> &lt;!--ряд с ячейками заголовков-->\n
\t\t\t\t&lt;tr>&lt;td>данные&lt;/td>&lt;td>данные&lt;/td>&lt;/tr> &lt;!--ряд с ячейками тела таблицы-->\n
&lt;/table>\n\n

По умолчанию таблица и ячейки не имеют видимых границ. Границы задаются с помощью свойства border:\n
/* внешние границы таблицы серого цвета толщиной 1px */\n
table {border: 1px solid grey;}\n
/* границы ячеек первого ряда таблицы */\n
th {border: 1px solid grey;}\n
/* границы ячеек тела таблицы */\n
td {border: 1px solid grey;}\n\n

Промежутки между ячейками таблицы убираются с помощью свойства table {border-collapse: collapse;}.\n
Ширина таблицы по умолчанию равна ширине её внутреннего содержимого. Чтобы установить ширину, нужно задать значение для свойства width:\n
/* сделает ширину таблицы равной ширине блока контейнера, в котором она находится */\n
table {width: 100%;}\n
/* задаст фиксированную ширину для таблицы */\n
table {width: 600px;}\n\n

Если для ячеек таблицы заданы внутренние отступы и границы, то ширина таблицы будет включать в себя следующие значения:\n
padding-left и padding-right, ширина border-left плюс ширина border-right последней ячейки в ряду. Если заданы ширина и границы ячеек, то ширина таблицы будет складываться из ширины ячеек плюс ширина border-left и ширина border-right последней ячейки в ряду.\n\n
2. Как создать строки (ряды) таблицы\n
Строки или ряды таблицы создаются с помощью тега &lt;tr>. Количество горизонтальных строк таблицы определяется количеством парных тегов &lt;tr>&lt;/tr>.\n\n
3. Как сделать ячейку заголовка столбца таблицы\n
Элемент &lt;th> создаёт заголовок столбца — специальную ячейку, текст в которой выделяется полужирным. Количество ячеек заголовка определяется количеством пар тегов &lt;th>&lt;/th>. Для элемента доступны атрибуты colspan, rowspan, headers.\n\n
&lt;table>\n
&lt;tr>&lt;th>ячейка заголовка&lt;/th>&lt;th>ячейка заголовка&lt;/th>&lt;/tr>\n
&lt;/table>\n\n

4. Как сделать ячейку тела таблицы\n
Элемент &lt;td> создаёт ячейки таблицы, внутрь которых помещаются данные таблицы. Парные теги &lt;td>&lt;/td>, расположенные в одном ряду, определяют количество ячеек в строке таблицы. Количество пар ячеек &lt;td> должно быть равно количеству пар ячеек &lt;th>. Для элемента доступны атрибуты colspan, rowspan, headers.\n\n
&lt;table>\n
&lt;tr>&lt;th>ячейка заголовка&lt;/th>&lt;th>ячейка заголовка&lt;/th>&lt;/tr>\n
&lt;tr>&lt;td>ячейка тела таблицы&lt;/td>&lt;td>ячейка тела таблицы&lt;/td>&lt;/tr>\n
&lt;/table>\n\n

5. Как добавить подпись (заголовок) к таблице\n
Элемент &lt;caption> создает подпись таблицы. Добавляется непосредственно после тега &lt;table>, вне строки или ячейки.\n\n
&lt;table>\n
&lt;caption>Перечень продуктов&lt;/caption>\n
  &lt;tr>\n
    &lt;th>№ п/п&lt;/th>\n
    &lt;th>Наименование товара&lt;/th>\n
    &lt;th>Ед. изм.&lt;/th>\n
    &lt;th>Количество&lt;/th>\n
    &lt;th>Цена за ед. изм., руб.&lt;/th>\n
    &lt;th>Стоимость, руб.&lt;/th>\n
  &lt;/tr>\n
  &lt;tr>\n
    &lt;td>1.&lt;/td>\n
    &lt;td>Томаты свежие&lt;/td>&lt;td>кг&lt;/td>&lt;td>15,20&lt;/td>&lt;td>69,00&lt;/td>&lt;td>1048,80&lt;/td>\n
  &lt;/tr>\n
  &lt;tr>\n
    &lt;td>2.&lt;/td>\n
    &lt;td>Огурцы свежие&lt;/td>&lt;td>кг&lt;/td>&lt;td>2,50&lt;/td>&lt;td>48,00&lt;/td>&lt;td>120,00&lt;/td>\n
  &lt;/tr>\n
  &lt;tr>\n
    &lt;td colspan="5" style="text-align:right">ИТОГО:&lt;/td>&lt;td>1168,80&lt;/td>\n
  &lt;/tr>\n
&lt;/table>\n\n

6. Группирование строк и столбцов таблицы\n
Элемент &lt;colgroup> создает структурную группу столбцов, выделяя логически однородные ячейки. Группирует один или более столбцов для единого форматирования, позволяя применить стили к столбцам вместо того, чтобы повторять стили для каждой ячейки и для каждой строки. Добавляется непосредственно после тегов &lt;table> и &lt;caption>.\n
Элемент &lt;col> формирует группы столбцов, которые делят таблицу на разделы, не относящиеся к общей структуре, т.е. не содержащие информацию одного типа. Позволяет задавать свойства столбцов для каждого столбца в пределах элемента &lt;colgroup>. С помощью атрибута style можно изменить основной цвет фона ячеек. Для элемента &lt;col> доступен атрибут span, задающий количество столбцов для объединения.\n\n
&lt;table>\n
  &lt;colgroup>\n
    &lt;col span="2" style="background:Khaki">&lt;!-- С помощью этой конструкции задаем цвет фона для первых двух столбцов таблицы-->\n
      &lt;col style="background-color:LightCyan">&lt;!-- Задаем цвет фона для следующего (одного) столбца таблицы-->\n
  &lt;/colgroup>\n
  &lt;tr>\n
    &lt;th>№ п/п&lt;/th>\n
    &lt;th>Наименование&lt;/th>\n
    &lt;th>Цена&lt;/th>\n
  &lt;/tr>\n
  &lt;tr>\n
    &lt;td>1&lt;/td>\n
    &lt;td>Карандаш цветной&lt;/td>\n
    &lt;td>20,00&lt;/td>\n
  &lt;/tr>\n
  &lt;tr>\n
    &lt;td>2&lt;/td>\n
    &lt;td>Линейка 20 см&lt;/td>\n
    &lt;td>30,00&lt;/td>\n
  &lt;/tr>\n
&lt;/table>\n\n

№ п/п Наименование \t\t\t\tЦена\n
\t1 \t\t\tКарандаш цветной 20,00\n
\t2 \t\t\tЛинейка, 20см \t\t\t30,00\n\n

7. Группировка разделов таблицы\n
Элемент &lt;thead> создает группу заголовков для строк таблицы с целью задания единого оформления. Используется в сочетании с элементами &lt;tbody> и &lt;tfoot> для указания каждой части таблицы.\n
Элемент должен быть использован в следующем порядке: как дочерний элемент &lt;table>, после &lt;caption> и &lt;colgroup>, и перед &lt;tbody>, &lt;tfoot> и &lt;tr> элементами. В пределах одной таблицы можно использовать один раз.\n
Элемент &lt;tbody> группирует основное содержимое таблицы. Используется в сочетании с элементами &lt;thead> и &lt;tfoot>.\n
Элемент &lt;tfoot> создает группу строк для представления информации о суммах или итогах, расположенную в нижней части таблицы. Используется в таблице один раз. Располагается после тега &lt;thead>, перед тегами &lt;tbody> и &lt;tr>.\n\n
&lt;table>\n
 &lt;thead>\n
  &lt;tr>\n
    &lt;th>№ п/п&lt;/th>\n
    &lt;th>Наименование товара&lt;/th>\n
     &lt;th>Ед. изм.&lt;/th>\n
     &lt;th>Количество&lt;/th>\n
     &lt;th>Цена за ед.&lt;/th>\n
     &lt;th>Стоимость&lt;/th>\n
  &lt;/tr>\n
 &lt;/thead>\n
&lt;tfoot>\n
  &lt;tr>\n
    &lt;td colspan="5" style="text-align:right">ИТОГО:&lt;/td>&lt;td>1168,80&lt;/td>\n
  &lt;/tr>\n
&lt;/tfoot>\n
&lt;tbody>\n
  &lt;tr>\n
    &lt;td>1.&lt;/td>\n
    &lt;td>Томаты свежие&lt;/td>&lt;td>кг&lt;/td>&lt;td>15,20&lt;/td>&lt;td>69,00&lt;/td>&lt;td>1048,80&lt;/td>\n
  &lt;/tr>\n
  &lt;tr>\n
    &lt;td>2.&lt;/td>\n
    &lt;td>Огурцы свежие&lt;/td>&lt;td>кг&lt;/td>&lt;td>2,50&lt;/td>&lt;td>48,00&lt;/td>&lt;td>120,00&lt;/td>\n
  &lt;/tr>\n
&lt;/tbody>\n
&lt;/table>\n\n

Такая группировка строк была заложена в стандарте в расчете на то, что обозреватели при отображении длинных таблиц обеспечат прокрутку строк данных при сохранении надзаголовка и подзаголовка неподвижными, а при их выводе на принтер смогут использовать надзаголовок и подзаголовок в качестве колонтитулов страницы. Однако, современные обозреватели этого не делают и либо просто отображают &lt;thead> и &lt;tfoot> как строки данных, либо, в лучшем случае, просто помещают соответствующие строки в начало и конец таблицы.\n\n

8. Как объединить ячейки таблицы\n
Атрибуты colspan и rowspan объединяют ячейки таблицы. Атрибут colspan задает количество ячеек, объединенных по горизонтали, а rowspan — по вертикали.\n\n
&lt;table>\n
  &lt;tr>\n
    &lt;th>№ п/п&lt;/th>\n
    &lt;th>Наименование товара&lt;/th>\n
     &lt;th>Ед. изм.&lt;/th>\n
     &lt;th>Количество&lt;/th>\n
     &lt;th>Цена за ед. изм., руб.&lt;/th>\n
     &lt;th>Стоимость, руб.&lt;/th>\n
  &lt;/tr>\n
  &lt;tr>\n
    &lt;td>1.&lt;/td>\n
    &lt;td>Томаты свежие&lt;/td>&lt;td>кг&lt;/td>&lt;td>15,20&lt;/td>&lt;td>69,00&lt;/td>&lt;td>1048,80&lt;/td>\n
  &lt;/tr>\n
  &lt;tr>\n
    &lt;td>2.&lt;/td>\n
    &lt;td>Огурцы свежие&lt;/td>&lt;td>кг&lt;/td>&lt;td>2,50&lt;/td>&lt;td>48,00&lt;/td>&lt;td>120,00&lt;/td>\n
  &lt;/tr>\n
  &lt;tr>\n
    &lt;td colspan="5" style="text-align:right">ИТОГО:&lt;/td>&lt;td>1168,80&lt;/td>&lt;!-- Задаем количество ячеек по горизонтали для объединения-->\n
  &lt;/tr>\n
&lt;/table>\n\n

9. Атрибуты элементов таблицы\n
ТАБЛИЦА 1. АТРИБУТЫ ЭЛЕМЕНТОВ ТАБЛИЦЫ\n
Атрибут	Описание, принимаемое значение\n
colspan	Количество ячеек в строке для объединения по горизонтали.\n
&lt;td colspan="3">\n
Возможные значения: число от 1 до 999.\n
headers	Задает список ячеек заголовка, содержащих информацию о заголовке текущей ячейки данных. Предназначен для речевых браузеров.\n
&lt;th id="идентификатор">...&lt;/th>\n
&lt;th headers="идентификатор">...&lt;/th>\n
Принимаемые значения: список имен ячеек, разделенных пробелами; эти имена должны быть присвоены ячейкам через их атрибут id.\n
rowspan	Количество ячеек в столбце для объединения по вертикали.\n
&lt;td rowspan="2">\n
Возможные значения: число от 1 до 999.\n
span	Количество колонок, объединяемых для задания единого стиля, по умолчанию равно 1.\n
&lt;col span="2">\n
Принимаемые значения: любое целое положительное число.\n
</item>
        <!--27-->
        <item>27.ПОНЯТИЕ ОБЪЕКТА В HTML-ДОКУМЕНТАХ. ЭЛЕМЕНТЫ ФОРМ.\n\n\n\n\n
Общие понятия об объектах в HTML\n
Для того, чтобы добавить создаваемым Web-страницам дополнительные возможности, мы можем вставлять в состав их содержимого специализированные функциональные элементы. В качестве подобных элементов часто выступают Java-апплеты, элементы ActiveX, Flash-ролики и многое другое. Как их обрабатывает браузер, нас заботить не должно. Он все равно сделает это правильно. Нас интересует, как их внедрять в Web-страницы.\n
До тех пор, пока мы не научились сами создавать функциональные объекты, пользуясь какой-либо достаточно серьезной технологией, часто требующей хороших навыков программиста, мы можем использовать подобные компоненты от сторонних производителей. Благо подобные компоненты в изобилии выложены в Сети. Главное, их найти и правильно внедрить в Web-страницу.\n
Для вставки некоего функционального объекта, следует воспользоваться тэгом <object>. Для него существует и закрывающий тэг </object>. Между этими двумя тэгами обычно размещается список дополнительных данных, которые передаются объекту в качестве параметров, и некий текст, который будет отображаться, если браузер все-таки не сможет правильно обработать внедренный объект. Здесь необходимо различать свойства объекта, которые мы задаем при помощи параметров тэга, и дополнительные данные, которые передаются как параметры самого объекта при помощи специализированных тэгов.\n
Так, например, если мы хотим вставить в свою Web-страницу некий элемент ActiveX, демонстрирующий изменение некоторой зависимости на графике, то нам потребуется, помимо внедрения самого объекта, установить еще и начальные данные. Для этого придется воспользоваться приблизительно следующей конструкцией:\n\n
&lt;object classid="clsid:EB39F965-2374-llD3-85Fl-F21"\n
\t\t\tcodebase="http://www.mysite.com/scripts..."\n
\t\t\twidth="500 height-300 align center">\n
\t\t\t&lt;param name="start" value="0" valuеtype="data">\n
\t\t\t<p>K сожалению, Ваша операционная система не поддерживает технологию ActiveX</p>\n
&lt;object>\n\n
В данном примере мы при объявлении внедренного объекта использовали в объявляющем тэге несколько параметров. Параметр classid применяется для установки идентификатора внедряемого элемента, а параметр codebase задает URL файла, в котором и содержится внедряемый объект. Обычно для распространяемых объектов подобные параметры детально описываются в сопроводительном тексте. Чуть позже мы подробно рассмотрим все параметры этого тэга. После тэга &lt;object> мы разместили тэг &lt;param>, при помощи которого задали начальные данные для внедренного объекта. Проще всего рассматривать подобные передаваемые параметры как переменные. На каждую передаваемую переменную требуется один тэг &lt;рагаm>. Но теперь, все-таки, перейдем к рассмотрению многочисленных параметров тэга &lt;оbject>.\n
  •  Параметр classid, как мы уже знаем, применяется для установки уникального идентификатора внедряемого элемента. Часто его просто необходимо использовать, так как внедряемый элемент сохраняется в локальной системе пользователя, как, например, элементы ActiveX.\n
•  Параметр codebase предназначен для указания URL, который указывает на некий файл или каталог, в котором располагаются все необходимые для функционирования внедряемого элемента файлы.\n
•  Параметр data предназначен для задания местоположения графических изображений или иных блоков данных, которые используются встраиваемым объектом для своей деятельности. В качестве значения параметра используется URL, указывающий на файл с требуемым блоком данных.\n
•  Параметр type задает тип данных, на которые указывает предыдущий параметр. В качестве значения данного параметра используется одно из стандартных наименований типов данных, определенных в протоколе HTTP.\n
•  Параметр codetype позволяет указывать тип подключаемого объекта. Рекомендуется использовать данный параметр в тех случаях, когда информации, находящейся в параметре classid недостаточно для того, чтобы четко указать тип внедряемого элемента.\n
•  Параметр archive позволяет указывать местоположение архивных данных, которые имеют отношение к внедренному объекту, например, его обновлению. В некоторых случаях это позволяет сократить общее время загрузки новой версии внедряемого объекта. В качестве значения данного параметра используется список URL, разделенный пробелами.\n
•  Параметр declare не имеет значений. Если он входит в состав тэга &lt;object>, то внедряемый объект просто объявляется, но не вставляется в Web-страницу. Обычно параметр применяется, если у нас есть несколько тэгов &lt;object>, вставленных друг в друга.\n
•  Параметр standby позволяет задавать текст, который будет отображаться на месте объекта, пока он сам загружается из Сети. В качестве значения параметра используется обычная текстовая строка.\n
•  Параметр height предназначен для явного указания высоты объекта. В качестве значения параметра используется количество пикселов, абсолютное или кратное, или процентное соотношение.\n
•  Параметр width позволяет явно задавать ширину внедряемого объекта. В качестве значения используется один из стандартных вариантов задания размеров.\n
•  Параметр usemap используется, если внедряемый объект является графическим изображением, которое предназначено для использования в качестве сегментированной карты. Вопросы использования сегментированной графики мы рассматривали в разделе, посвященном гиперссылкам. В качестве значения параметра используется имя карты ссылок, заданное в параметре name тэга &lt;тар>, объявляющего подключаемую карту сегментов.\n
•  Параметр name позволяет задавать уникальное идентифицирующее имя данного конкретного внедряемого объекта.\n
•  Параметр tabindex Позволяет задавать порядковый номер объекта в последовательности органов управления, размещенных на Web-странице, переход между которыми производится при помощи клавиши табуляции.\n
•  Параметр hspace задает размеры свободного пространства по горизонтали между встроенным объектом и остальным содержимым Web-страницы. В качестве значения, используется число, обозначающее количество пикселов в отступе.\n
•  Параметр vspace позволяет задавать отступы про вертикали. В качестве значения используется все то же количество пикселов.\n
•  Параметр border задает толщину границы, обрамляющей внедренный объект. В качестве значения используется количество пикселов.\n
•  Параметр align позволяет задавать вертикальное или горизонтальное выравнивание объекта относительно остального содержимого Web-страницы. В качестве значения используется одно из уже знакомых нам ключевых слов: bottom, middle, top, left, right. Механизм их действия подробно описывался в разделе, посвященном использованию графики.\n
Если встраиваемому объекту необходимо передавать начальные данные для работы, то для этих целей применяется тэг &lt;param>, который мы уже упоминали ранее. Он помещается между тэгами <object> и </object>. Если мы передаем данные объекту, то тот принимает их как переменные. Следовательно, нам необходимо задать имя этой переменной, чтобы объект мог правильно ее распознать, и значение переменной. Это минимальные требования. На самом деле, мы можем сделать больше. Все эти действия производятся при помощи параметров &lt;param>. Всего этих параметров — пять. Помимо общего идентифицирующего параметра id, есть и четыре специфичных.\n
•  Параметр name является обязательным для тэга &lt;param>. При помощи значения этого параметра мы устанавливаем имя передаваемой переменной. Значением параметра является текст. Так как существуют самые различные методы создания встраиваемых объектов, то может получиться так, что это наименование переменной будет чувствительно к регистру символов. Поэтому стоит придерживаться того наименования, которое приводится в описании объекта.\n
•  Параметр value предназначен для установки значения передаваемой переменной. Значением данного параметра является текст. Встраиваемый объект сам берет на себя его распознавание.\n
•  Параметр valuetype позволяет задавать тип передаваемого значения. Это могут быть данные в каком-либо стандартизованном формате, ссылка на некий ресурс в Сети или другой объект. Кроме того, некоторые встраиваемые объекты в качестве переменных могут принимать другие объекты, причем, их тип может и не совпадать. В качестве значения параметра может использоваться одно из трех ключевых слов. Значение data, установленное по умолчанию, указывает, что используется стандартная переменная, передающая данные какого-либо типа. Как и упоминалось, мы передаем данные как строку, а объект сам интерпретирует их. Значение ref указывает, что в качестве переменной передается ссылка на какой-либо ресурс в Сети: А значение object сигнализирует, что мы передаем в качестве стартовых данных другой объект.\n
•  Параметр type используется в тех случаях, когда параметр valuetype имеет значение ref, т.е. когда в качестве переменной мы передаем ссылку на некий ресурс в Сети. Данный параметр указывает, какой тип имеет ресурс, на который мы ссылаемся.\n
И на этом перечень используемых параметров тэга &lt;param> заканчивается. Еще раз напомню, что когда мы берем из Сети некий встраиваемый объект, к нему всегда прилагается сопроводительный текст, в котором рассказывается, как подключать данный объект, и какие стартовые данные ему нужны для работы. Внимательно читайте инструкцию, это может серьезно сэкономить вам время.\n
Среди встраиваемых объектов HTML выделяет в особую группу Java-апплеты. Для того, чтобы внедрить их в состав содержимого Web-страниц, предусмотрен специализированный тэг &lt;applet>. Но прежде, чем мы разберем его использование, стоит все-таки узнать, что такое Java-апплеты.\n
Язык Java изначально задумывался для создания приложений, которые бы выполнялись на любой компьютерной платформе без изменения кода, т. е. с использованием Java не нужно писать отдельные версии программного обеспечения для компьютеров на базе Intel-процессоров и компьютеров семейства Macintosh, или для различных операционных систем.\n
Подобная "многоликость" достигается за счет очень остроумного решения. Java-приложения записываются не в кодах какого-либо процессора, как обычные исполняемые программы, а в своем специализированном формате, называемом байт-кодом. Этот байт-код распознается не процессором, а другим приложением, которое называется виртуальной Java-машиной, Вот эта виртуальная Java-машина пишется для каждой компьютерной системы отдельно. Она переводит байт-код в команды процессора. Эти виртуальные Java-машины написаны уже почти для каждой операционной системы, поэтому Java-приложения медленно, но верно завоевывают популярность.\n
Естественно, возможность выполнения кода на любой компьютерной системе — это именно то, чего не хватает WWW. Ведь если документы читают браузеры, то активные элементы должны обрабатываться непосредственно операционной системой; и если сделать ставку на какое-либо решение, которое действует только в одной системе, то тем самым мы отсекаем от своего ресурса пользователей остальных компьютерных платформ и операционных систем.\n
Поэтому был разработан дополнительный стандарт облегченных Java-приложений, которые могли бы внедряться в Web-страницы. Подобные облегченные Java-приложения называются Java-апплетами. Вставляются в содержимое Web-страниц они при помощи тэга <appiet>. Но специфика использования его ничем не отличаются от правил использования тэга &lt;object>. И наборы параметров этих двух тэгов практически не различаются. В тэге &lt;applet> могут применяться параметры codebase, code, name, archive, width, height, alt, align, hspace, vspace. Естественно, функциональность этих параметров не отличается от функциональности их близнецов, используемых в тэге &lt;object>. Между тэгами &lt;applet> и </appiet> могут размещаться тэги &lt;param>, задающие стартовые данные для Java-апплета.\n
Следует обратить внимание на то, что в списке параметров отсутствует параметр classid. Дело в том, что тэг; &lt;applet> применяется для объектов строго фиксированного типа, для апплетов, а они унаследовали пакетную структуру из своего прародителя — языка Java. Java-апплеты, если говорить более точно, представляют собой не просто какие-то файлы, а, так называемые, классы, хранимые в Java-пакетах. Поэтому для идентификации используется просто наименование класса, которое записывается в параметре name.\n
И на этом мы заканчиваем рассмотрение внедряемых исполняемых объектов. Еще раз повторюсь: до тех пор, пока вы не умеете создавать их самостоятельно, а для этого необходимо уметь программировать немного лучше начального уровня, следует использовать общедоступные внедряемые элементы. Однако при их использовании все-таки следует соблюдать определенную осторожность, так как исполняемые объекты от неизвестных производителей потенциально могут быть опасны для пользователей. Следует пользоваться элементами, которые уже прошли проверку временем и интернет-сообществом.\n
Раньше в HTML имелась только одна возможность добавлять мультимедийную информацию на web-страницы - элемент IMG. Он позволял добавлять только изображения, а остальные форматы были закрыты для web. Тогда разработчики браузеров стали добавлять поддержку новых элементов. Так появились тэги &lt;embed> от фирмы Netscape и &lt;applet> от фирмы Sun.\n
Но появление этих элементов не решило всех проблем и тогда в спецификацию HTML был добавлен новый элемент &lt;object>, позволяющий работать с любыми форматами. При этом на компьютере пользователя должно быть установлено приложение или дополнительный модуль к браузеру (плагин), позволяющий просматривать объект соответствующего формата.\n\n
Элементы форм\n
Формы состоят из определенного количества элементов ввода. Все элементы ввода помещаются между тегами <form> и </form>\n
Наиболее распространенным элементом ввода является элемент input. Однако реальное действие этого элемента зависит от того, какое значение установлено у его атрибута type. А он может принимать следующие значения:\n
•  text: обычное текстовое поле\n
•  password: тоже текстовое поле, только вместо вводимых символов отображаются звездочки, поэтому в основном используется для ввода пароля\n
•  radio: радиокнопка или переключатель. Из группы радиокнопок можно выбрать только одну\n
•  checkbox: элемент флажок, который может находиться в отмеченном или неотмеченном состоянии\n
•  hidden: скрытое поле\n
•  submit: кнопка отправки формы\n
•  color: поле для ввода цвета\n
•  date: поле для ввода даты\n
•  datetime: поле для ввода даты и времени с учетом часового пояса\n
•  datetime-local: поле для ввода даты и времени без учета часового пояса\n
•  email: поле для ввода адреса электронной почты\n
•  month: поле для ввода года и месяца\n
•  number: поле для ввода чисел\n
•  range: ползунок для выбора числа из некоторого диапазона\n
•  tel: поле для ввода телефона\n
•  time: поле для ввода времени\n
•  week: поле для ввода года и недели\n
•  url: поле для ввода адреса url\n
•  file: поле для выбора отправляемого файла\n
•  image: создает кнопку в виде картинки\n
Кроме элемента input в различных модификациях есть еще небольшой набор элементов, которые также можно использовать на форме:\n
•  button: создает кнопку\n
•  select: выпадающий список\n
•  label: создает метку, которая отображается рядом с полем ввода\n
•  textarea: многострочное текстовое поле\n\n
Атрибуты name и value\n
У всех элементов ввода можно установить атрибуты name и value. Эти атрибуты имеют важное значение. По атрибуту name мы можем идентифицировать поле ввода, а атрибут value позволяет установить значение поля ввода. Например:\n
&lt;html>\n
\t\t&lt;head>\n
\t\t\t\t\t\t&lt;meta charset="utf-8">\n
\t\t\t\t\t&lt;title>Формы в HTML5&lt;/title>\n
\t\t&lt;/head>\n
\t\t&lt;body>\n
\t\t\t&lt;form method="get" action="index.html">\n
\t\t\t\t\t&lt;input type="text" name="login" value="Tom"/>\n
\t\t\t\t\t&lt;input type="password" name="password"/>\n
\t\t\t\t\t&lt;input type="submit" value="Войти" />\n
\t\t\t&lt;/form>\n
\t\t&lt;/body>\n
&lt;/html>\n\n
Здесь текстовое поле имеет значение "Tom" (как указано в атрибуте value), поэтому при загрузке веб-страницы в этом поле мы увидим данный текст.\n
Поскольку методом отправки данных формы является метод "get", то данные будут отправляться через строку запроса. Так как нам в данном случае не важно, как данные будут приниматься, не важен сервер, который получает данные, поэтому в качестве адреса я установил ту же самую страницу - то есть файл index.html. И при отправке мы сможем увидеть введенные данные в строке запроса:\n
В строке запроса нас интересует следующий кусочек:\n
login=Tom&amp;password=qwerty\n
При отправке формы браузер соединяет все данные в набор пар "ключ-значение". В нашем случае две таких пары: login=Tom и password=qwerty. Ключом в этих парах выступает название поля ввода, которое определяется атрибутом name, а значением - собственно то значение, которое введено в поле ввода (или значение атрибута value).\n
Получив эти данные, сервер легко может узнать, какие значения в какие поля ввода были введены пользователем.\n
</item>
        <!--28-->
        <item>28.ТИПЫ УПРАВЛЯЮЩИХ ЭЛЕМЕНТОВ. ПОНЯТИЕ ФРЕЙМОВОЙ СТРУКТУРЫ WEB-СТРАНИЦЫ.\n\n\n\n\n
Типы управляющих элементов\n\n
В HTML определены следующие типы управляющих элементов:\n\n
кнопки:\n
Авторы могут создавать три типа кнопок:\n
•	кнопки отправки: При активизации такой кнопки производится отправка формы. В форме может быть несколько кнопок отправки.\n
•	кнопки сброса: При активизации такой кнопки для всех управляющих элементов устанавливаются исходные значения.\n
•	прочие кнопки: Для таких кнопок действие по умолчанию не определено. С атрибутами событий каждой такой кнопки могут быть связаны клиентские скрипты. Если происходит событие (например, пользователь нажимает кнопку, отпускает ее и т.д.), включается связанный с событием скрипт.\n
Авторы должны определять язык скрипта для кнопок в объявлении скрипта по умолчанию (в элементе META).\n
Авторы создают кнопки с помощью элемента BUTTON или INPUT. Подробнее об определении различных типов кнопок см. в определении этих элементов.\n\n
флажки\n
Флажки (и кнопки с зависимой фиксацией) - это переключатели вкл./выкл., которые могут переключаться пользователем. Переключатель "включен", если для управляющего элемента установлен атрибут selected.\n
При отправке формы успешными могут стать только включенные переключатели. Несколько флажков в форме могут иметь одно и то же имя управляющего элемента. Таким образом, например, флажки позволяют пользователям выбрать несколько значений для одного и того же свойства. Для создания флажков используется элемент INPUT.\n\n
кнопки с зависимой фиксацией\n
Кнопки с зависимой фиксацией похожи на флажки за исключением того, что, если несколько кнопок используют одно и то же имя управляющего элемента, они являются взаимоисключающими: если одна кнопка включена, другие обязательно выключены. Для создания кнопок с зависимой фиксацией используется элемент INPUT.\n\n
меню\n
Предоставляют пользователям варианты на выбор. Меню создается с помощью элемента SELECT, а также элементов OPTGROUP и OPTION.\n\n
текстовый ввод\n
Для ввода текста пользователем авторы могут создавать управляющие элементы двух типов. Элемент INPUT создает управляющий элемент для ввода текста из одной строки, а элемент TEXTAREA - элемент для ввода текста из нескольких строк. В обоих случаях вводимый текст становится текущим значением управляющего элемента.\n\n
выбор файлов\n
Управляющие элементы этого типа позволяют пользователям выбирать файлы, содержимое которых может передаваться вместе с формой. Для создания этого управляющего элемента используется элемент INPUT.\n\n
скрытые управляющие элементы\n
Авторы могут создавать управляющие элементы, не представляемые пользователям, но имеющие значения, которые передаются с формой. Обычно они используются для хранения информации между обменом клиент/сервер, которая в противном случае могла бы пропасть вследствие stateless природы протокола http. Для создания скрытого управляющего элемента используется элемент INPUT.\n\n
объекты\n
Авторы могут помещать в формы общие объекты, так что связанные с ними значения будут передаваться с другими управляющими элементами. Для создания таких управляющих элементов используется элемент OBJECT.\n\n

Фреймы - средство для разделения экрана на несколько областей, в каждой из которых отображается содержимое отдельной Web - страницы или Web - сайта.\n
Фреймы – это прямоугольные области экрана, каждая из которых содержит свой собственный HTML - документ.\n
Тег &lt;FRAMESET>
Тег &lt;FRAMESET> определяет структуру фреймов на Web - странице. Фреймы разделяют окно браузера на отдельные области, расположенные вплотную друг к другу. В каждую из таких областей загружается самостоятельная веб-страница определяемая с помощью тега &lt;FRAME>. С помощью фреймов Web - страница делится на два или более документа, которые обычно содержат навигацию по сайту и его контент. Механизм фреймов позволяет открывать документ в одном фрейме, по ссылке, нажатой в совершенно другом фрейме. Тег <FRAMESET> заменяет тег &lt;BODY> и используется для разделения экрана. Имеет закрывающий тег </FRAMESET>. Допустимо использовать вложенную структуру элементов, это позволяет разбить один фрейм на две и более области.\n\n
Тег &lt;FRAME>.\n
Внутри тегов <FRAMESET> </FRAMESET> располагаются одиночные теги &lt;FRAME>, причем их должно быть столько, сколько задано областей. Без параметров эти теги бесполезны.\n
Тег &lt;FRAME> определяет свойства отдельного фрейма, на которые делится окно браузера. Этот элемент должен располагаться в контейнере &lt;FRAMESET>, который к тому же задает способ разметки страницы на отдельные области. В каждую из таких областей загружается самостоятельная Web – страница, определяемая с помощью атрибута Src. Хотя обязательных атрибутов у тега &lt;FRAME> и нет, рекомендуется задавать каждому фрейму его имя через атрибут Name. Это особенно важно, если требуется по ссылке из одного фрейма загружать документ в другой.\n
&lt;FRAME> Тег для описания рамки (&lt;FRAME SRC="file.htm">).\n\n
Атрибуты тега&lt;FRAME>\n\n
Bordercolor\n
Устанавливает цвет границы фрейма\n\n
Frameborder\n
Определяет, отображать рамку вокруг фрейма или нет.\n\n
Name\n
Задает уникальное имя фрейма.\n\n
Noresize\n
Определяет, можно изменять размер фрейма пользователю или нет.\n\n
Scrolling\n
Определяет присутствие в окне фрейма полосы прокрутки. Может принимать значения "yes", "no" и "auto"(по умолчанию)\n\n
Src\n
Путь к файлу, предназначенному для загрузки во фрейме.\n\n
Marginwidht\n
Определяет расстояние между содержимым фрейма и его границами справа и слева.\n\n
Marginheight\n
Определяет расстояние между содержимым фрейма и его границами сверху и снизу.\n\n
Target\n
Устанавливает связь между фреймами. Определяет имя фрейма, в который будет загружен новый документ. Имеет несколько значений: - _blank загружает содержимое страницы, заданной ссылкой, в новое пустое окно. - _self загружает содержимое страницы, заданной ссылкой, в то же окно, которое содержит ссылку. - _parent загружает содержимое страницы, заданной ссылкой, в окно, являющееся непосредственным владельцем набора фреймов. - _top загружает содержимое страницы, заданной ссылкой, в полное окно, игнорируя используемые фреймы
</item>
        <!--29-->
        <item>29.СТИЛЕВОЕ ОФОРМЛЕНИЕ HTML-ДОКУМЕНТОВ. КАСКАДНЫЕ ТАБЛИЦЫ СТИЛЕЙ (CSS).\n\n\n\n\n
Любой html-документ, сколько бы он элементов не содержал, будет по сути "мертвым" без использования стилей. Стили или лучше сказать каскадные таблицы стилей (Cascading Style Sheets) или попросту CSS определяют представление документа, его внешний вид. Рассмотрим вкратце применение стилей в контексте HTML5.\n
Стиль в CSS представляет правило, которое указывает веб-браузеру, как надо форматировать элемент. Форматирование может включать установку цвета фона элемента, установку цвета и типа шрифта и так далее.\n
Определение стиля состоит из двух частей: селектор, который указывает на элемент, и блок объявления стиля - набор команд, которые устанавливают правила форматирования. Например:\n\n
div{\n
    background-color:red;\n
    width: 100px;\n
    height: 60px;\n
}\n
В данном случае селектором является div. Этот селектор указывает, что этот стиль будет применяться ко всем элементам div.\n
После селектора в фигурных скобках идет блок объявления стиля. Между открывающей и закрывающей фигурными скобками определяются команды, указывающие, как форматировать элемент.\n
Каждая команда состоит из свойства и значения. Так, в следующем выражении:\n\n
background-color:red;\n\n
background-color представляет свойство, а red - значение. Свойство определяет конкретный стиль. Свойств css существует множество. Например, background-color определяет цвет фона. После двоеточия идет значение для этого свойства. Например, выше указанная команда определяет для свойства background-color значение red. Иными словами, для фона элемента устанавливается цвет "red", то есть красный.\n
После каждой команды ставится точка с запятой, которая отделяет данную команду от других.\n
Наборы таких стилей часто называют таблицами стилей или CSS (Cascading Style Sheets или каскадные таблицы стилей). Существуют различные способы определения стилей.\n\n
Атрибут style\n
Первый способ заключается во встраивании стилей непосредственно в элемент с помощью атрибута style:\n\n
&lt;!DOCTYPE html>\n
&lt;html>\n
    &lt;head>\n
        &lt;meta charset="utf-8">\n
        &lt;title>Стили&lt;/title>\n
    &lt;/head>\n
    &lt;body>\n
        &lt;h2 style="color:blue;">Стили&lt;/h2>\n
        &lt;div style="width: 100px; height: 100px; background-color: red;">&lt;/div>\n
    &lt;/body>\n
&lt;/html>\n\n

Здесь определены два элемента - заголовок h2 и блок div. У заголовка определен синий цвет текста с помощью свойства color. У блока div определены свойства ширины (width), высоты (height), а также цвета фона (background-color).\n
Второй способ состоит в использования элемента style в документе html. Этот элемент сообщает браузеру, что данные внутри являются кодом css, а не html:\n\n
&lt;!DOCTYPE html>\n
&lt;html>\n
    &lt;head>\n
        &lt;meta charset="utf-8">\n
        &lt;title>Стили&lt;/title>\n
        &lt;style>\n
        h2{\n
            color:blue;\n
        }\n
        div{\n
            width: 100px;\n
            height: 100px;\n
            background-color: red;\n
        }\n
        &lt;/style>\n
    &lt;/head>\n
    &lt;body>\n
        &lt;h2>Стили&lt;/h2>\n
        &lt;div>&lt;/div>\n
    &lt;/body>\n
&lt;/html>\n\n
Результат в данном случае будет абсолютно тем же, что и в предыдущем случае.\n
Часто элемент style определяется внутри элемента head, однако может также использоваться в других частях HTML-документа. Элемент style содержит наборы стилей. У каждого стиля указывается вначале селектор, после чего в фигурных скобках идет все те же определения свойств css и их значения, что были использованы в предыдущем примере.\n
Второй способ делает код html чище за счет вынесения стилей в элемент style. Но также есть и третий способ, который заключается в вынесении стилей во внешний файл.\n
Создадим в одной папке с html странице текстовый файл, который переименуем в styles.css и определим в нем следующее содержимое:\n\n
h2{\n
    color:blue;\n
}\n
div{\n
    width: 100px;\n
    height: 100px;\n
    background-color: red;\n
}\n
Это те же стили, что были внутри элемента style. И также изменим код html-страницы:\n\n
&lt;!DOCTYPE html>\n
&lt;html>\n
    &lt;head>\n
        &lt;meta charset="utf-8">\n
        &lt;title>Стили&lt;/title>\n
        &lt;link rel="stylesheet" type="text/css" href="styles.css"/>\n
    &lt;/head>\n
    &lt;body>\n
        &lt;h2>Стили&lt;/h2>\n
        &lt;div>&lt;/div>\n
    &lt;/body>\n
&lt;/html>\n\n
Здесь уже нет элемента style, зато есть элемент link, который подключает выше созданный файл styles.css: <link href="styles.css" rel="stylesheet" type="text/css" />\n
Таким образом, определяя стили во внешнем файле, мы делаем код html чище, структура страницы отделяется от ее стилизации. При таком определении стили гораздо легче модифицировать, чем если бы они были определены внутри элементов или в элементе style, и такой способ является предпочтительным в HTML5.\n
Использование стилей во внешних файлах позволяет уменьшить нагрузку на веб-сервер с помощью механизма кэширования. Поскольку веб-браузер может кэшировать css-файл и при последующем обращении к веб-странице извлекать нужный css-файл из кэша.\n
Также возможна ситуация, когда все эти подходы сочетаются, а для одного элемента одни свойства css определены внутри самого элемента, другие свойства css определены внутри элемента style, а третьи находятся во внешнем подключенном файле. Например:\n\n
&lt;!DOCTYPE html>\n
&lt;html>\n
    &lt;head>\n
        &lt;link rel="stylesheet" type="text/css" href="styles.css"/>\n
        &lt;style>\n
            div{\n
                width:200px;\n
            }\n
        &lt;/style>\n
    &lt;/head>\n
    &lt;body>\n
        &lt;div style="width:120px;">&lt;/div>\n
    &lt;/body>\n
&lt;/html>\n\n
А в файле style.css определен следующий стиль:\n\n
div{\n
    width:50px;\n
    height:50px;\n
    background-color:red;\n
}\n\n
В данном случае в трех местах для элемента div определено свойство width, причем с разным значением. Какое значение будет применяться к элементу в итоге? Здесь у нас действует следующая система приоритетов:\n
•	Если у элемента определены встроенные стили (inline-стили), то они имеют высший приоритет, то есть в примере выше итоговой шириной будет 120 пикселей\n
•	Далее в порядке приоритета идут стили, которые определены в элементе style\n
•	Наименее приоритетными стилями являются те, которые определены во внешнем файле.\n\n
Атрибуты html и стили css\n
Многие элементы html позволяют устанавливать стили отображения с помощью атрибутов. Например, у ряда элементов мы можем применять атрибуты width и height для установки ширины и высоты элемента соответственно. Однако подобного подхода следует избегать и вместо встроенных атрибутов следует применять стили CSS. Важно четко понимать, что разметка HTML должна предоставлять только структуру html-документа, а весь его внешний вид, стилизацию должны определять стили CSS.\n\n
Валидация кода CSS\n
В процессе написания стилей CSS могут возникать вопросы, а правильно ли так определять стили, корректны ли они. И в этом случае мы можем воспользоваться валидатором css, который доступен по адресу http://jigsaw.w3.org/css-validator/.
</item>
        <!--30-->
        <item>30.СЕРВЕРНЫЙ ЯЗЫК PHP. СИНТАКСИС. ВКЛЮЧЕНИЕ PHP-СЦЕНАРИЯ В HTML-ДОКУМЕНТ.\n\n\n\n\n
PHP (PHP: Hypertext Preprocessor — «PHP: препроцессор гипертекста»; первоначально Personal Home Page Tools — «Инструменты для создания персональных веб-страниц») — скриптовый язык общего назначения, интенсивно применяемый для разработки веб-приложений. В настоящее время поддерживается подавляющим большинством хостинг-провайдеров и является одним из лидеров среди языков, применяющихся для создания динамических веб-сайтов.\n
Язык и его интерпретатор (Zend Engine) разрабатываются группой энтузиастов в рамках проекта с открытым кодом. Проект распространяется под собственной лицензией, несовместимой с GNU GPL.\n\n
 Область применения\n
В области веб-программирования, в частности серверной части, PHP — один из популярных сценарных языков (наряду с JSP, Perl и языками, используемыми в ASP.NET).\n
Популярность в области построения веб-сайтов определяется наличием большого набора встроенных средств и дополнительных модулей для разработки веб-приложений. Основные из них:\n
•	автоматическое извлечение POST- и GET-параметров, а также переменных окружения веб-сервера в предопределённые массивы;\n
•	взаимодействие с большим количеством различных систем управления базами данных через дополнительные модули (MySQL, MySQLi, SQLite, PostgreSQL, Oracle (OCI8), Oracle, Microsoft SQL Server, Sybase, ODBC, mSQL, IBM DB2, Cloudscape и Apache Derby, Informix, Ovrimos SQL, Lotus Notes, DB++, DBM, dBase, DBX, FrontBase, FilePro, Ingres II, SESAM, Firebird / InterBase, Paradox File Access, MaxDB, Интерфейс PDO), Redis;\n
•	автоматизированная отправка HTTP-заголовков;\n
•	работа с HTTP-авторизацией;\n
•	работа с cookies и сессиями;\n
•	работа с локальными и удалёнными файлами, сокетами;\n
•	обработка файлов, загружаемых на сервер;\n
•	работа с XForms.\n
В настоящее время PHP используется сотнями тысяч разработчиков. Согласно рейтингу корпорации TIOBE, базирующемуся на данных поисковых систем, в мае 2019 года PHP находился на 6 месте среди языков программирования. К крупнейшим сайтам, использующим PHP, относятся Facebook, Wikipedia и др.
Входит в LAMP — распространённый набор программного обеспечения для создания и хостинга веб-сайтов (Linux, Apache, MySQL, PHP).\n\n
Синтаксис\n
Синтаксис PHP подобен синтаксису языка Си. Некоторые элементы, такие как ассоциативные массивы и цикл foreach, заимствованы из Perl.\n
Для написания простейшего скрипта не требуется описывать какие-либо переменные, используемые модули и т. п. Любой скрипт может начинаться непосредственно с оператора PHP.\n
Простейшая программа Hello world на PHP выглядит следующим образом:\n\n
        &lt;?php\n
            echo \'Hello, world!\';\n
            ?>\n
Также возможен более короткий вариант вывода строки:\n
        &lt;?= \'Hello, world!\' ?>\n
Открывающий тег вида &lt;?= используется для сокращённой записи конструкций, используемых для вывода строки.\n
PHP исполняет код, находящийся внутри ограничителей, таких как &lt;?php ?>. Всё, что находится вне ограничителей, выводится без изменений. В основном это используется для вставки PHP-кода в HTML-документ, например, так:\n\n
&lt;html>\n
   &lt;head>\n
      &lt;title>\n
         Тестируем PHP\n
      &lt;/title>\n
   &lt;/head>\n
   &lt;body>\n
      &lt;?php\n
          echo "Привет мир!";\n
          ?>\n
   &lt;/body>\n
&lt;/html>\n\n
Помимо ограничителей &lt;?php ?>, допускается использование сокращённого варианта &lt;? ?>. Кроме того, до версии 7.0 допускалось использование ограничителей языка программирования ASP &lt;% %> и &lt;script language="php"> &lt;/script>. Работа сокращённых конструкций определяется в конфигурационном файле php.ini.\n
Имена переменных начинаются с символа $, тип переменной объявлять не нужно. Имена переменных и констант чувствительны к регистру символов. Имена классов, методов классов и функций к регистру символов не чувствительны. Переменные обрабатываются в строках, заключённых в двойные кавычки, и heredoc-строках (строках, созданных при помощи оператора &lt;&lt;&lt;). Переменные в строках, заключённых в одинарные кавычки, не обрабатываются.\n
PHP рассматривает переход на новую строку как пробел, так же как HTML и другие языки со свободным форматом. Инструкции разделяются с помощью точки с запятой (;), за исключением некоторых случаев, после объявления конструкции if/else и циклов.\n
Переменные в функцию можно передавать как по значению, так и по ссылке (используется знак &amp;).\n
PHP поддерживает три типа комментариев: в стиле языка Си (ограниченные /* */), C++ (начинающиеся с // и идущие до конца строки) и оболочки UNIX (с # до конца строки).\n
</item>
        <!--31-->
        <item>31.ОПЕРАЦИИ ПРАВОГО И ЛЕВОГО ДЕЛЕНИЯ МАТРИЦ.\n\n\n\n\n
В ML имеются две разновидности операции деления матриц: правое (/) и левое (\).\n
Операция левого деления – это «обратное деление»\n
Правое (обычное)деление:\n
>> Z=A./B\n
Z =\n
1 2 3\n
4 5 6\n
Поэлементное обратное деление (.\) – деление 2-го операнда на первый. Для наших матриц:\n
>> Z=B.\A\n
Z =\n
1 2 3\n
4 5 6\n
Используется при решении системы линейных уравнений.\n
В матричной алгебре\n
X= B/A = B*A-1 (решает уравнение X*A=B)\n
X= B\A = B-1 *A\n
X= A\B = A-1 *B (решает уравнение A*X=B)\n
С помощью этой операции решается система линейных уравнений.\n
С векторами и матрицами – иначе. Пусть A – матрица, а Х – вектор. А * Х = В и Х * А = В – разные уравнения.\n
Для решения уравнения Х * А = В используется обычное деление:\n
Х = B / A = В *А-1\n
Для решения уравнения А * Х = В используется обратное деление:\n
Х = А \ В = А-1 * В\n
Операция обратного деления используется для решения системы линейных уравнений. Например:\n
2x1 + 3x2 = 11\n
3x1 – 4x2 = 8\n
A – матрица коэффициентов левой части.\n
B – вектор правых частей.\n
Решается уравнение вида A*X=B:\n
 >> A=[2 3;3 -4];\n
>> B=[11 8 ];\n
>> Х=A\B&quot;\n
Х =\n
4.0000\n
1.0000\n
Для проверки можно выполнить умножение A*X:\n
 >> A*X\n
ans =\n
11.0000\n
8.0000\n
В результате получили вектор правых частей, что доказывает правильность найденного решения.\n
</item>
        <!--32-->
        <item>32.СТАНДАРТНЫЕ ФУНКЦИИ ВЕЩЕСТВЕННОГО АРГУМЕНТА.\n\n\n\n\n
Экспоненциальные функции\n
a^x Степенная функция\n
x^a Показательная функция\n
sqrt(x) Квадратный корень\n
exp(x) Экспонента\n
log(x) Натуральный логарифм\n
log10(x) Десятичный логарифм\n
abs(x) Модуль\n
fix(x) Отбрасывание дробной части числа\n
floor(x) Округлениие до меньшего целого\n
ceil(x) Округлениие до большего целого\n
round(x) Обычное округление\n
rem(x,y) Остаток от деленияx x на y без учёта знака\n
mod(x,y) Остаток от деленияx x на y с учёта знака\n
sign(x) Знак числа\n
factor(x) Разложение числа x на простые множители\n\n

Тригонометрические функции\n
sin(x) Синус\n
sinh(x) Синус гиперболический\n
asin(x) Арксинус\n
asinh(x) Арксинус гиперболический\n
cos(x) Косинус\n
cosh(x) Косинус гиперболический\n
acos(x) Арккосинус\n
acosh(x) Арккосинус гиперболический\n
tan(x) Тангенс\n
tanh(x) Тангенс гиперболический\n
atan(x) Арктангенс\n
atanh(x)0 Арктангенс гиперболический\n
cot(x) Котангенс\n
coth(x) Котангенс гиперболический\n
acot(x) Арккотангенс\n
acoth(x) Арккотангенс гиперболический\n
</item>
        <!--33-->
        <item>33.СИСТЕМНЫЕ ПЕРЕМЕННЫЕ MATLAB.\n\n\n\n\n
Системные переменные MATLAB\n
В системе MATLAB существует особой вид переменных, значение которых, за исключением переменой ans, нельзя изменить. Эти переменные называются системными. Они предназначены для более эффективной работы при вычислениях, а также для вывода системой сообщений при некорректной постановке задачи пользователем. В таблице приведен список системных переменных, используемых в MATLAB.\n\n
Обозначения системных переменных MATLAB\n
Переменная	Значение переменной\n
i, j	мнимая единица ( )\n
pi	число (3.14159265)\n
eps	погрешность для операций над числами с плавающей точкой (по умолчанию -52)\n
realmin	минимальное значение вещественного числа (2-1022)\n
realmax	Максимальное значение вещественного числа (21023)\n
inf	бесконечность ()\n
naN	неопределенность, например, 0/0)\n
ans	переменная, хранящая результат последней операции\n
</item>
        <!--34-->
        <item>34.КОМПЛЕКСНОЕ ЧИСЛО И КОМПЛЕКСНЫЕ ФУНКЦИИ.\n\n\n\n\n
Ко́мпле́ксные чи́сла (от лат. complex — совокупный, тесно связанный) — числа вида a+bi, где a,b — вещественные числа, i — мнимая единица, то есть число, для которого выполняется равенство: i2=-1; Множество комплексных чисел обычно обозначается символом C.  Вещественные числа можно рассматривать как частный случай комплексных, они имеют вид a+0i. Главное свойство C  — в нём выполняется основная теорема алгебры, то есть любой многочлен n-й степени (n≥1) имеет n корней. Доказано, что система комплексных чисел логически непротиворечива.\n
Так же как и для вещественных чисел, для комплексных чисел определены операции сложения, вычитания, умножения и деления. Однако многие свойства комплексных чисел отличаются от свойств вещественных чисел; например, нельзя указать, какое из двух комплексных чисел больше или меньше. Удобно представлять комплексные числа a+bi  точками на комплексной плоскости; например, для изображения сопряжённых чисел используется операция отражения относительно горизонтальной оси. Альтернативное представление комплексного числа в тригонометрической записи оказалось полезным для вычисления степеней и корней. Функции комплексного аргумента изучаются в комплексном анализе.\n
Комплексная функция — основной объект изучения теории функций комплексной переменной, комплекснозначная функция комплексного аргумента: f:C→C.\n\n
Основные функции для работы с комплексными числами приведены в таблице\n
Функция	---Краткое описание\n
z=complex(x,y) ---	Конструирует комплексное число\n
x=real(z) ---	Возвращает вещественную часть комплексного числа z\n
y=imag(z) ---	Возвращает мнимую часть комплексного числа z\n
z1=conj(z)=z’ ---	Возвращает число комплексно-сопряженное число\n
ro=abs(z) --- Возвращает модуль числа z\n
phi=angle(z) ---	Возвращает угол наклона радиус вектора\n
</item>
        <!--35-->
        <item>Уругвай</item>
        <!--36-->
        <item>36.ПРИНЦИПЫ УПРАВЛЕНИЯ ПРОЕКТОМ.\n\n\n\n\n\n
Три фундаментальных принципа проектного управления.\n\n
Первый принцип проектного управления. Принцип яйца.\n
Как ответ на эти два вызова - конечность и неопределенность, родилось проектное управление. Появился принцип яйца. Это, конечно, метафора. Но она отражает то, как менеджеры отреагировали на конечность и неопределенность.\n
 Что символизирует куриное яйцо? Представьте, курица снесла яйцо и садится его высиживать. Яйцо сразу конечного размера, то есть скорлупа уже больше не увеличивается. И скорлупа – это аналог того, что называется «устав проекта». В каждом проекте обязательно есть такая вещь, как устав. В уставе фиксируются неизменные ограничения проекта - стоимость, сроки и кратко его суть (содержание). И сколько бы курица ни сидела, яйцо больше не растёт. Это жесткие рамки, в которые проект должен уложиться, и мы обязаны уложить его в эти рамки любой ценой.\n
Под скорлупой яйца находится внутреннее содержимое. Но пока это только общие планы. Когда курица садится на яйцо, там есть белок и желток - размытые субстанции, а птица еще не угадывается. Так и на старте проекта пишется устав, а подробных планов нет. Они создаются очень примерно. То есть вы должны представить себе общую картину, а уточнять будете позже, чтобы не тратить каждый раз время на переписывание и уточнение. И чем дальше продвигается проект вперёд, чем дольше курица высиживает яйцо, тем явственнее проступают лапки, клювик, глазки и вообще наша будущая птица. Так и с проектом. Сначала планы примерные, а чем дольше он длится, тем больше уточнений вы вносите, и в этом заключается принцип яйца.\n
 То есть на старте есть устав и примерные планы (белок и желток). На протяжении проекта устав неизменен, а планы меняются, расширяются. Это очень важное правило – скорлупу трогать нельзя. Если вы расковыряли пальцем скорлупу яйца, то результат у вас уже не получится, высидеть яйцо будет невозможно. Точно так же и с проектом: если вы устав нарушили, этот проект надо перезапускать. Если яйцо сначала высиживала курица, а потом вы решили, что это должен делать крокодил, то придется брать уже другое яйцо.\n
 Задача менеджера проекта – обеспечить, чтобы внутреннее содержимое не переросло ограничения, чтобы белок и желток не стали больше самого яйца. Если скорлупа лопнет, проект тоже не получится. И PMBoK – это пособие о том, как впихнуть то, что не вмещается, как яйцо удержать в скорлупе.\n
 Попробуйте ответить, можно ли назвать успешным проект, если сроки были превышены в 50 раз, а бюджет – в 40 раз, но продукт получился хорошим? Речь идет, в частности, о продуктах Microsoft – Word и Excel – очень популярных, очень хороших продуктах. Являются ли они успешными проектами?\n
 На самом деле это провальные проекты, но все довольны. И надо эти две вещи разделять и не путаться: это очень хорошие продукты, которыми все довольны, но провальные проекты. Почему это не просто придирки? Если бы это была не Microsoft, а совершенно другая компания, то:\n
•	проект никогда бы не завершился,\n
•	компания разорилась бы.\n
 По сути, эти проекты не обладали конечностью. Руководству на самом деле было все равно, сколько денег уйдет на проекты и когда они выйдут. Главное – чтобы продукты вышли и покорили рынок.\n
 И таких компаний немало, тот же Яндекс или Google. Они не очень переживают, сколько будет стоить их новый сервис или обновление. Их не очень интересуют сроки. Для них важно, чтобы получился очень хороший продукт.\n
 Когда у вас такая ситуация – скрам работает прекрасно, ничего лучше не бывает. Если у вас бесконечное число денег и времени, и вам просто нужен хороший продукт, то ничего лучше, чем спокойненько делать и все время показывать клиенту промежуточные результаты, никто не придумал. Но если вы работаете в боевых рыночных условиях, если у вас бюджет ограничен, и хороший продукт – не единственное, что вас волнует, то для этого есть проектное управление.\n\n
Второй принцип. Принцип удава.\n
 Любой проект имеет жизненный цикл. Он начинается с инициации (этап определения границ и формального запуска проекта) и заканчивается закрытием (этап формального завершения работ), а в середине у него клубок процессов. Абсолютно у каждого проекта, даже если вы его не закончили, провалили, есть начало, конец и середина: инициация, закрытие и клубок процессов. Если на этот цикл натянуть смешной контур, то получится удав. Такой сытый удав, который что-то переваривает.\n\n
Третий принцип. Принцип командности и проактивности.\n
Как вы считаете, должен ли быть менеджер проекта экспертом в том, в чем у него проект, должен ли он разбираться в этом?\n
С одной стороны, должен, иначе его просто обманут. Но с другой, менеджеру проекта не просто быть экспертом, потому что непонятно, где именно должна находиться зона его экспертизы. Вот конкретный пример. Представьте себе проект по разработке томографа. Давайте попробуем разобраться, какими должны быть компетенции менеджера этого проекта. Томограф - сложный прибор со сложным софтом, над ним трудится инженер-электронщик, с одной стороны, программист – с  другой. Проектирование с последующей сборкой - примерно столь же трудоемкая задача, как и написание для томографа программного обеспечения. При этом томограф делается для врачей, поэтому необходимо участие врача, для уточнения, что имеет диагностическую ценность, а что - нет. А еще томограф – прибор, который проходит строгую сертификацию, потому что при неправильном применении он может человека убить. И процедура его сертификации длительная и сложная, требует участия отдельных компетентных специалистов. И в какой из упомянутых сфер должен быть экспертом менеджер проекта? Понятно, что он не может быть одновременно и электронщиком, и программистом, и врачом, и специалистом по сертификации.\n
 Это универсальная ситуация: проекты – всегда задачи с конечностью и неопределенностью, когда стыкуются разные сферы и нужны разные специалисты. Поэтому менеджеру проекта не обязательно быть экспертом, потому что непонятно, в какой это должно быть области.\n
 Другая ситуация, когда мы смотрим на работу какого-либо отдела. Обычно начальники отделов – это бывшие эксперты. Сначала он был простым инженером, потом дорос до начальника отдела инженеров. Он самый умный инженер, поэтому его назначили всеми руководить. Начальники отделов, конечно, не всегда вырастают из рядовых сотрудников, но чаще всего ситуация именно такая. Но здесь вряд ли речь пойдет именно об управлении проектами. Если у вас вдруг проект внутри отдела, и в него вовлечены только сотрудники отдела, это наверняка не проект. Это просто задачи в рамках вашей операционной деятельности. Проект предполагает конечность и неопределенность. А откуда возьмется неопределенность, если ваши люди делают дело, которое и вы, и они хорошо знают? Проекты, как правило, предполагают кросс-функциональность. Это верно даже для тех IT-проектов, в которых команды маленькие. Все равно в них есть программисты, тестировщики, аналитики, дизайнеры, люди других профессий. Во всех этих сферах нельзя быть экспертом, поэтому менеджер не может быть экспертом во всем. Конечно, грамотность нужна, понимание предмета проекта, например, в нашем последнем примере знать что-то про томограф обязательно. Иначе команда вас не примет как руководителя. Но быть экспертом во всем невозможно.\n
 И отсюда берется принцип командности. Очень простая логика: проектное управление не предполагает, что вы, как руководитель, можете взять и сделать проект самостоятельно. Понадобятся знания большого количества экспертов в разных доменах, которые вам нужно объединить. Вы – интегратор в первую очередь. Принцип командности говорит о том, что вся команда участвует в формировании планов. Планы пишутся всей командой – вами и вашими сотрудниками. Один вы не сможете учесть все нюансы, хотя соблазн самому построить план проекта всегда велик.\n
 Проактивность – это антоним реактивности. Что такое реактивность? Когда что-то загорелось, побежали – потушили. А проактивность – это мы сидим и думаем, как бы так сделать, чтобы не загорелось никогда, а если загорится, чтобы мы быстро справились. Фактически, проактивность - это управление рисками. Превентивное.\n
 А управление проектом – это, во-первых, умение увлекать команду формированием планов и управление этими планами. А во-вторых, проактивность – вы должны думать про риски, управлять ими, всячески их оценивать.\n
</item>
        <!--37-->
        <item>37.ОРГАНИЗАЦИОННАЯ СТРУКТУРА ПРОЕКТА.\n\n\n\n\n
Организационная структура проекта – это временная организационная структура, созданная для повышения качества управления и взаимодействия в проекте путем определения и визуализации процессов взаимодействия как между внутренними, так и с внешними участниками проекта.\n\n
Команда проекта\n
Проект — явление временное, и это определяет специфику управления его участниками. На время реализации проекта создается так называемая команда проекта, которая имеет определенную организационную структуру. Несмотря на все многообразие существующих проектов, в команде можно выделить ряд более или менее стандартных ролей.\n
В первую очередь, это менеджер (руководитель) проекта — физическое лицо, несущее личную ответственность за успех проекта и осуществляющее оперативное руководство.\n
Как правило, в компаниях назначают куратора проекта — представителя высшего руководства, который хоть и не вникает в тонкости текущего положения дел в проекте, но контролирует его ход, следит, чтобы проект соответствовал стратегическим целям компании, а если у менеджера проекта не хватает полномочий, — помогает ему своим авторитетом.\n
Проектный комитет создается в компаниях, в которых бизнес построен по проектному типу. Это орган, задачи которого — отбирать проекты и контролировать их выполнение на высшем уровне, принимать ключевые решения.\n
В технически сложных проектах важна роль главного инженера проекта (ГИП), который порой по статусу равен менеджеру проекта.\n
В крупных проектах могут выделяться менеджеры по различным функциональным областям, например по управлению финансами, персоналом, рисками и т. п.\n
Все вышеперечисленные роли образуют команду управления проектом, которая входит в команду проекта. Также участниками команды проекта являются исполнители как из числа штатных сотрудников компании, так и нанятые специально для реализации конкретного проекта. Иногда в нее включают подрядчиков и субподрядчиков.\n
Отдельно стоит выделить проектный офис. В простейшем случае это своего рода секретариат, в котором хранится вся документация по проекту. Он может состоять как из одного, так и из нескольких сотрудников. В более продвинутых компаниях проектный офис также играет роль методологического центра, обслуживающего все проекты организации. Ниже представлен пример типичной команды проекта.\n\n
\t\t\t\t\t\t\tВысшее руководство компании\n
\t\t\t\t\t\t\t\t\t\t\t\t|\n
\t\t\t\t\t\t\tПроектный комитет\n
\t\t\t\t\t\t\t\t\t\t\t\t|\n
\t\t\t\t\t\t\tКуратор проекта\n
\t\t\t\t\t\t\t\t\t\t\t\t|\n
\t\t\t\t\t\t\tМенеджер проекта\n
\t\t\t\t\t\t\t\t\t\t\t\t|\n
Рук-ль отдела | ГИП | Админ проекта\n
\t\t\t\t\t\t\t\t\t\t\t\t|\n
Исполнители | Подрядчики | Субподрядчики\n\n

Проект и компания\n
Ни один проект не существует в вакууме. Как правило, он реализуется в интересах некоторой компании, которая его и инициирует. Такая компания называется родительской, головной или материнской. Соответственно, у компании есть определенная организационная структура, и проект каким-то образом «встраивается» в нее.\n
Самой распространенной структурой на сегодняшний день является функциональная структура, представляющая собой иерархию, в которой для каждого служащего четко определен один вышестоящий руководитель. При этом сотрудники сгруппированы по специальностям: маркетинг, производство, закупки и т.п. Такая структура оптимальна для хорошо налаженного циклического производства, однако вызывает ряд трудностей при выполнении проектов.\n
На определенном этапе в организации возникают проекты и назначается их координатор. Он отвечает за выполнение проекта, достижение целей, соблюдение сроков и выделенного бюджета. Фактически же такой сотрудник не имеет достаточно полномочий для решения поставленных задач. Отвечать «за все» и не иметь полномочий – главная проблема для эффективного управления проектами. Также, одним из основных недостатков при реализации проектов является неповоротливость структуры, так как все распоряжения любой сотрудник может получать только от своего функционального руководителя, что вызывает длительные задержки при принятии решений. Также проблемы могут возникать из-за того, что интересы проекта вступают в противоречие с интересами функциональных руководителей.\n
Такая структура весьма статична и эффективна только для реализации локальных проектов в рамках подразделения.\n\n
ФУНКЦИОНАЛЬНАЯ ОРГСТРУКТУРА\n
\t\t\t\t\tРуководство компании\n
\t\t\t\t\t\t\t\t\t\t\t|\n
Рук-ль подр_1 Рук-ль подр_2 Рук-ль подр_3\n
\t\t\t\t\t|\t\t\t\t\t\t\t\t\t|\t\t\t\t\t\t\t\t\t\t|\n
СОТРУДНИК_1  \tсотрудник_1  \t\t\tСОТРУДНИК_1\n
сотрудник_2 \t\t\tСОТРУДНИК_2  \tсотрудник_2\n
сотрудник_3 \t\t\tсотрудник_3  \t\t\tСОТРУДНИК_3\n\n

Примечание: Большими буквами выделены сотрудники, участвующие в проекте.\n\n
Проектная структура полностью противоположна матричной по своей организации. Здесь проектные команды как бы образуют свои собственные временные подразделения, созданные на время выполнения проекта и возглавляемые руководителями проектов. При такой организации функциональные подразделения выполняют сервисную функцию по отношению к проектам, т. е. оказывают им услуги, например техническую поддержку или бухгалтерское обслуживание. Также функциональные отделы играют роль пула ресурсов (например, специалистов), динамически перераспределяемых между проектами. В проектной структуре члены команды ориентированы только на достижение целей проекта и подчиняются только его руководителю.\n
При такой организации проект фактически представляет собой филиал компании, при этом «законы», по которым действует сотрудник в рамках проекта, полностью определяются руководством проекта. Такая структура эффективна в крупных, значимых для компании проектах, как правило, продолжительностью более двух лет.\n\n
ПРОЕКТНАЯ ОРГСТРУКТУРА\n
\t\t\t\t\t\t\t\tРуководство компании\n
\t\t\t\t\t\t\t\t\t\t\t\t|\n
Рук-во проекта_1 Рук-во проекта_2 Др. отделы\n
\t\t\t\t\t|\n
СОТРУДНИК_1\n
СОТРУДНИК_2\n
СОТРУДНИК_3\n
Примечание: Большими буквами сотрудники, участвующие в проекте.\n

Основной недостаток проектной структуры состоит в том, что ресурсы не всегда используются эффективно (например, услугами юриста вы пользуетесь всего несколько часов в неделю, и их невыгодно оплачивать полностью из бюджета проекта).\n
Эту проблему позволяет решить матричная структура, которая представляет собой компромисс между функциональной и проектной структурами. Здесь сотрудник подчиняется с одной стороны руководителю проекта, а с другой — своему функциональному руководителю. В зависимости от того, у кого из них больше власти, различают слабую (незначительная власть руководителя проекта) и сильную, или жесткую (менеджер проекта выше функционального руководителя) матрицы. Идеальной представляется сбалансированная матрица, при которой менеджер проекта ответственен за его результаты, а функциональный руководитель — за качество работы своих сотрудников, «командированных» в проект. Основной минус матричной структуры — двойное подчинение сотрудников.\n\n
МАТРИЧНАЯ ОРГСТРУКТУРА\n
\t\t\t\t\t\t\t\tРуководство компании\n
\t\t\t\t\t\t\t\t\t\t\t\t|\n
Рук-во проекта Рук-во отдела_1 Рук-во отдела_2\n
\t\t\t\t\t|\n
Менеджер_1 \tСотрудник_1 \t\tСотрудник_1\n
МЕНЕДЖЕР_2 СОТРУДНИК_2 СОТРУДНИК_2\n
Менеджер_3 \tСотрудник_3 \t\tСотрудник_3\n
Примечание: Большими буквами сотрудники, участвующие в проекте.\n
В компании могут одновременно сосуществовать различные оргструктуры. Наибольшее применение получила слабая матрица, т. к. традиционно велика роль функциональных руководителей.\n\n
Выбор организационной структуры проекта\n
Каждый тип структуры имеет свои плюсы и минусы. Матричная структура является компромиссной, ее разновидности можно наиболее часто встретить в компаниях, бизнес которых связан с ведением проектов. Зачастую в одной компании можно встретить несколько структур в зависимости от масштаба и других особенностей конкретного проекта. Однако можно дать ряд рекомендаций по выбору организационной структуры.\n\n
Крит. выбора:	Функц-ая	Матричная	Проектная\n
Уров. неопр-сти:	Низкий	Средний	Высокий\n
Технология:	Типовая	Сложная	Инновационная\n
Комплексность:	Низкая	Средняя	Высокая\n
Продолжительность:	Малая	Средняя	Большая\n
Знач. для компании:	Малое	Среднее	Ключевое\n
Уровень взаимосвязей между частями проекта:	Низкий	Средний	Высокий\n
Важность фактора времени (наличие критических сроков):	Низкая	Средняя	Высокая\n
Зависимость от вышестоящей организации:	Высокая	Средняя	Низкая\n
</item>
        <!--38-->
        <item>38.ОСНОВНЫЕ ЭЛЕМЕНТЫ ПЛАНА ПРОЕКТА.\n\n\n\n\n\n
Управление проектами заключается в составлении плана и отслеживании хода работ по нему. Соответственно, чем лучше план проекта, чем более аккуратно он составлен, тем легче потом выполнять проектные работы и удачно завершить проект.\n
Чтобы хорошо планировать, нужно, в первую очередь, хорошо представлять себе, что такое проект и из каких элементов состоит его план.\n\n
Что такое проект?\n
Деятельность любой организации заключается в выполнении операций и проектов. Те и другие имеют много общего, например, выполняются людьми, для чего выделяются ограниченные ресурсы.\n
Главное отличие операций от проектов заключается в том, что операции выполняются постоянно и повторяются, тогда как проекты временны и уникальны. Исходя из этого, проект определяется как временное усилие, предпринятое для создания уникального продукта или услуги. “Временное” обозначает, что каждый проект имеет точно определенные даты начала и окончания. Говоря об уникальности продукта или услуги, мы подразумеваем, что они имеют заметные отличия от аналогичных продуктов или услуг.\n
Уникальность каждого проекта порождает сложности при его планировании, поскольку зачастую трудно предположить, как в действительности будут достигаться результаты. Поэтому результатом проектной деятельности является не только продукт или услуга, но и извлеченные уроки, то есть опыт, который используется в дальнейшем при планировании и выполнении следующих проектов.\n
Проекты применяются на любых уровнях организации, в них могут быть вовлечены как несколько человек, так и несколько тысяч. Проекты могут быть разной длительности: некоторые продолжаются менее ста часов, другие – -более миллиона. Проект может вовлекать один отдел организации, а может и выходить за ее пределы, как в случаях совместных предприятий и партнерства.\n
Проекты могут осуществляться в любой области деятельности. Так, проектами могут быть и проектирование транспортного средства, и разработка информационной системы, и проведение предвыборной кампании, и постройка здания, и подготовка номера журнала.\n\n
Проект как временное явление\n
У каждого проекта есть четко определенные начало и окончание. Проект заканчивается вместе с достижением всех его целей или наоборот, когда становится ясно, что эти цели не могут быть достигнуты. Временность не означает краткосрочность проекта -многие проекты могут продолжаться несколько лет. В любом случае, проект конечен и не может состоять из постоянно продолжающихся действий.\n
Очень многие предприятия временны в том смысле, что в какой-то момент работа на них остановится. Например, понятно, что конвейер по производству определенной модели автомобилей когда-то остановится, так как машина будет снята с производства. Однако такой род временности не делает конвейер проектом, поскольку работа по сборке машин является типичной рутинной операционной деятельностью. Фундаментальное отличие проекта заключается в том, что проект заканчивается, когда поставленные цели достигнуты, тогда как при непроектной деятельности перед исполнителями ставятся новые цели и работа продолжается.\n
Временная природа проектов сказывается и на других аспектах проектной деятельности. Например, проекты обычно имеют четко очерченные временные рамки для создания продукта или услуги, поскольку благоприятная для них ситуация на рынке складывается на ограниченное время. Кроме того, проектная команда, как правило, по его окончании распадается, а ее члены переходят в другие проекты.\n
В отличие от конвейера по сборке автомобилей хорошим примером проекта может быть разработка нового автомобиля. Разработка осуществляется в ограниченные сроки и продолжается до достижения определенного результата -прототипа нового автомобиля. Когда результат достигнут, автомобиль отправляется в производство, а проектная команда -конструкторы, дизайнеры, инженеры и пр. -могут быть вовлечены в новый проект, хотя и не обязательно в том же составе.\n
Проект очень часто путают с программой, то есть координированным управлением группой проектов внутри одной организации. Управление сразу несколькими проектами координируется для того, чтобы получить выгоду, которую нельзя получить от отдельного управления каждым из них. Программы обычно сочетают элементы проектов и операций. Например, разработка веб-сайта явля ется проектом, тогда как поддержка его в течение длительного времени – -это операционная деятельность.\n
К операционной деятельности организации можно применить проектный подход. Если в организации принят такой подход, то выполняемые в ней текущие операции, такие как поддержка веб-сайта в течение определенного периода времени, определяются как отдельный проект. Управление проектами в последние годы охватывает все большее число операций в организациях, то есть все большее число организаций переходит на “управление через проекты”. Управление через проекты (managing by projects), то есть применение методик проектного управления к операционной деятельности, надо отличать от управления проектами (project management).\n
Программы могут также включать повторяющиеся, или циклические, работы, например, периодическое издание журнала само по себе является непрерывным процессом, тогда как подготовка отдельного номера -это проект.\n\n
Составляющие проектного плана\n
Проект позволяет достичь определенного результата в определенные сроки и за определенные деньги. План проекта составляется для того, чтобы определить, с помощью каких работ будет достигаться результат проекта, какие люди и оборудование нужны для исполнения этих работ, в какое время эти люди и оборудование будут заняты работой по проекту. Поэтому проектный план содержит три основных элемента: задачи (task), ресурсы (resource) и назначения (assignment). Рассмотрим подробнее каждый из них.\n\n
Задачи\n
Задачей называется работа, осуществляемая в рамках проекта для достижения определенного результата. Например, в проекте издания номера журнала задачей является “проведение редколлегии”. Поскольку обычно проект содержит много задач, то для удобства отслеживания плана их объединяют в группы, или фазы. Совокупность фаз проекта называется его жизненным циклом.\n\n
Фазы\n
Фаза проекта состоит из одной или нескольких задач, в результате выполнения которых достигается один или несколько основных результатов проекта. Таким образом, результаты, достигнутые благодаря выполнению каждой из задач, входящих в фазу, формируют ее результат.\n
Если для достижения результатов задачи достаточно выполнить только ее, то для достижения результата фазы нужно выполнить группу других задач. И в этом заключается отличие фазы от задачи: ее результат суммирует результаты других задач. Именно поэтому в MS Project фазы называют суммарными задачами (summary task).\n
Например, результатом фазы “подготовка материалов” будут материалы номера журнала, которые можно передать на предпечатную подготовку. Поскольку номер состоит из обложки и статей, то для получения результата фазы нужно решить как минимум две задачи: “подготовка обложки”, результатом которой будет обложка журнала с фотографией фотомодели и заголовками статей, и “подготовка статей”, результатом которой будут все тексты статей журнала.\n
При планировании работ нужно помнить, что чем детальнее составлен план проекта, тем он точнее (а значит, лучше). Поэтому в тех случаях, когда это возможно, стоит разбивать большие задачи на подзадачи (то есть превращать задачи в фазы). Формальными критериями, показывающими, что задачу можно разбить на подзадачи, являются длительность (задачи редко бывают дольше 2-3 дней) и большое число задействованных исполнителей (как правило, если над решением задачи трудятся больше 2-3 человек, то каждый решает свою собственную задачу, которую можно отдельно учесть в плане проекта).\n
Фазы могут состоять как из задач, так и из других фаз. Например, “подготовка обложки” тоже является фазой, поскольку может быть разделена на три задачи: “отбор модели”, результатом которой будет фамилия модели для фотосъемки, “фотосъемка модели”, заканчивающаяся получением фотографии отобранной модели, и “верстка обложки”. По завершении последней задачи сделанная фотография будет размещена на обложке, и обложка будет подготовлена к публикации.\n
Проект разбивается на фазы и для удобства отслеживания хода работ. По завершении проектной фазы обычно осуществляется анализ как полученных результатов, чтобы с минимальными затратами определить и исправить ошибки, так и общего хода исполнения проекта, чтобы определить, стоит ли переходить к его следующей фазе.\n
В большинстве жизненных циклов фазы выполняются последовательно. При этом часто следующая фаза начинается лишь после того, как будут одобрены результаты предыдущей. Однако в некоторых жизненных циклах последующая фаза начинается раньше одобрения результатов предыдущей фазы, если такой риск считается приемлемым. “Пересечение” фаз при планировании называется быстрым путем (fast tracking).\n
Разбиение проекта на фазы позволяет представить его в виде списка основных результатов и дат, к которым эти результаты должны быть получены. Руководитель проекта осуществляет непосредственный контроль исполнения каждой задачи внутри проекта, сообщая вышестоящему менеджеру только о достижении фазовых результатов. Этому менеджеру, в свою очередь, для контроля исполнения проекта вполне достаточно таких данных.\n\n
Вехи\n
Каждый проект ориентирован на достижение определенной цели, и обычно достичь ее нельзя, не достигнув нескольких промежуточных целей. Например, нельзя построить дом, не заложив фундамент. Закладка фундамента является промежуточной целью при постройке дома.\n
Задачи, в результате исполнения которых достигаются промежуточные цели, называются завершающими задачами, или, в терминах MS Project, вехами (milestones). Обычно результатом фазы является достижение промежуточной цели, поэтому вехой в плане проекта принято обозначать последнюю задачу фазы, в результате которой достигается ее результат.\n
Иногда, если такой задачи нет, а фазовый результат достигается, например одновременным завершением нескольких задач, то создается фиктивная завершающая задача. Длительность такой задачи устанавливаетсяв0днейинанее не выделяются исполнители. Она присутствует в плане исключительно для обозначения момента завершения фазы, что облегчает мониторинг плана проекта.\n\n
Длительность и трудозатраты\n
Длительность задачи  –  это период рабочего времени, который необходим для того, чтобы выполнить ее. Например, задача “Сбор предложений от авторов” в проекте издания журнала может занимать неделю.\n
Длительность может не соответствовать трудозатратам занимающегося задачей сотрудника. Например, для выполнения задачи “Сбор предложений от авторов” сотруднику (ответственному секретарю журнала) нужно потратить полчаса на рассылку типового электронного письма авторам и полчаса на обработку поступивших в течение недели ответов. Значит, его трудозатраты на выполнение задачи составят один час. Таким образом, длительность (duration) соответствует времени, через которое будет получен результат задачи, а трудозатраты (work) -времени, затраченному сотрудниками на получение результата.\n\n
Зависимости и связи\n
Задачи в плане проекта взаимосвязаны, например, часто одна задача не может начаться, пока не закончена другая (возведение стен не может начаться раньше закладки фундамента). В плане проекта зависимости (dependencies) обозначаются с помощью связей (links), и оба эти термина -зависимость и связь -имеют один и тот же смысл, обозначая логику, определяющую последовательность работ в плане проекта.\n\n
Роли и ресурсы\n
Под ресурсами в MS Project понимаются сотрудники и оборудование, необходимые для выполнения проектных задач. Например, для выполнения задачи “Сбор предложений от авторов” в проекте должен быть задействован ответственный секретарь журнала.\n
Каждый сотрудник, участвующий в проекте, получает определенную роль всоответствии со своей квалификацией, требованиями проекта и регламентами, действующими в организации. Например, в одном проекте сотрудник может выступать в роли архитектора приложений, а в другом, где остро требуется программист, тот же сотрудник может быть занят в роли программиста.\n
При составлении списка ресурсов часто используется ролевое планирование. Например, сначала определяется, что для исполнения работ требуются три программиста и один менеджер, а затем, когда план проекта утвержден, подбираются конкретные сотрудники для этих ролей.\n\n
Стоимость ресурсов\n
Важное свойство ресурсов – -стоимость их использования в проекте, то есть затраты (cost). В MS Project есть два типа стоимости ресурсов: повременная ставка и стоимость за использование. Повременная ставка (rate) выражается в стоимости использования ресурса в единицу времени, например, 100 рублей в час или 1000 рублей в день. В таком случае стоимость участия ресурса в проекте составит время, которое он работает в проекте, умноженное на почасовую ставку. Обычно почасовая ставка служит для учета стоимости нематериальных ресурсов.\n
В области управления проектами термины “стоимость” и “затраты” равнозначны. В книге оба термина также применяются на равных правах.\n
Величина затрат на использование (cost per use) обозначает стоимость использования оборудования или сотрудника в задаче. Эта величина не зависит от того, сколько времени задействован в задаче сотрудник или материальный ресурс. Общие затраты на использование ресурса определяются путем умножения стоимости использования ресурса в задаче на число задач, в которых он задействован.\n
У ресурса может быть указана стоимость как одного из двух типов, так и обоих. При определении общих затрат на использование ресурса в проекте MS Project определяет повременные затраты и затраты на использование и суммирует их.\n\n
Назначения\n
Назначение -это связь определенной задачи и ресурсов, необходимых для ее выполнения. При этом на одну задачу могут быть назначены несколько ресурсов, причем как материальных, так и нематериальных. Назначения объединяют в плане ресурсы и задачи, делая план целостным. Благодаря назначениям решается целый ряд задач планирования. Во-первых, определяются ответственные за исполнение задач. Во-вторых, когда определены задачи, за которые отвечает ресурс, можно рассчитать общий объем времени, затрачиваемый им на проект, а значит, его стоимость для проекта. В-третьих, определив стоимость участия всех ресурсов в проекте, можно подсчитать его общую стоимость. Наконец, назначая ресурсы на задачи, можно сократить срок выполнения работ, выделяя на них больше ресурсов и тем самым сокращая общую длительность проекта.\n\n
Проектный треугольник\n
Как мы уже знаем, большинство проектов имеют определенные дату окончания, бюджет и объем работ. Это трио времени, денег и объема работ часто называют проектным треугольником, потому что при внесении изменений в один из этих элементов меняются оба других. И хотя для проекта в равной степени важны все три элемента, как правило, только один из них в зависимости от приоритетов имеет наибольшее влияние на другие.\n
Например, если вы решите изменить план проекта, укоротив расписание, то возрастет стоимость проекта (если вы решите привлечь дополнительных работников) или уменьшится объем работ. Если же изменить план проекта с целью уменьшения его бюджета, то может возрасти длительность проекта и уменьшиться объем работ. Наконец, если вы увеличите объем работ, то проект будет длиться дольше и стоить дороже.\n
То, как изменения в плане влияют на другие стороны треугольника, зависит от обстоятельств и специфики проекта. В некоторых случаях сокращение времени увеличивает стоимость, а в других – -уменьшает.\n
При создании плана вы можете столкнуться с тем, что план не удовлетворяет ожиданиям, например, проект заканчивается слишком поздно или его стоимость превышает допустимые пределы. В таком случае план нужно оптимизировать, чтобы привести его в соответствие с ожиданиями.
Когда вы начинаете оптимизировать план, постоянно помните обо всех элементах треугольника и о том, что, когда вы изменяете одну из сторон, это затрагивает две другие -позитивно или негативно в зависимости от вашего проекта. И проверяйте два других элемента треугольника, чтобы быть уверенным, что изменения не делают план невыполнимым. Например, если вы изменили свой план с целью уменьшить расходы, проверьте, что дата окончания проекта все еще находится в допустимых пределах.\n
Качество, четвертый элемент проектного треугольника, находится в его центре, и изменения, вносимые в любую из сторон треугольника, практически всегда влияют на качество. Качество не является стороной треугольника -это результат ваших действий со временем, стоимостью и объемом работ.\n
Например, если вы нашли лишнее время в расписании, то можете увеличить объем работ, добавив задачи и увеличив длительность проекта. С этими дополнительными задачами и временем вы сможете добиться более высокого качества в проекте и произведенном продукте или услуге.\n
Если же вы хотите снизить расходы, чтобы уложиться в бюджет, возможно, вам понадобится уменьшить объем работ, убрав некоторые из задач или уменьшив их длительность. С уменьшенным объемом работ у проекта будет меньше шансов выйти на требуемый уровень качества, поэтому снижение расходов может привести к снижению качества проекта.\n
</item>
        <!--39-->
        <item>39.МЕТОДЫ РЕСУРСНОГО ВЫРАВНИВАНИЯ.\n\n\n\n\n
Выравнивание ресурсов – это процесс реорганизации плана проекта с целью ликвидации перегруженности его ресурсов.\n\n
Для выравнивания применяются следующие основные приемы.\n
1. Уменьшение объема назначения ресурса на некоторую задачу. Это может привести к увеличению ее длительности пропорционально ежедневному уменьшению трудозатрат. Например, если при работе по 8ч в день (объем назначения 100%) работник выполняет задачу за 5 дней, то при уменьшении объема назначения до 4ч в день (50%) ему понадобится 10 дней для этой же задачи.\n
2. Реорганизация сетевого графика работ. В результате параллельные задачи, на которые назначен перегруженный ресурс, становятся последовательными и перегруженность преодолевается. Это может привести к удлинению проекта в целом, особенно если реорганизуемые задачи расположены на критическом пути;\n
3. Замена перегруженного ресурса другим свободным ресурсом или несколькими свободными. Это может привести к снижению качества работ. При первоначальном планировании менеджер обычно назначает задачам самых опытных и квалифицированных сотрудников. Замена их другими приведет к преодолению перегрузки за счет использования менее квалифицированного персонала. В результате повышаются риски снижения качества и увеличения длительности задачи.\n
4. Вставить перерывы в задачах или назначениях для ликвидации их пересечений. Наличие перерыва позволяет высвободить один или все ресурсы задачи, которые перестают быть перегруженными. Результат – увеличение длительности задачи. Если же она является критической, это приводит к увеличению длительности всего проекта.\n
5. Учесть сверхнормативные трудозатраты ресурсов как сверхурочные. Сверхурочные трудозатраты назначаются сотрудникам в разумных пределах (не более 2 – 3 часов в сутки). При этом следует учитывать фактор усталости, который снижает эффективность труда. Задача, использующая сверхурочные трудозатраты, может потерять в качестве и имеет риск увеличения фактической длительности.\n\n
Любой из перечисленных методов может привести к ухудшению показателей проекта – либо к увеличению длительности, либо к повышению стоимости, либо и к тому и к другому. Поэтому не существует никаких общих рекомендаций по выравниванию, которое в каждом конкретном случае выполняется в зависимости от индивидуальных особенностей проекта и ресурсов, а качество выравнивания существенно зависит от опыта менеджера проекта.\n\n
В системе имеется два способа выравнивания: автоматический и вручную.\n
При автоматическом выравнивании Microsoft Project сам пытается избавиться от перегрузки перемещением задач на другие сроки или вставкой перерывов между задачами, оперируя резервами времени некритических задач.\n\n
При ручном выравнивании загрузки ресурсов используются следующие типовые приемы:\n
1. изменение объемов назначений;\n
2. замена одного ресурса другим;\n
3. редактирование распределения трудозатрат;\n
4. прерывание задачи;\n
5. перенос трудозатрат в сверхурочные.\n
</item>
        <!--40-->
        <item>40.ПРИНЦИПЫ КОЛИЧЕСТВЕННОГО УПРАВЛЕНИЯ.\n\n\n\n\n
«Тем, что нельзя измерить, нельзя управлять». Измерения по проекту необходимо выполнять регулярно, не реже одного раза в 1-2 недели. Для каждого измеримого показателя должны быть определены его плановые значения. Для каждого планового значения должны быть определены три области критичности отклонений:\n
· Допустимые отклонения. Предполагается, что никаких управляющих воздействий не требуется.\n
· Критичные отклонения. Требуется тщательный анализ причин отклонения и при необходимости применение корректирующих действий.\n
· Недопустимые отклонения. Требуется срочный анализ причин отклонения и обязательное применение корректирующих действий.\n
Измерения необходимо производить регулярно. Цель — выявить причины наступивших или возможных критичных и недопустимых отклонений. Результатом анализа должны стать планирование корректирующих действий по компенсации недопустимых отклонений, их реализация и мониторинг результативности применения этих корректирующих действий.\n
Все измерения необходимо сохранять в репозитарии проекта. Измерения, накопленные в ходе проекте, являются наиболее достоверной основой при детальной оценке и планировании работ на следующих итерациях проекта.\n
Поскольку главная задача менеджера удержать проект в пределах «железного» треугольника, то, в первую очередь, необходимо анализировать отклонения проекта по срокам и затратам. Делается это при помощи метода освоенного объема. Приходилось сталкиваться с мнением, что этот метод не применим в управлении программными проектами. Это действительно так, если мы используем «водопадную» модель процесса разработки. Но если ИСР проекта, ориентирована на инкрементальную разработку, то это означает, что на верхних уровнях декомпозиции находятся компоненты проектного продукта и их функционал, а не производственные процессы. Следовательно, если в проекте реализованы, протестированы и документированы 50 % функциональных требований, то есть все основания полагать, что осталась приблизительно половина проектных работ.\n
Суть метода оценки проекта по освоенному объему заключается в следующем. Сначала оценивается отклонение от графика SV (Shedule Variance) в денежных единицах:\n\n
SV = EV - PV, где\n
· EV (Earned Value) — освоенный объем. Плановая стоимость выполненных работ. Объем выполненных работ, выраженный в терминах одобренного бюджета, выделенного на эти работы для плановой операции и элемента иерархической структуры работ;\n
· PV (Planned Value) — плановый объем. Плановая стоимость запланированных работ. Утвержденный бюджет, выделенный на плановые работы, выполняемые в рамках плановой операции или элемента иерархической структуры работ.\n
Например. Пусть мы на текущий момент реализовали (протестировали и документировали) 20 функциональных требований, на каждое из которых было запланировано затратить по 40 чел.*час. по 1000 сом, то освоенный объем будет\n
EV = 20 * 40 * 1000 = 800 000 сом.\n
Если же на текущий момент планировалось реализовать только 15 требований, то плановый объем будет\n
PV = 15 * 40 * 1000 = 600 000 сом.\n
Следовательно, мы опережаем график (отклонение от графика положительное) на величину\n
SV = EV - PV = 800 000- 600 000 = 200 000 сом.\n
Если мы опережаем график, то это не обязательно означает что проект идет успешно. Хорошо это или плохо зависит от значения другого показателя метода освоенного объема: CV (Cost Variance) — отклонения по затратам, которое оценивается по формуле:\n\n
CV = EV – AC, где\n
· AC (Actual Cost) — фактические затраты. Фактическая стоимость выполненных работ. Фактические затраты на выполнение работ за определенный период в рамках плановой операции или элемента иерархической структуры работ.\n
Например, если мы для того, что сократить время работ по проекту работали 25% времени сверхурочно и в выходные дни с двойной оплатой, то фактические трудозатраты составили:\n
AC = 20 * (30 * 1000 + 10 * 2000) = 1 000 000 сом.\n
Поэтому отклонения по затратам в нашем случае будет\n
CV = EV - AC PV = 800 000 - 1 000 000 = - 200 000 сом.\n
Отрицательное значение отклонения по затратам означает, что мы превысили бюджет, что, в общем случае, не очень хорошо. Но если срок завершения проекта для нас имеет высший приоритет, и наши прогнозируемые затраты по завершению проекта не превышают плановых с учетом управленческого резерва (Рисунок 43), то в этом случае можно считать, что проект выполняется успешно.\n
Отклонение от бюджета и по срокам в абсолютных денежных единицах недостаточно для характеристики проектов разных масштабов. Более наглядны относительные показатели: индекс выполнения сроков SPI (Schedule Performance Index)\n\n
SPI = EV / PV\n
и индекс выполнения стоимости CPI (Cost Performance Index)\n
CPI = EV/ AC,\n
которые характеризуют проект независимо от его размера. Если значения обоих индексов больше 1, то это свидетельствуют о благополучном состоянии в проекте.\n
Какие еще измеримые показатели целесообразно применять в управлении программным проектом?\n
В первую очередь это показатель прогресса проекта, доля реализованных и проверенных высокоуровневых требований к проекту, например отношение числа завершенных сценариев использования продукта к их общему числу.\n
Другой показатель — стабильность проекта, общее количество принятых (утвержденных спонсором или заказчиком) изменений в плане управления проектом. Чем выше нестабильность в проекте, тем больше сложность в управлении работами и ниже производительность участников.\n
Если кто-то думает, что код — это решение проблемы, то это не так. Код — это новый источник проблем. Поэтому всегда следует измерять текущий размер проекта — количество строк исходного кода, добавленных, измененных и удаленных в ходе выполнения проекта разработки ПО. Чем больше объем исходного кода, тем больше времени потребуется на внесение изменений и исправление ошибок.\n
При увеличении объема проектного продукта трудозатраты на каждую новую строку исходного кода увеличиваются. Если за номинал взять производительность проектной команды при производстве продукта в 10 KSLOC, то та же команда на проекте в 100 KSLOC покажет производительность в 1.3–1.7 раз меньшую, а на проекте в 1000 KSLOC следует ожидать, что производительность снизится в 1.6–3.0 раза.\n
Большой объем кода так же потребует большего количества людей на его сопровождение. Поскольку, даже если будет выявляться только несколько критических ошибок в год, то для того, чтобы их исправить в приемлемые сроки, например, за 24 часа, в продукте общим объемом в 1000 KSLOC то один программист с этим не справится. Это связано с тем, что для того, чтобы исправить ошибку в ограниченные сроки необходимо оперативно выявить и устранить ее причину, а для этого надо хорошо знать архитектуру и код программного продукта. Чтобы эффективно сопровождать продукт подобного объема необходимо иметь в «горячем» резерве примерно 20 разработчиков, потому что 50 KSLOC, на мой взгляд, это предельный объем кода, который может удерживать в голове и эффективно сопровождать один человек. И еще проблема: чем этих людей занимать в свободное от исправлений ошибок время, если нет новых проектов развития продукта.\n
Следующий важный показатель состояния проекта — это средняя производительность, отношение текущего размера проекта к фактическим затратам по проекту. С. Макконнелл приводит следующие показатели (минимальное, максимальное и среднее значение) производительности в KSLOC на один чел.*мес. фактических затрат для стандартных типов проектов объемом в 100 KSLOC:\n
· 300-7000 (800) — интранет система.\n
· 200-7000 (600) — бизнес система.\n
· 100-2000 (300) — Интернет система.\n
· 50-600 (100) — системное ПО, телекоммуникации.\n
· 20-300 (50) — системы реального времени.\n
Высокая производительность в проекте — это далеко не всегда хороший признак. Приходилось встречаться с проектами, в которых вследствие активного применения метода «copy+past», средняя производительность в разработке бизнес системы достигала 2000 SLOC/чел.*мес. Однако для реализации требуемого функционала было написано в 3–4 раза больше кода, чем это могло бы потребоваться при адекватной проработке архитектуры.\n
Еще одна группа количественных показателей, которые следует наблюдать в ходе реализации проекта, характеризует качество программного продукта:\n
· Дефектность продукта — количество выявленных дефектов на единицу объема продукта (например, KSLOC).\n
· Доля не устраненных дефектов — отношение количества незакрытых максимально критичных и критичных дефектов к количеству выявленных несоответствий.\n
· Средние затраты на сопровождение — средние трудозатраты на исправление одного дефекта. Высокое значение этого показателя может свидетельствовать о некачественной архитектуре программного продукта.\n
· Документированность кода — определяет процент строк исходного кода с комментарии по отношению к общему количеству строк.\n
Следует подчеркнуть, что наблюдать надо за средними по проекту значениями показателей, и ни в коем случае не пытаться измерять индивидуальные характеристики производительности и качества. Главные причины, почему это не следует делать, заключаются в том, что, во-первых, в этом случае вместо слаженной командной работы мы получим личную конкуренцию, а, во-вторых, наиболее «продвинутые» разработчики станут работать на формальные показатели, а не на достижение целей проекта.\n
Если команда действительно состоялась, то для нее характерна коллективная ответственность за достижение общих целей. И, как пишет, Т.Демарко, «менеджер проекта должен занимать очередь, чтобы покритиковать сотрудника, не выполняющего свои обещания», поскольку в правильной команде для этого всегда найдется масса желающих.\n
</item>
        <!--41-->
        <item>41.ОСНОВЫ ООП.\n\n\n\n\n
Объе́ктно-ориенти́рованное программи́рование (ООП) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования.\n
Идеологически ООП — подход к программированию как к моделированию информационных объектов, решающий на новом уровне основную задачу структурного программирования: структурирование информации с точки зрения управляемости, что существенно улучшает управляемость самим процессом моделирования, что, в свою очередь, особенно важно при реализации крупных проектов.\n
Управляемость для иерархических систем предполагает минимизацию избыточности данных (аналогичную нормализации) и их целостность, поэтому созданное удобно управляемым — будет и удобно пониматься. Таким образом, через тактическую задачу управляемости решается стратегическая задача — транслировать понимание задачи программистом в наиболее удобную для дальнейшего использования форму.\n
Основные принципы структурирования в случае ООП связаны с различными аспектами базового понимания предметной задачи, которое требуется для оптимального управления соответствующей моделью:\n
•	абстракция для выделения в моделируемом предмете важного для решения конкретной задачи по предмету, в конечном счёте — контекстное понимание предмета, формализуемое в виде класса;\n
•	инкапсуляция для быстрой и безопасной организации собственно иерархической управляемости: чтобы было достаточно простой команды «что делать», без одновременного уточнения как именно делать, так как это уже другой уровень управления;\n
•	наследование для быстрой и безопасной организации родственных понятий: чтобы было достаточно на каждом иерархическом шаге учитывать только изменения, не дублируя всё остальное, учтённое на предыдущих шагах;\n
•	полиморфизм для определения точки, в которой единое управление лучше распараллелить или наоборот — собрать воедино.\n
То есть фактически речь идёт о прогрессирующей организации информации согласно первичным семантическим критериям: «важное/неважное», «ключевое/подробности», «родительское/дочернее», «единое/множественное». Прогрессирование, в частности, на последнем этапе даёт возможность перехода на следующий уровень детализации, что замыкает общий процесс.\n
Обычный человеческий язык в целом отражает идеологию ООП, начиная с инкапсуляции представления о предмете в виде его имени и заканчивая полиморфизмом использования слова в переносном смысле, что в итоге развивает выражение представления через имя предмета до полноценного понятия-класса.\n\n
 Основные понятия\n
Абстракция данных\n
Абстрагирование означает выделение значимой информации и исключение из рассмотрения незначимой. В ООП рассматривают лишь абстракцию данных (нередко называя её просто «абстракцией»), подразумевая набор наиболее значимых характеристик объекта, доступных остальной программе.\n\n
Инкапсуляция\n
Инкапсуляция — свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе. Одни языки (например, С++, Java или Ruby) отождествляют инкапсуляцию с сокрытием, но другие (Smalltalk, Eiffel, OCaml) различают эти понятия.\n\n
Наследование\n
Наследование — свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом.\n\n
Полиморфизм подтипов\n
Полиморфизм подтипов (в ООП называемый просто «полиморфизмом») — свойство системы, позволяющее использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта. Другой вид полиморфизма — параметрический — в ООП называют обобщённым программированием.\n\n
Класс\n
Класс — универсальный, комплексный тип данных, состоящий из тематически единого набора «полей» (переменных более элементарных типов) и «методов» (функций для работы с этими полями), то есть он является моделью информационной сущности с внутренним и внешним интерфейсами для оперирования своим содержимым (значениями полей). В частности, в классах широко используются специальные блоки из одного или чаще двух спаренных методов, отвечающих за элементарные операции с определённым полем (интерфейс присваивания и считывания значения), которые имитируют непосредственный доступ к полю. Эти блоки называются «свойствами» и почти совпадают по конкретному имени со своим полем (например, имя поля может начинаться со строчной, а имя свойства — с заглавной буквы). Другим проявлением интерфейсной природы класса является то, что при копировании соответствующей переменной через присваивание копируется только интерфейс, но не сами данные, то есть класс — ссылочный тип данных. Переменная-объект, относящаяся к заданному классом типу, называется экземпляром этого класса. При этом в некоторых исполняющих системах класс также может представляться некоторым объектом при выполнении программы посредством динамической идентификации типа данных. Обычно классы разрабатывают таким образом, чтобы обеспечить отвечающие природе объекта и решаемой задаче целостность данных объекта, а также удобный и простой интерфейс. В свою очередь, целостность предметной области объектов и их интерфейсов, а также удобство их проектирования, обеспечивается наследованием.\n\n
Объект\n
Сущность в адресном пространстве вычислительной системы, появляющаяся при создании экземпляра класса (например, после запуска результатов компиляции и связывания исходного кода на выполнение).</item>
        <!--42-->
        <item>42.ОБЪЕКТЫ КЛАССА. МЕТОДЫ И ДАННЫЕ КЛАССА.\n\n\n\n\n\n
В объектно-ориентированным языке такие понятия как "класс" и "объект" играют ключевую роль. Любую программу в ООП можно представить как набор взаимодействующих между собой объектов.\n
Шаблоном или описанием объекта является класс, а объект представляет экземпляр этого класса. Можно еще провести следующую аналогию. У нас у всех есть некоторое представление о человеке - наличие двух рук, двух ног, головы, туловища и т.д. Есть некоторый шаблон - этот шаблон можно назвать классом. Реально же существующий человек (фактически экземпляр данного класса) является объектом этого класса.
Класс определяется с помощью ключевого слова сlass.\n
Любой объект может обладать двумя основными характеристиками: состояние - некоторые данные, которые хранит объект, и поведение - действия, которые может совершать объект.\n
Объект – совокупность свойств, методов их обработки (процедуры и функции) и событий, на который данный объект может реагировать, и которые приводят к изменению свойств объекта.\n
Объект – многократно используемый программный модуль – экземпляр класса.\n
Для хранения состояния объекта в классе применяются поля или переменные класса.\n
По́ле кла́сса или атрибу́т (переменная-член, data member, class field, instance variable) в объектно-ориентированном программировании — переменная, описание которой создает программист при создании класса. Все данные объекта хранятся в его полях. Доступ к полям осуществляется по их имени. Обычно тип данных каждого поля задаётся в описании класса.\n
Для определения поведения объекта в классе применяются методы.\n
Методами называются процедуры и функции, предназначенные для обработки внутренних данных объекта данного класса (полей). Объект может обладать набором заранее встроенных методов обработки, созданных пользователем, которые выполняются при наступлении заранее определенных событий, например: нажатие кнопки мыши, определенной клавиши, выбор пункта меню и т.п..\n
</item>
        <!--43-->
        <item>43.ПЕРЕГРУЗКА ОПЕРАЦИЙ.\n\n\n\n\n\n
Иногда возникает необходимость создать один и тот же метод, но с разным набором параметров. И в зависимости от имеющихся параметров применять определенную версию метода. Такая возможность еще называется перегрузкой методов (method overloading).\n
В ООП мы можем создавать в классе несколько методов с одним и тем же именем, но разной сигнатурой. Что такое сигнатура? Сигнатура складывается из следующих аспектов:\n
•	Имя метода\n
•	Количество параметров\n
•	Типы параметров\n
•	Порядок параметров\n
•	Модификаторы параметров\n\n
Перегрузка операторов в программировании — один из способов реализации полиморфизма, заключающийся в возможности одновременного существования в одной области видимости нескольких различных вариантов применения оператора, имеющих одно и то же имя, но различающихся типами параметров, к которым они применяются.\n
Перегрузка методов полезна, когда требуется решать одинаковые задачи с разным набором параметров. Типичный пример – это конструкторы класса, но перегружать можно и любой другой метод.\n
Для перегрузки операций внутри класса нужно написать специальную функцию — метод класса. При перегрузке операций следует помнить следующее:\n
•	нельзя поменять приоритет операций;\n
•	нельзя изменить тип операции (из унарной операции нельзя сделать бинарную или наоборот);\n
•	перегруженная операция является членом класса и может использоваться только в выражениях с объектами своего класса;\n
•	нельзя создавать новые операции;\n
•	запрещено перегружать операции: . (доступ к членам класса), унарную операцию * (значение по адресу указателя), :: (расширение области видимости), ?: (операция if);\n
•	допустима перегрузка следующих операций: +, —, *, /, %, =, &lt;, >, +=, -=, *=, /=, &amp;&amp;, ||, ++, —, (), [], new, delete.\n
</item>
        <!--44-->
        <item>44.	НАСЛЕДОВАНИЕ. ПОЛИМОРФИЗМ. ИНКАПСУЛЯЦИЯ.\n\n\n\n\n
Все языки OOP основаны на трёх основополагающих концепциях, называемых инкапсуляцией, полиморфизмом и наследованием. Рассмотрим эти концепции.\n\n
1. Инкапсуляция`\n
Инкапсуляция (encapsulation) - это механизм, который объединяет данные и код, манипулирующий зтими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования. В объектно-ориентированном программировании код и данные могут быть объединены вместе; в этом случае говорят, что создаётся так называемый "чёрный ящик". Когда коды и данные объединяются таким способом, создаётся объект (object). Другими словами, объект - это то, что поддерживает инкапсуляцию.\n
Внутри объекта коды и данные могут быть закрытыми (private). Закрытые коды или данные доступны только для других частей этого объекта. Таким образом, закрытые коды и данные недоступны для тех частей программы, которые существуют вне объекта. Если коды и данные являются открытыми, то, несмотря на то, что они заданы внутри объекта, они доступны и для других частей программы. Характерной является ситуация, когда открытая часть объекта используется для того, чтобы обеспечить контролируемый интерфейс закрытых элементов объекта.\n
На самом деле объект является переменной определённого пользователем типа. Может показаться странным, что объект, который объединяет коды и данные, можно рассматривать как переменную. Однако применительно к объектно-ориентированному программированию это именно так. Каждый элемент данных такого типа является составной переменной.\n\n
2. Полиморфизм\n
Полиморфизм (polymorphism) (от греческого polymorphos) - это свойство, которое позволяет одно и то же имя использовать для решения двух или более схожих, но технически разных задач. Целью полиморфизма, применительно к объектно-ориентированному программированию, является использование одного имени для задания общих для класса действий. Выполнение каждого конкретного действия будет определяться типом данных.\n
В более общем смысле, концепцией полиморфизма является идея "один интерфейс, множество методов". Это означает, что можно создать общий интерфейс для группы близких по смыслу действий. Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование того же интерфейса для задания единого класса действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор. Вам, как программисту, не нужно делать этот выбор самому. Нужно только помнить и использовать общий интерфейс. Пример из предыдущего абзаца показывает, как, имея три имени для функции определения абсолютной величины числа вместо одного, обычная задача становится более сложной, чем это действительно необходимо.\n
  Полиморфизм может применяться также и к операторам. Фактически во всех языках программирования ограниченно применяется полиморфизм, например, в арифметических операторах. Так, в Си, символ + используется для складывания целых, длинных целых, символьных переменных и чисел с плавающей точкой. В этом случае компилятор автоматически определяет, какой тип арифметики требуется. В С++ вы можете применить эту концепцию и к другим, заданным вами, типам данных. Такой тип полиморфизма называется перегрузкой операторов (operator overloading).\n
Ключевым в понимании полиморфизма является то, что он позволяет вам манипулировать объектами различной степени сложности путём создания общего для них стандартного интерфейса для реализации похожих действий.\n\n
3. Наследование\n
Наследование (inheritance) - это процесс, посредством которого один объект может приобретать свойства другого. Точнее, объект может наследовать основные свойства другого объекта и добавлять к ним черты, характерные только для него. Наследование является важным, поскольку оно позволяет поддерживать концепцию иерархии классов (hierarchical classification). Применение иерархии классов делает управляемыми большие потоки информации. Например, подумайте об описании жилого дома. Дом - это часть общего класса, называемого строением. С другой стороны, строение - это часть более общего класса - конструкции, который является частью ещё более общего класса объектов, который можно назвать созданием рук человека. В каждом случае порождённый класс наследует все, связанные с родителем, качества и добавляет к ним свои собственные определяющие характеристики. Без использования иерархии классов, для каждого объекта пришлось бы задать все характеристики, которые бы исчерпывающи его определяли. Однако при использовании наследования можно описать объект путём определения того общего класса (или классов), к которому он относится, с теми специальными чертами, которые делают объект уникальным. Наследование играет очень важную роль в OOP.
</item>
        <!--45-->
        <item>45.ТОПОЛОГИЯ СЕТЕЙ.\n\n\n\n\n\n\n
Топология сетей (от греч. τόπος, - место) — способ описания конфигурации сети, схема расположения и соединения сетевых устройств.\n
Топология – это схема соединения каналами связи компьютеров или узлов сети между собой.\n
Сетевая топология может быть\n
•	физической — описывает реальное расположение и связи между узлами сети.\n
•	логической — описывает хождение сигнала в рамках физической топологии.\n
•	информационной — описывает направление потоков информации, передаваемых по сети.\n
•	управления обменом — это принцип передачи права на пользование сетью.\n\n
Существует множество способов соединения сетевых устройств. Выделяют следующие топологии:\n
•	полносвязная\n
•	ячеистая\n
•	общая шина\n
•	звезда\n
•	кольцо\n
•	снежинка\n\n

1) Полносвязная топология — топология компьютерной сети, в которой каждая рабочая станция подключена ко всем остальным. Этот вариант является громоздким и неэффективным, несмотря на свою логическую простоту. Для каждой пары должна быть выделена независимая линия, каждый компьютер должен иметь столько коммуникационных портов сколько компьютеров в сети. По этим причинам сеть может иметь только сравнительно небольшие конечные размеры. Чаще всего эта топология используется в многомашинных комплексах или глобальных сетях при малом количестве рабочих станций.\n
Технология доступа в сетях этой топологии реализуется методом передачи маркера. Маркер – это пакет, снабженный специальной последовательностью бит (его можно сравнить с конвертом для письма). Он последовательно предается по кольцу от компьютера к компьютеру в одном направлении. Каждый узел ретранслирует передаваемый маркер. Компьютер может передать свои данные, если он получил пустой маркер. Маркер с пакетом передается, пока не обнаружится компьютер, которому предназначен пакет. В этом компьютере данные принимаются, но маркер движется дальше и возвращается к отправителю.\n
После того, как отправивший пакет компьютер убедится, что пакет доставлен адресату, маркер освобождается.\n
Недостаток:  громоздкий и неэффективный вариант, т.к. каждый компьютер должен иметь большое кол-во коммуникационных портов.\n\n

2) Ячеистая топология - базовая полносвязная топология компьютерной сети, в которой каждая рабочая станция сети соединяется с несколькими другими рабочими станциями этой же сети. Характеризуется высокой отказоустойчивостью, сложностью настройки и переизбыточным расходом кабеля. Каждый компьютер имеет множество возможных путей соединения с другими компьютерами. Обрыв кабеля не приведёт к потере соединения между двумя компьютерами.\n
 Получается из полносвязной путем удаления некоторых возможных связей. Эта топология допускает соединение большого количества компьютеров и характерна, как правило, для крупных сетей.\n\n

3) Общая шина, представляет собой общий кабель (называемый шина или магистраль), к которому подсоединены все рабочие станции. На концах кабеля находятся терминаторы, для предотвращения отражения сигнала.\n
Достоинства:\n
•	Небольшое время установки сети;\n
•	Дешевизна (требуется меньше кабеля и сетевых устройств);\n
•	Простота настройки;\n
•	Выход из строя рабочей станции не отражается на работе сети.\n
 Недостатки:\n
•	Неполадки в сети, такие как обрыв кабеля и выход из строя терминатора, полностью блокируют работу всей сети;\n
•	Сложная локализация неисправностей;\n
•	С добавлением новых рабочих станций падает производительность сети.\n
Шинная топология представляет собой топологию, в которой все устройства локальной сети подключаются к линейной сетевой среде передачи данных. Такую линейную среду часто называют каналом, шиной или трассой. Каждое устройство, например, рабочая станция или сервер, независимо подключается к общему шинному кабелю с помощью специального разъема. Шинный кабель должен иметь на конце согласующий резистор, или терминатор, который поглощает электрический сигнал, не давая ему отражаться и двигаться в обратном направлении по шине.\n\n

4) Звезда - базовая топология компьютерной сети, в которой все компьютеры сети присоединены к центральному узлу (обычно коммутатор), образуя физический сегмент сети. Подобный сегмент сети может функционировать как отдельно, так и в составе сложной сетевой топологии (как правило, «дерево»). Весь обмен информацией идет исключительно через центральный компьютер, на который таким способом возлагается очень большая нагрузка, поэтому ничем другим, кроме сети, он заниматься не может. Как правило, именно центральный компьютер является самым мощным, и именно на него возлагаются все функции по управлению обменом. Никакие конфликты в сети с топологией звезда в принципе невозможны, потому что управление полностью централизовано.\n
Метод доступа реализуется с помощью технологии Arcnet. Этот метод доступа также использует маркер для передачи данных. Маркер передается от компьютера к компьютеру в порядке возрастания адреса. Как и в кольцевой топологии, каждый компьютер регенерирует маркер.\n
Достоинства:\n
•	выход из строя одной рабочей станции не отражается на работе всей сети в целом;\n
•	хорошая масштабируемость сети;\n
•	лёгкий поиск неисправностей и обрывов в сети;\n
•	высокая производительность сети (при условии правильного проектирования);\n
•	гибкие возможности администрирования.\n
Недостатки:\n
•	выход из строя центрального концентратора обернётся неработоспособностью сети (или сегмента сети) в целом;\n
•	для прокладки сети зачастую требуется больше кабеля, чем для большинства других топологий;\n
•	конечное число рабочих станций в сети (или сегменте сети) ограничено количеством портов в центральном концентраторе.\n\n

5) Кольцо - это топология, в которой каждый компьютер соединен линиями связи только с двумя другими: от одного он только получает информацию, а другому только передает. На каждой линии связи, как и в случае звезды, работает только один передатчик и один приемник. Это позволяет отказаться от применения внешних терминаторов.\n
Работа в сети кольца заключается в том, что каждый компьютер ретранслирует (возобновляет) сигнал, то есть выступает в роли повторителя, потому затухание сигнала во всем кольце не имеет никакого значения, важно только затухание между соседними компьютерами кольца. Четко выделенного центра в этом случае нет, все компьютеры могут быть одинаковыми. Однако достаточно часто в кольце выделяется специальный абонент, который управляет обменом или контролирует обмен. Понятно, что наличие такого управляющего абонента снижает надежность сети, потому что выход его из строя сразу же парализует весь обмен.\n
 Компьютеры в кольце не являются полностью равноправными (в отличие, например, от шинной топологии). Одни из них обязательно получают информацию от компьютера, который ведет передачу в этот момент, раньше, а другие — позже. Именно на этой особенности топологии и строятся методы управления обменом по сети, специально рассчитанные на «кольцо». В этих методах право на следующую передачу (или, как еще говорят, на захват сети) переходит последовательно к следующему по кругу компьютеру.\n
Подключение новых абонентов в «кольцо» обычно совсем безболезненно, хотя и требует обязательной остановки работы всей сети на время подключения. Как и в случае топологии «шина», максимальное количество абонентов в кольце может быть достаточно большое (1000 и больше). Кольцевая топология обычно является самой стойкой к перегрузкам, она обеспечивает уверенную работу с самыми большими потоками переданной по сети информации, потому что в ней, как правило, нет конфликтов (в отличие от шины), а также отсутствует центральный абонент (в отличие от звезды).\n
В кольце, в отличие от других топологий (звезда, шина), не используется конкурентный метод посылки данных, компьютер в сети получает данные от стоящего предыдущим в списке адресатов и перенаправляет их далее, если они адресованы не ему. Список адресатов генерируется компьютером, являющимся генератором маркера. Сетевой модуль генерирует маркерный сигнал (обычно порядка 2—10 байт во избежание затухания) и передает его следующей системе (иногда по возрастанию MAC-адреса). Следующая система, приняв сигнал, не анализирует его, а просто передает дальше. Это так называемый нулевой цикл.\n
Последующий алгоритм работы таков — пакет данных GRE, передаваемый отправителем адресату начинает следовать по пути, проложенному маркером. Пакет передаётся до тех пор, пока не доберётся до получателя.\n
Достоинства:\n
•	Простота установки;\n
•	Практически полное отсутствие дополнительного оборудования;\n
•	Возможность устойчивой работы без существенного падения скорости передачи данных при интенсивной загрузке сети, поскольку использование маркера исключает возможность возникновения коллизий.\n
Недостатки:\n
•	Выход из строя одной рабочей станции, и другие неполадки (обрыв кабеля), отражаются на работоспособности всей сети;\n
•	Сложность конфигурирования и настройки;\n
•	Сложность поиска неисправностей.\n
•	Необходимость иметь две сетевые платы, на каждой рабочей станции.\n\n

6) Снежинка (Иерархическая Звезда или древовидная топология) - топология типа звезды, но используется несколько концентратов, иерархически соединенных между собой связями типа звезда.  Топология "снежинка" требует меньшей длины кабеля, чем "звезда", но больше элементов.\n
 Самый распространенный способ связей как в локальных сетях, так и в глобальных.
</item>
        <!--46-->
        <item>46.ПРИНЦИПЫ СЕТЕВЫХ ТЕХНОЛОГИЙ.\n\n\n\n\n\n
Сеть позволяет двум и более компьютерам связываться друг с другом, совместно использовать файлы и принтеры, обмениваться данными и работать с общим подключением к Интернету. В крупных компаниях сети существуют уже несколько десятилетий, повсеместно встречаются в мелких организациях, а в последнее время домашние сети тоже стали вполне распространенным явлением. Построение домашней сети обойдется недорого и не требует сложной настройки. В наше время домов с несколькими компьютерами становится все больше, и сети часто используются для организации совместных широкополосных подключений к Интернету — например, по линии DSL или кабельному модему.\n
Даже простая сеть обладает многими полезными возможностями:\n
•	Совместный доступ к файлам — документы и даже некоторые приложения, хранящиеся на одном компьютере, могут быть доступны для других компьютеров сети (так, словно они находятся на жестком диске удаленного компьютера).\n
•	Синхронизация файлов — файлы могут автоматически синхронизироваться между несколькими компьютерами (например, между настольным и портативным компьютером). Пользователь отключает портативный компьютер от сети (скажем, для поездки в командировку) и работает на нем с файлами. После возвращения портативный компьютер снова подключается к сети, а файлы автоматически копируются на настольный компьютер для продолжения работы.\n
•	Совместный доступ к устройствам — принтер, подключенный к одному компьютеру, может использоваться другими компьютерами сети. То же относится к сканерам, устройствам резервного копирования и устройствам высокоскоростного доступа к Интернету (например, DSL и кабельные модемы).\n
•	Сетевые игры — вы можете играть в сетевые игры с другими пользователями вашей локальной сети и даже Интернета. В конце концов, воевать со своими знакомыми интереснее, чем с компьютерными персонажами.\n
•	Обмен информацией и совместная работа — отправка и получение электронной почты, моментальная организация чатов и даже видеоконференций с участниками с разных концов страны. Windows Vista включает ряд новых функций совместной работы, в том числе возможность проведения «живых» презентаций по сети.\n
•	Работа в Web — используя Internet Explorer или другой браузер по своему усмотрению, пользователь может получить информацию с другого континента так же легко, как из другой комнаты того же здания.\n
•	Совместная работа с данными — сетевое подключение позволяет двум и более пользователям одновременно обращаться к одной базе данных. Например, такая возможность может пригодиться для получения истории болезни пациентов, параллельной разработки приложений в коллективах программистов или отслеживания счетов и расходов в домашнем хозяйстве.\n
•	Администрирование — сеть упрощает решение задач по сопровождению и диагностике компьютеров. При помощи Удаленного рабочего стола (или его аналога от стороннего производителя) можно управлять удаленным компьютером точно так же, как если бы вы сидели прямо перед ним. Вместо того чтобы тратить несколько часов на телефонные переговоры и помогать в решении проблемы с компьютером, исправьте все сами за считанные минуты.
Возможность выполнения всех перечисленных функций зависит только от установленного программного обеспечения и скорости канала связи. Так как Windows обычно содержит встроенную поддержку сетей и набор приложений, обеспечивающих все перечисленные функции, от вас потребуется лишь правильно настроить их. Необходимо учитывать, что подключение компьютера к сети существенно повышает его уязвимость для хакеров и вирусов.
Чтобы разобраться во всех программах и оборудовании, используемых при построении сетей, очень важно знать сетевую терминологию. Далее перечислены основные термины, встречающиеся при обсуждении сетевых технологий:\n
•	Домен — сеть, использующая модель «клиент/сервер». В рамках этой модели один или несколько серверов предоставляют сети централизованные ресурсы: общий доступ к файлам, использование принтеров или электронной почты. Клиенты подключаются к серверам, чтобы получить доступ к сети. Домены обычно применяются в крупных организациях; локальные сети, находящиеся в разных географических местах, могут быть подключены к одному домену. Не путайте сетевые домены с доменными именами Интернета (sura.ru).\n
•	Брандмауэр (firewall) —  уровень зашиты, разрешающий или запрещающий пересылку данных по сети на основании заданного набора правил. Брандмауэры используются для ограничения несанкционированного доступа со стороны злоумышленников, блокировки «черных ходов», открываемых вирусами и другими вредоносными программами, и подавления лишнего трафика за счет блокировки некоторых типов сетевых приложений. В Windows существует встроенный брандмауэр.\n
•	Шлюз (gateway) — устройство, связывающее две сети с разными протоколами (или две сети IP). Например, шлюз может соединять локальную проводную или беспроводную сеть с Интернетом. Шлюзы часто встраиваются в маршрутизаторы, чтобы домашние PC могли взаимодействовать друг с другом и подключаться к Интернету.\n
•	Концентраторы и коммутаторы — сетевые устройства, к которым подключаются несколько каналов Ethernet (подключаемые устройства называются узлами). Отличия между концентратором и коммутатором сводятся к производительности (и цене). Коммутатор способен одновременно обслуживать несколько полноценных широкополосных подключений, а более дешевые концентраторы распределяют ресурсы канала (например, если каждое из трех параллельных подключений использует одну треть пропускной способности канала).\n
•	Точка доступа — общедоступные беспроводные сети работают во многих кафе, библиотеках, аэропортах и других общественных местах. Любой желающий может подключиться к такой сети по Wi-Fi для получения доступа к Интернету. Одни точки доступа работают бесплатно, другие должны оплачиваться. В некоторых городах целые районы превращены в огромные точки доступа, к которым может подключаться любой желающий, причем нередко бесплатно.\n
•	IP-адрес — числовой код из четырех байт (например, 207.46.230.218), идентифицирующий компьютер или устройство в сетях TCP/IP (Transmission Control Protocol/Internet Protocol). Два компьютера в одной сети не могут обладать одинаковыми IP-адресами, но один компьютер может иметь несколько IP-адресов (например, шлюзовой сервер имеет два адреса - по одному для каждой из объединяемых сетей). Большинство компонентов адреса принимает значения от 0 до 255, что дает примерно 2564, или 4,3 миллиарда возможных комбинаций. Преобразование адресов между сетями осуществляется механизмом NAT (Network Address Translation). В частности, преобразование адресов приносит пользу при подключении защищенной брандмауэром локальной сети к Интернету (так, преобразование адресов дает возможность веб-серверам возвращать ответы нужному компьютеру сети, даже если весь Интернет-трафик проходит через один кабельный или DSL-модем).\n
В Интернете специально выделенные компьютеры, называемые серверами имен, преобразуют символьные имена хостов вида www.microsoft.com в соответствующие им IP-адреса. За дополнительной информацией обращайтесь к разделам «Настройка протокола IP для Windows» и «NSLookup».\n
Четырехбайтовая адресация используется в действующей версии сетевого протокола, называемой IPv4. Однако Windows также поддерживает новую версию IPv6, которая значительно расширяет диапазон доступных IP-адресов, а также обладает новыми функциями безопасности и QoS (Quality of Service). Адреса IPv6 имеют вид fe80::28ff:b329:f8b3:a44e. Протокол IPv6 обычно встречается в сетях крупных организаций, но не в малых или домашних сетях.\n
•	локальная сеть — обычно этим термином обозначается сеть, расположенная в пределах одной комнаты или здания. Также встречается сокращение LAN (Local Area Network).\n
•	Одноранговая сеть — сеть, в которой центральные серверы отсутствуют, а компьютеры непосредственно взаимодействуют друг с другом и обмениваются ресурсами. К категории одноранговых относятся домашние сети и многие сети малых предприятий. В более крупных сетях вместо одноранговой модели чаще используется модель с централизованными серверами. Термином «одноранговые сети» также иногда обозначаются приложения, напрямую связывающие компьютеры по Интернету или сети для обмена файлами (например, BitTorrent).\n
•	Протокол — «язык», на котором ваш компьютер общается с другими компьютерами сети. Семейство протоколов TCP/IP — фактический стандарт для локальных и глобальных сетей, и его поддержка необходима для подключения к Интернету.\n
•	TCP/IP — сокращенное обозначение семейства протоколов, включающего протоколы TCP (Transmission Control Protocol), IP (Internet Protocol), UDP (User Datagram Protocol) и ICMP (Internet Control Message Protocol). TCP/IP необходим для подключения к Интернету и является стандартным протоколом в большинстве современных локальных сетей.\n
•	Маршрутизатор (router) — устройство, обеспечивающее внутри- и межсетевую передачу пакетов данных, а также маршрутизацию пакетов к месту назначения. В частности, маршрутизатор анализирует пакеты данных в сети, определяет место назначения и отправляет их. В Интернете маршрутизаторы обычно пересылают пакеты данных другим маршрутизаторам, которые пересылают их третьим, и т. д., пока пакет не достигнет места назначения. Маршрутизаторы часто путают с коммутаторами. Коммутатор представляет собой пассивное устройство, объединяющее другие устройства для формирования сети, а маршрутизатор занимается активным перенаправлением пакетов.\n
•	Сервер — компьютер сети, обеспечивающий выполнение некоторой функции (доступ к электронной почте, хранение и предоставление файлов, управление базой данных и т. д.). Серверы обычно используются в корпоративных, но не в домашних сетях.\n
•	Топология — физическое строение сети.\n
•	VPN (Virtual Private Network) виртуальная сеть, обеспечивающая защищенную пересылку шифрованных данных в Интернете. Компании часто используют VPN, чтобы их работники могли подключаться к корпоративной сети из дома или во время поездки. Подключение осуществляется по Интернету, но все данные шифруются и передаются по виртуальному «туннелю», что обеспечивает конфиденциальность и защиту трафика. Windows содержит встроенные средства для создания подключений VPN.\n
•	Глобальная сеть — сеть из компьютеров, находящихся на больших расстояниях друг от друга. Примером глобальной сети служит Интернет. На домашнем маршрутизаторе несколько портов обычно используются для подключения компьютеров к домашней сети, а один порт с пометкой WAN связывает домашнюю сеть с Интернетом.\n
•	Рабочая группа — группа компьютеров, объединенных в одноранговую сеть с совместным доступом к ресурсам (таким, как принтеры и файлы). Рабочие группы часто путают с сетью. Одна сеть может содержать несколько рабочих групп, в нее можно включать новые рабочие группы и удалять их. При настройке сети Windows  автоматически создает рабочую группу и присваивает ей имя. Тем не менее вы можете переименовать эту группу и добавить в сеть новые группы. Windows позволяет легко сменить рабочую группу, к которой принадлежит ваш компьютер.
</item>
        <!--47-->
        <item>47.СИСТЕМА СЧИСЛЕНИЕ. ПЕРЕВОД ЧИСЕЛ ИЗ ОДНОЙ СИСТЕМЫ СЧИСЛЕНИЯ В ДРУГУЮ.\n\n\n
Система счисления — это способ записи (представления) чисел.\n
Что под этим подразумевается? Например, вы видите перед собой несколько деревьев. Ваша задача — их посчитать. Для этого можно — загибать пальцы, делать зарубки на камне (одно дерево — один палец\зарубка) или сопоставить 10 деревьям какой-нибудь предмет, например, камень, а единичному экземпляру — палочку и выкладывать их на землю по мере подсчета. В первом случае число представляется, как строка из загнутых пальцев или зарубок, во втором — композиция камней и палочек, где слева — камни, а справа — палочки\n\n
Системы счисления подразделяются на позиционные и непозиционные, а позиционные, в свою очередь, — на однородные и смешанные.\n
Непозиционная — самая древняя, в ней каждая цифра числа имеет величину, не зависящую от её позиции (разряда). То есть, если у вас 5 черточек — то число тоже равно 5, поскольку каждой черточке, независимо от её места в строке, соответствует всего 1 один предмет.\n
Позиционная система — значение каждой цифры зависит от её позиции (разряда) в числе. Например, привычная для нас 10-я система счисления — позиционная. Рассмотрим число 453. Цифра 4 обозначает количество сотен и соответствует числу 400, 5 — кол-во десяток и аналогично значению 50, а 3 — единиц и значению 3. Как видим — чем больше разряд — тем значение выше. Итоговое число можно представить, как сумму 400+50+3=453.\n
Однородная система — для всех разрядов (позиций) числа набор допустимых символов (цифр) одинаков. В качестве примера возьмем упоминавшуюся ранее 10-ю систему. При записи числа в однородной 10-й системе вы можете использовать в каждом разряде исключительно одну цифру от 0 до 9, таким образом, допускается число 450 (1-й разряд — 0, 2-й — 5, 3-й — 4), а 4F5 — нет, поскольку символ F не входит в набор цифр от 0 до 9.\n
Смешанная система — в каждом разряде (позиции) числа набор допустимых символов (цифр) может отличаться от наборов других разрядов. Яркий пример — система измерения времени. В разряде секунд и минут возможно 60 различных символов (от «00» до «59»), в разряде часов – 24 разных символа (от «00» до «23»), в разряде суток – 365 и т. д.\n\n

Непозиционные системы\n
Как только люди научились считать — возникла потребность записи чисел. В начале все было просто — зарубка или черточка на какой-нибудь поверхности соответствовала одному предмету, например, одному фрукту. Так появилась первая система счисления — единичная.\n\n
Единичная система счисления\n
Число в этой системе счисления представляет собой строку из черточек (палочек), количество которых равно значению данного числа. Таким образом, урожай из 100 фиников будет равен числу, состоящему из 100 черточек.\n
Но эта система обладает явными неудобствами — чем больше число — тем длиннее строка из палочек. Помимо этого, можно легко ошибиться при записи числа, добавив случайно лишнюю палочку или, наоборот, не дописав.\n
Для удобства, люди стали группировать палочки по 3, 5, 10 штук. При этом, каждой группе соответствовал определенный знак или предмет. Изначально для подсчета использовались пальцы рук, поэтому первые знаки появились для групп из 5 и 10 штук (единиц). Все это позволило создать более удобные системы записи чисел.\n\n
Древнеегипетская десятичная система\n
В Древнем Египте использовались специальные символы (цифры) для обозначения чисел 1, 10, 102, 103, 104, 105, 106, 107.
Почему она называется десятичной? Как писалось выше — люди стали группировать символы. В Египте — выбрали группировку по 10, оставив без изменений цифру “1”. В данном случае, число 10 называется основанием десятичной системы счисления, а каждый символ — представление числа 10 в какой-то степени.\n
Числа в древнеегипетской системе счисления записывались, как комбинация этих символов, каждый из которых повторялся не более девяти раз. Итоговое значение равнялось сумме элементов числа. Стоит отметить, что такой способ получения значения свойственен каждой непозиционной системе счисления.\n\n

Вавилонская шестидесятеричная система\n
В отличии от египетской, в вавилонской системе использовалось всего 2 символа: “прямой” клин — для обозначения единиц и “лежачий” — для десятков. Чтобы определить значение числа необходимо изображение числа разбить на разряды справа налево. Новый разряд начинается с появления прямого клина после лежачего.\n
Число 60 и все его степени так же обозначаются прямым клином, что и “1”. Поэтому вавилонская система счисления получила название шестидесятеричной.\n
Все числа от 1 до 59 вавилоняне записывали в десятичной непозиционной системе, а большие значения — в позиционной с основанием 60.\n
Запись числа была неоднозначной, поскольку не существовало цифры обозначающей ноль. Представление числа 92 могло обозначать не только 92=60+32, но и, например, 3632=3600+32. Для определения абсолютного значения числа был введен специальный символ для обозначения пропущенного шестидесятеричного разряда, что соответствует появлению цифры 0 в записи десятичного числа.\n

Шестидесятеричная вавилонская система — первая система счисления, частично основанная на позиционном принципе. Данная система счисления используется и сегодня, например, при определении времени — час состоит из 60 минут, а минута из 60 секунд.\n\n
Римская система\n
Римская система не сильно отличается от египетской. В ней для обозначения чисел 1, 5, 10, 50, 100, 500 и 1000 используются заглавные латинские буквы I, V, X, L, C, D и M соответственно. Число в римской системе счисления — это набор стоящих подряд цифр.\n\n

Методы определения значения числа:\n
1.	Значение числа равно сумме значений его цифр. Например, число 32 в римской системе счисления имеет вид XXXII=(X+X+X)+(I+I)=30+2=32\n
2.	Если слева от большей цифры стоит меньшая, то значение равно разности между большей и меньшей цифрами. При этом, левая цифра может быть меньше правой максимум на один порядок: так, перед L(50) и С(100) из «младших» может стоять только X(10), перед D(500) и M(1000) — только C(100), перед V(5) — только I(1); число 444 в рассматриваемой системе счисления будет записано в виде CDXLIV = (D-C)+(L-X)+(V-I) = 400+40+4=444.\n
3.	Значение равно сумме значений групп и цифр, не подходящих под 1 и 2 пункты.\n\n

Помимо цифирных, существуют и буквенные (алфавитные) системы счисления, вот некоторые из них:\n
1) Славянская\n
2) Греческая (ионийская)\n\n

Позиционные системы счисления\n
Как упоминалось выше — первые предпосылки к появлению позиционной системы возникли в древнем Вавилоне. В Индии система приняла форму позиционной десятичной нумерации с применением нуля, а у индусов эту систему чисел заимствовали арабы, от которых её переняли европейцы. По каким-то причинам, в Европе за этой системой закрепилось название “арабская”.\n\n
Десятичная система счисления\n
Это одна из самых распространенных систем счисления. Именно её мы используем, когда называем цену товара и произносим номер автобуса. В каждом разряде (позиции) может использоваться только одна цифра из диапазона от 0 до 9. Основанием системы является число 10.\n
Для примера возьмем число 503. Если бы это число было записано в непозиционной системе, то его значение равнялось 5+0+3 = 8. Но у нас — позиционная система и значит каждую цифру числа необходимо умножить на основание системы, в данном случае число “10”, возведенное в степень, равную номеру разряда. Получается, значение равно 5*102 + 0*101 + 3*100 = 500+0+3 = 503. Чтобы избежать путаницы при одновременной работе с несколькими системами счисления основание указывается в качестве нижнего индекса. Таким образом, 503 = 50310.\n\n
Помимо десятичной системы, отдельного внимания заслуживают 2-, 8-, 16-ая системы.\n

Двоичная система счисления\n
Эта система, в основном, используется в вычислительной технике. Почему не стали использовать привычную нам 10-ю? Первую вычислительную машину создал Блез Паскаль, использовавший в ней десятичную систему, которая оказалась неудобной в современных электронных машинах, поскольку требовалось производство устройств, способных работать в 10 состояниях, что увеличивало их цену и итоговые размеры машины. Этих недостатков лишены элементы, работающие в 2-ой системе. Тем не менее, рассматриваемая система была создана за долго до изобретения вычислительных машин и уходит “корнями” в цивилизацию Инков, где использовались кипу — сложные верёвочные сплетения и узелки.\n
Двоичная позиционная система счисления имеет основание 2 и использует для записи числа 2 символа (цифры): 0 и 1. В каждом разряде допустима только одна цифра — либо 0, либо 1.\n
Примером может служить число 101. Оно аналогично числу 5 в десятичной системе счисления. Для того, чтобы перевести из 2-й в 10-ю необходимо умножить каждую цифру двоичного числа на основание “2”, возведенное в степень, равную разряду. Таким образом, число 1012 = 1*22 + 0*21 + 1*20 = 4+0+1 = 510.\n
Хорошо, для машин 2-я система счисления удобнее, но мы ведь часто видим, используем на компьютере числа в 10-й системе. Как же тогда машина определяет какую цифру вводит пользователь? Как переводит число из одной системы в другую, ведь в её распоряжении всего 2 символа — 0 и 1?\n
Чтобы компьютер мог работать с двоичными числами (кодами), необходимо чтобы они где-то хранились. Для хранения каждой отдельной цифры применяется триггер, представляющий собой электронную схему. Он может находится в 2-х состояниях, одно из которых соответствует нулю, другое — единице. Для запоминания отдельного числа используется регистр — группа триггеров, число которых соответствует количеству разрядов в двоичном числе. А совокупность регистров — это оперативная память. Число, содержащееся в регистре — машинное слово. Арифметические и логические операции со словами осуществляет арифметико-логическое устройство (АЛУ). Для упрощения доступа к регистрам их нумеруют. Номер называется адресом регистра. Например, если необходимо сложить 2 числа — достаточно указать номера ячеек (регистров), в которых они находятся, а не сами числа. Адреса записываются в 8- и 16-ричной системах (о них будет рассказано ниже), поскольку переход от них к двоичной системе и обратно осуществляется достаточно просто. Для перевода из 2-й в 8-ю число необходимо разбить на группы по 3 разряда справа налево, а для перехода к 16-ой — по 4. Если в крайней левой группе цифр не достает разрядов, то они заполняются слева нулями, которые называются ведущими. В качестве примера возьмем число 1011002. В восьмеричной — это 101 100 = 548, а в шестнадцатеричной — 0010 1100 = 2С16. Отлично, но почему на экране мы видим десятичные числа и буквы? При нажатии на клавишу в компьютер передаётся определённая последовательность электрических импульсов, причём каждому символу соответствует своя последовательность электрических импульсов (нулей и единиц). Программа драйвер клавиатуры и экрана обращается к кодовой таблице символов (например, Unicode, позволяющая закодировать 65536 символов), определяет какому символу соответствует полученный код и отображает его на экране. Таким образом, тексты и числа хранятся в памяти компьютера в двоичном коде, а программным способом преобразуются в изображения на экране.\n\n

Восьмеричная система счисления\n
8-я система счисления, как и двоичная, часто применяется в цифровой технике. Имеет основание 8 и использует для записи числа цифры от 0 до 7.
Пример восьмеричного числа: 254. Для перевода в 10-ю систему необходимо каждый разряд исходного числа умножить на 8n, где n — это номер разряда. Получается, что 2548 = 2*82 + 5*81 + 4*80 = 128+40+4 = 17210.\n\n

Шестнадцатеричная система счисления\n
Шестнадцатеричная система широко используется в современных компьютерах, например при помощи неё указывается цвет: #FFFFFF — белый цвет. Рассматриваемая система имеет основание 16 и использует для записи числа: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B. C, D, E, F, где буквы равны 10, 11, 12, 13, 14, 15 соответственно.\n
В качестве примера возьмем число 4F516. Для перевода в восьмеричную систему — сначала преобразуем шестнадцатеричное число в двоичное, а затем, разбив на группы по 3 разряда, в восьмеричное. Чтобы преобразовать число в 2-е необходимо каждую цифру представить в виде 4-х разрядного двоичного числа. 4F516 = (100 1111 101)2. Но в 1 и 3 группах не достает разряда, поэтому заполним каждый ведущими нулями: 0100 1111 0101. Теперь необходимо разделить полученное число на группы по 3 цифры справа налево: 0100 1111 0101 = 010 011 110 101. Переведем каждую двоичную группу в восьмеричную систему, умножив каждый разряд на 2n, где n — номер разряда: (0*22+1*21+0*20) (0*22+1*21+1*20) (1*22+1*21+0*20) (1*22+0*21+1*20) = 23658.\n\n

Помимо рассмотренных позиционных систем счисления, существуют и другие, например:\n
1) Троичная\n
2) Четверичная\n
3) Двенадцатеричная\n\n
Позиционные системы подразделяются на однородные и смешанные.\n\n

Однородные позиционные системы счисления\n
Определение, данное в начале статьи, достаточно полно описывает однородные системы, поэтому уточнение — излишне.\n\n

Смешанные системы счисления\n
К уже приведенному определению можно добавить теорему: “если P=Qn (P,Q,n – целые положительные числа, при этом P и Q — основания), то запись любого числа в смешанной (P-Q)-ой системе счисления тождественно совпадает с записью этого же числа в системе счисления с основанием Q.”
Опираясь на теорему, можно сформулировать правила перевода из P-й в Q-ю системы и наоборот:\n
1.	Для перевода из Q-й в P-ю, необходимо число в Q-й системе, разбить на группы по n цифр, начиная с правой цифры, и каждую группу заменить одной цифрой в P-й системе.\n
2.	Для перевода из P-й в Q-ю, необходимо каждую цифру числа в P-й системе перевести в Q-ю и заполнить недостающие разряды ведущими нулями, за исключением левого, так, чтобы каждое число в системе с основанием Q состояло из n цифр.\n

Яркий пример — перевод из двоичной системы счисления в восьмеричную. Возьмем двоичное число 100111102, для перевода в восьмеричное — разобьем его справа налево на группы по 3 цифры: 010 011 110, теперь умножим каждый разряд на 2n, где n — номер разряда, 010 011 110 = (0*22+1*21+0*20) (0*22+1*21+1*20) (1*22+1*21+0*20) = 2368. Получается, что 100111102 = 2368. Для однозначности изображения двоично-восьмеричного числа его разбивают на тройки: 2368 = (10 011 110)2-8.\n\n
Смешанными системами счисления также являются, например:\n
1) Факториальная\n
2) Фибоначчиева\n\n
Перевод из одной системы счисления в другую\n
Иногда требуется преобразовать число из одной системы счисления в другую, поэтому рассмотрим способы перевода между различными системами.\n\n

Преобразование в десятичную систему счисления\n
Имеется число a1a2a3 в системе счисления с основанием b. Для перевода в 10-ю систему необходимо каждый разряд числа умножить на bn, где n — номер разряда. Таким образом, (a1a2a3)b = (a1*b2 + a2*b1 + a3*b0)10.\n
Пример: 1012 = 1*22 + 0*21 + 1*20 = 4+0+1 = 510\n\n

Преобразование из десятичной системы счисления в другие\n
Целая часть:\n
1.	Последовательно делим целую часть десятичного числа на основание системы, в которую переводим, пока десятичное число не станет равно нулю.\n
2.	Полученные при делении остатки являются цифрами искомого числа. Число в новой системе записывают, начиная с последнего остатка.\n\n

Дробная часть:\n
1.	Дробную часть десятичного числа умножаем на основание системы, в которую требуется перевести. Отделяем целую часть. Продолжаем умножать дробную часть на основание новой системы, пока она не станет равной 0.\n
2.	Число в новой системе составляют целые части результатов умножения в порядке, соответствующем их получению.\n\n
Пример: переведем 1510 в восьмеричную:\n
15\8 = 1, остаток 7\n
1\8 = 0, остаток 1\n

Записав все остатки снизу вверх, получаем итоговое число 17. Следовательно, 1510 = 178.\n\n

Преобразование из двоичной в восьмеричную и шестнадцатеричную системы\n
Для перевода в восьмеричную — разбиваем двоичное число на группы по 3 цифры справа налево, а недостающие крайние разряды заполняем ведущими нулями. Далее преобразуем каждую группу, умножая последовательно разряды на 2n, где n — номер разряда.\n
В качестве примера возьмем число 10012: 10012 = 001 001 = (0*22 + 0*21 + 1*20) (0*22 + 0*21 + 1*20) = (0+0+1) (0+0+1) = 118\n

Для перевода в шестнадцатеричную — разбиваем двоичное число на группы по 4 цифры справа налево, затем — аналогично преобразованию из 2-й в 8-ю.\n\n

Преобразование из восьмеричной и шестнадцатеричной систем в двоичную\n
Перевод из восьмеричной в двоичную — преобразуем каждый разряд восьмеричного числа в двоичное 3-х разрядное число делением на 2 (более подробно о делении см. выше пункт “Преобразование из десятичной системы счисления в другие”), недостающие крайние разряды заполним ведущими нулями.\n
Для примера рассмотрим число 458: 45 = (100) (101) = 1001012\n
Перевод из 16-ой в 2-ю — преобразуем каждый разряд шестнадцатеричного числа в двоичное 4-х разрядное число делением на 2, недостающие крайние разряды заполняем ведущими нулями.\n\n

Преобразование дробной части любой системы счисления в десятичную
Преобразование осуществляется также, как и для целых частей, за исключением того, что цифры числа умножаются на основание в степени “-n”, где n начинается от 1.\n
Пример: 101,0112 = (1*22 + 0*21 + 1*20), (0*2-1 + 1*2-2 + 1*2-3) = (5), (0 + 0,25 + 0,125) = 5,37510\n\n

Преобразование дробной части двоичной системы в 8- и 16-ую\n
Перевод дробной части осуществляется также, как и для целых частей числа, за тем лишь исключением, что разбивка на группы по 3 и 4 цифры идёт вправо от десятичной запятой, недостающие разряды дополняются нулями справа.\n
Пример: 1001,012 = 001 001, 010 = (0*22 + 0*21 + 1*20) (0*22 + 0*21 + 1*20), (0*22 + 1*21 + 0*20) = (0+0+1) (0+0+1), (0+2+0) = 11,28\n\n

Преобразование дробной части десятичной системы в любую другую\n
Для перевода дробной части числа в другие системы счисления нужно обратить целую часть в ноль и начать умножение получившегося числа на основание системы, в которую нужно перевести. Если в результате умножения будут снова появляться целые части, их нужно повторно обращать в ноль, предварительно запомнив (записав) значение получившейся целой части. Операция заканчивается, когда дробная часть полностью обратится в нуль.\n
Для примера переведем 10,62510 в двоичную систему:\n
0,625*2 = 1,25\n
0,250*2 = 0,5\n
0,5*2 = 1,0\n
Записав все остатки сверху вниз, получаем 10,62510 = (1010), (101) = 1010,1012\n
</item>
        <!--48-->
        <item>48.МНОЖЕСТВА. ОПЕРАЦИИ НАД МНОЖЕСТВАМИ.\n\n\n\n\n\n
Множеством называется совокупность некоторых элементов, объединенных каким-либо общим признаком. Элементами множества могут быть числа, фигуры, предметы, понятия и т.п.\n
Множества обозначаются прописными буквами, а элементы множество строчными буквами. Элементы множеств заключаются в фигурные скобки.\n
Если элемент x принадлежит множеству X, то записывают x ∈ Х (∈ — принадлежит).\n
Если множество А является частью множества В, то записывают А ⊂ В (⊂ — содержится).\n
Множество может быть задано одним из двух способов: перечислением и с помощью определяющего свойства.\n
Например, перечислением заданы следующие множества:\n
	А={1,2,3,5,7} — множество чисел\n
	Х={x1,x2,...,xn} — множество некоторых элементов x1,x2,...,xn\n
	N={1,2,...,n} — множество натуральных чисел\n
	Z={0,±1,±2,...,±n} — множество целых чисел\n
Множество (-∞;+∞) называется числовой прямой, а любое число — точкой этой прямой. Пусть a — произвольная точка числовой прямой иδ — положительное число. Интервал (a-δ; a+δ) называется δ-окрестностью точки а.\n
Множество Х ограничено сверху (снизу), если существует такое число c, что для любого x ∈ X выполняется неравенство x≤с (x≥c). Число с в этом случае называется верхней(нижней) гранью множества Х. Множество, ограниченное и сверху и снизу, называется ограниченным. Наименьшая (наибольшая) из верхних (нижних) граней множества называется точной верхней (нижней) гранью этого множества.\n\n
Основные числовые множества\n
N	{1,2,3,...,n} Множество всех натуральных чисел\n
Z	{0, ±1, ±2, ±3,...} Множество целых чисел. Множество целых чисел включает в себя множество натуральных.\n
Q	Множество рациональных чисел.\n
Кроме целых чисел имеются ещё и дроби. Дробь — это выражение вида  , где p — целое число, q — натуральное. Десятичные дроби также можно записать в виде  . Например: 0,25 = 25/100 = 1/4. Целые числа также можно записать в виде  . Например, в виде дроби со знаменателем "один": 2 = 2/1.\n
Таким образом любое рациональное число можно записать десятичной дробью — конечно или бесконечной периодической.\n
R	Множество всех вещественных чисел.\n
Иррациональные числа — это бесконечные непериодические дроби. К ним относятся:\n
	число   — отношение длины окружности к её диаметру;\n
	число   — названное в честь Эйлера и др.;\n
Вместе два множества (рациональных и иррациональных чисел) — образуют множество действительных (или вещественных) чисел.\n

Если множество не содержит ни одного элемента, то оно называется пустым множеством и записывается Ø.\n\n

ОПЕРАЦИИ НАД МНОЖЕСТВАМИ\n
Два множества А и В равны (А=В), если они состоят из одних и тех же элементов.\n
Например, если А={1,2,3,4}, B={3,1,4,2} то А=В.\n
Объединением (суммой) множеств А и В называется множество А ∪ В, элементы которого принадлежат хотя бы одному из этих множеств.\n
Например, если А={1,2,4}, B={3,4,5,6}, то А ∪ B = {1,2,3,4,5,6}\n
Пересечением (произведением) множеств А и В называется множество А ∩ В, элементы которого принадлежат как множеству А, так и множеству В.\n
Например, если А={1,2,4}, B={3,4,5,2}, то А ∩ В = {2,4}\n
Разностью множеств А и В называется множество АВ, элементы которого принадлежат множеству А, но не принадлежат множеству В.\n
Например, если А={1,2,3,4}, B={3,4,5}, то АВ = {1,2}\n
Симметричной разностью множеств А и В называется множество А Δ В, являющееся объединением разностей множеств АВ и ВА, то есть А Δ В = (АВ) ∪ (ВА).\n
Например, если А={1,2,3,4}, B={3,4,5,6}, то А Δ В = {1,2} ∪ {5,6} = {1,2,5,6}\n

</item>
        <!--49-->
        <item>49.ЛОГИЧЕСКИЕ ОПЕРАЦИИ. ЛОГИЧЕСКИЕ ОСНОВЫ КОМПЬЮТЕРА.\n\n\n\n
Логические операции - мыслительные действия, результатом которых является изменение содержания или объема понятий, а также образование новых понятий.\n
Логическое выражение - устное утверждение или запись, в которое, наряду с постоянными величинами, обязательно входят переменные величины (объекты). В зависимости от значений этих переменных величин (объектов) логическое выражение может принимать одно из двух возможных значений: истина (логическая 1) или ложь (логический 0).\n
Сложное логическое выражение - логическое выражение, состоящее из одного или нескольких простых логических выражений (или сложных логических выражений), соединенных с помощью логических операций.\n\n

Логические операции и таблицы истинности\n
1) Логическое умножение или конъюнкция:\n
Конъюнкция - это сложное логическое выражение, которое считается истинным в том и только том случае, когда оба простых выражения являются истинными, во всех остальных случаях данное сложенное выражение ложно.\n
Обозначение: F = A &amp; B.\n

Таблица истинности для конъюнкции\n
A	B	F\n
1	1	1\n
1	0	0\n
0	1	0\n
0	0	0\n\n

2) Логическое сложение или дизъюнкция:\n
Дизъюнкция - это сложное логическое выражение, которое истинно, если хотя бы одно из простых логических выражений истинно и ложно тогда и только тогда, когда оба простых логических выражения ложны.\n
Обозначение: F = A v B.\n
Таблица истинности для дизъюнкции\n
A	B	F\n
1	1	1\n
1	0	1\n
0	1	1\n
0	0	0\n\n

3) Логическое отрицание или инверсия:\n
Инверсия - это сложное логическое выражение, если исходное логическое выражение истинно, то результат отрицания будет ложным, и наоборот, если исходное логическое выражение ложно, то результат отрицания будет истинным. Другими простыми слова, данная операция означает, что к исходному логическому выражению добавляется частица НЕ или слова НЕВЕРНО, ЧТО.\n
Обозначение: F = ¬A.\n
Таблица истинности для инверсии\n
A	¬А\n
1	0\n
0	1\n\n

4) Логическое следование или импликация:\n
Импликация - это сложное логическое выражение, которое истинно во всех случаях, кроме как из истины следует ложь. То есть данная логическая операция связывает два простых логических выражения, из которых первое является условием (А), а второе (В) является следствием.
«A → B» истинно, если из А может следовать B.\n
Обозначение: F = A → B.\n
Таблица истинности для импликации\n

A	B	F\n
1	1	1\n
1	0	0\n
0	1	1\n
0	0	1\n\n

5) Логическая равнозначность или эквивалентность:\n
Эквивалентность - это сложное логическое выражение, которое является истинным тогда и только тогда, когда оба простых логических выражения имеют одинаковую истинность.\n
«A ↔ B» истинно тогда и только тогда, когда А и B равны.\n
Обозначение: F = A ↔ B.\n
Таблица истинности для эквивалентности\n

A	B	F\n
1	1	1\n
1	0	0\n
0	1	0\n
0	0	1\n\n

6) Операция XOR (исключающие или)\n
«A ⊕ B» истинно тогда, когда истинно А или B, но не оба одновременно.\n
Эту операцию также называют "сложение по модулю два".\n
Обозначение: F = A ⊕ B.\n
A	B	F\n
1	1	0\n
1	0	1\n
0	1	1\n
0	0	0\n\n

Порядок выполнения логических операций в сложном логическом выражении\n

1. Инверсия;\n
2. Конъюнкция;\n
3. Дизъюнкция;\n
4. Импликация;\n
5. Эквивалентность.\n\n

Логическая операция — в программировании операция над выражениями логического (булевского) типа, соответствующая некоторой операции над высказываниями в алгебре логики. Как и высказывания, логические выражения могут принимать одно из двух истинностных значений — «истинно» или «ложно». Логические операции служат для получения сложных логических выражений из более простых. В свою очередь, логические выражения обычно используются как условия для управления последовательностью выполнения программы.\n
В некоторых языках программирования (например, в языке Си) вместо логического типа или одновременно с ним используются числовые типы. В этом случае считается, что отличное от нуля значение соответствует логической истине, а ноль — логической лжи.\n
Значение отдельного бита также можно рассматривать как логическое, если считать, что 1 означает «истинно», а 0 — «ложно». Это позволяет применять логические операции к отдельным битам, к битовым векторам покомпонентно и к числам в двоичном представлении поразрядно. Такое одновременное применение логической операции к последовательности битов осуществляется с помощью побитовых логических операций. Побитовые логические операции используются для оперирования отдельными битами или группами битов, применяются для наложения битовых масок, выполнения различных арифметических вычислений.\n
Среди логических операций наиболее известны конъюнкция (&amp;&amp;), дизъюнкция (||), отрицание (!). Их нередко путают с битовыми операциями, хотя это разные вещи\n\n

Логические основы компьютеров\n
Компьютер состоит из элементов, связанных между собой и взаимодействующих во время его работы. Каждый элемент выполняет определенную операцию. Машинные элементы делятся на логические, запоминающие и вспомогательные. Логические элементы обеспечивают выполнение арифметических и логических операций; запоминающие элементы предназначаются для хранения информации, а вспомогательные элементы предназначаются для формирования стандартных сигналов и согласования работы всех элементов.\n
Информация, которую обрабатывает компьютер, может быть представлена в виде высказываний, в которых что-либо утверждается или отрицается. Высказывание — это любое предложение, в отношении которого имеет смысл утверждение об его истинности или ложности. При этом считается, что высказывание не может быть одновременно и истинным, и ложным. Примеры высказываний: "Май — весенний месяц" — это истинное утверждение; "2+3=6" — ложное утверждение. Разумеется, не всякое предложение является логическим высказыванием. Например, "Вася — самый высокий человек" — это утверждение может быть как истинным, так и ложным.\n
Наука, в которой с помощью формальных правил определяет истинность или ложность высказывания называется логикой. В алгебре логики все высказывания обозначаются буквами а, b, с и т. д., что позволяет манипулировать ими подобно тому, как в математике манипулируют обычными переменными, принимающие лишь два значения ИСТИНА (true) или ЛОЖЬ (false).\n
Переменные и функции, принимающие значение 0 (false) или 1 (true) носят название логических или булевских по имени английского математика Джорджа Буля (1815-1864), основателя математической логики.\n
При записи тех или иных логических выражений используется специальный язык, который принят в математической логике\n
X	not X\n

Основой цифровой техники служат три логические операции, лежащие в основе всех выводов компьютера. Иногда эти операции И, ИЛИ, НЕ называют "тремя китами машинной логики".\n
</item>
        <!--50-->
        <item>50.ГРАФЫ. ОРИЕНТИРОВАННЫЕ И НЕОРИЕНТИРОВАННЫЕ ГРАФЫ.\n\n\n\n\n\n
Граф — абстрактный математический объект, представляющий собой множество вершин графа и набор рёбер, то есть соединений между парами вершин. Например, за множество вершин можно взять множество аэропортов, обслуживаемых некоторой авиакомпанией, а за множество рёбер взять регулярные рейсы этой авиакомпании между городами.\n
Для разных областей применения виды графов могут различаться направленностью, ограничениями на количество связей и дополнительными данными о вершинах или рёбрах. Многие структуры, представляющие практический интерес в математике и информатике, могут быть представлены графами.\n
Графы являются основным объектом изучения теории графов.\n\n
Граф, или неориентированный граф G  — это упорядоченная пара  G := (V,E), где  V — непустое множество вершин или узлов, а E — множество пар (в случае неориентированного графа — неупорядоченных) вершин, называемых рёбрами.\n
V (а значит и, E, иначе оно было бы мультимножеством) обычно считаются конечными множествами. Многие результаты, полученные для конечных графов, неверны (или каким-либо образом отличаются) для бесконечных графов, поскольку не все утверждения, имеющие место для конечных совокупностей, выполняются в случае бесконечных множеств.\n\n
Ориентированный граф\n
Ориентированный граф (сокращённо орграф) G — это упорядоченная пара G := (V,A), где V — непустое множество вершин или узлов, и A — множество (упорядоченных) пар различных вершин, называемых дугами или ориентированными рёбрами. Пусть (v,w) — это дуга. Тогда вершину v называют её началом, а w — концом. Можно сказать, что дуга v → w ведёт от вершины v к вершине w.\n
</item>
        <!--51-->
        <item>51.КОНЕЧНЫЕ АВТОМАТЫ.\n\n\n\n\n\n\n
Конечный автомат — это некоторая абстрактная модель, содержащая конечное число состояний чего-либо. Используется для представления и управления потоком выполнения каких-либо команд. Конечный автомат идеально подходит для реализации искусственного интеллекта в играх, получая аккуратное решение без написания громоздкого и сложного кода.\n\n
Описание состояний автомата\n
Конечный автомат можно представить в виде графа, вершины которого являются состояниями, а ребра — переходы между ними. Каждое ребро имеет метку, информирующую о том, когда должен произойти переход. Например, на изображении выше видно, что автомат сменит состояние «wander» на состояние «attack» при условии, что игрок находится рядом.\n\n
FSM – это абстракция, которая используется для создания логики, в том числе и игровой. Например, обычно любой объект АИ это FSM, разного рода анимации обычно можно описать как FSM. Да и само состояние игры обычно описывается именно как ФСМ. Само название Finite-state machine говорит о том, что состояний имеется конечное количество и потому программист может каждое из них описать и задать поведение объекта (будь то монстр, космический корабль или состояние игры) в данном состоянии. В общем, ФСМ это штука нужная и полезная, и потому нам надо будет разобраться как её использовать на практике.\n\n
FSM\n
Фактически, FSM это просто некий “автомат”, который может иметь какие-то различные состояния и в один момент времени может находиться лишь в одном из этих состояний. Например, если враг может просто ходить по уровню, может атаковать игрока, а так же может прятаться, то его поведение легко задаётся с помощью Finite-state machine с тремя состояниями: иду, атакую, прячусь. Если мы опишем действия, которые должен выполнять враг в каждом из этих трёх состояний, а потом будем переключать их по каким-то законам (или случайным образом) – у игрока возникнет ощущение, что враг наделён каким-то интеллектом.\n\n
FSM transition table\n
В играх (да и не только) чаще всего описываются не только возможные состояния FSM, но и правила (условия) перехода FSM из одного состояния в другое. Чаще всего при проектировании эти правила представляются в виде таблицы перехода состояний и потому таблицу эту называют “state transition table”, явно намекая на то, что она задаёт как будет осуществляться переход (transition) из одного состояния FSM в другое её состояние. Ну, например, простая таблица FSM может выглядеть так:\n
Состояние конечное/исходное	Прогулка	Атака\n
Вижу врага	Атака	-\n
Не вижу врага	-	Прогулка\n\n
Работать FSM по этой таблице будет примерно так:\n
Текущее состояние: Прогулка\n
Вижу врага? Да. Перехожу в состояние “Атака”\n\n
Текущее состояние: Атака\n
Вижу врага? Нет. Перехожу в состояние “Прогулка”\n\n
Текущее состояние: Прогулка\n
Вижу врага? Нет. Не меняю состояние.\n\n
Текущее состояние: Атака\n
Вижу врага? Да. Не меняю состояние.\n\n
Иными словами, FSM принимает данные (например, данные об игровом мире) и, основываясь на них, может менять (либо не менять) своё текущее состояние.\n\n
FSM, вход и выход из состояний\n
Для удобства работы, обычно каждому состоянию FSM так же задают 2 дополнительных функции: функцию входа в состояние и функцию выхода из состояния. Причин для их использования можно найти много, я же приведу лишь одну: эти функции позволяют “подготовить” объект к входу в состояние, либо к выходу их него. Что бы это не звучало банально, приведу несколько примеров:\n

При входе в состояние “иду”, мы можем загрузить анимацию ходьбы\n
При выходе из состояния “иду” мы можем выгрузить эту анимацию, поскольку она нам больше не нужна\n
При входе в состояние “прячусь” мы можем запомнить: куда мы решили спрятаться, от кого мы прячемся, каким путём мы решили пройти в выбранную нами точку-нычку )))\n
В случае, если ФСМ не является отдельной сущностью, а является частью объекта, часто добавляется ещё одна функция – функция “исполнения” состояния. Например, эта функция может переключать “кадры” анимации, для получения плавной ходьбы или реализовывать какой-то AI, либо и то и другое вместе.\n\n

Методы реализации FSM\n
Есть два наиболее часто применяемых метода реализации FSM:\n
Статический FSM. Поведение Finite-state machine определяется на стадии компиляции программы и не может изменяться в runtime. Этот метод обеспечивает наибольшее быстродействие и он проще в реализации.\n
Динамический метод реализации FSM. Поведение машины состояний может изменяться runtime путём добавления или удаления (включения/выключения) возможных состояний FSM. Гораздо более гибкий метод, но он значительно сложнее в реализации и используется достаточно редко.\n
</item>
        <!--52-->
        <item>52.СИСТЕМА. ВИДЫ ОПРЕДЕЛЕНИЙ. СВОЙСТВА СИСТЕМ.\n\n\n\n\n\n
Систе́ма (др.-греч. σύστημα «целое, составленное из частей; соединение») — множество элементов, находящихся в отношениях и связях друг с другом, которое образует определённую целостность, единство.\n\n
Сведение множества к единому — в этом первооснова красоты.\n
Пифагор\n\n
Потребность в использовании термина «система» возникает в тех случаях, когда нужно подчеркнуть, что что-то является большим, сложным, не полностью сразу понятным, при этом целым, единым. В отличие от понятий «множество», «совокупность» понятие системы подчёркивает упорядоченность, целостность, наличие закономерностей построения, функционирования и развития.\n
В повседневной практике слово «система» может употребляться в различных значениях, в частности:\n
•	теория, например, философская система Платона;\n
•	классификация, например, периодическая система химических элементов Д. И. Менделеева;\n
•	метод практической деятельности, например, система Станиславского;\n
•	способ организации мыслительной деятельности, например, система счисления;\n
•	совокупность объектов природы, например, Солнечная система;\n
•	некоторое свойство общества, например, политическая система, экономическая система и т. п.;\n
•	совокупность установившихся норм жизни и правил поведения, например, правовая система или система моральных ценностей;\n
•	закономерность («в его действиях прослеживается система»);\n
•	конструкционный принцип («оружие новой системы»);\n
•	и др.\n\n
Изучением систем занимаются такие инженерные и научные дисциплины как общая теория систем, системный анализ, системология, кибернетика, системная инженерия, термодинамика, ТРИЗ, системная динамика и т. д.\n\n

Определения системы\n
Существует по меньшей мере несколько десятков различных определений понятия «система», используемых в зависимости от контекста, области знаний и целей исследования. Основной фактор, влияющий на различие в определениях, состоит в том, что в понятии «система» есть двойственность: с одной стороны оно используется для обозначения объективно существующих феноменов, а с другой стороны — как метод изучения и представления феноменов, то есть как субъективная модель реальности.\n
В связи с этой двойственностью авторы определений пытались решить две различные задачи: (1) как объективно отличить «систему» от «несистемы» и (2) как выделить некоторую систему из окружающей среды. На основе первого подхода давалось дескриптивное (описательное) определение системы, на основе второго — конструктивное, иногда они сочетаются.\n
Так, данное в преамбуле определение из Большого Российского энциклопедического словаря является типичным дескриптивным определением. Другие примеры дескриптивных определений:\n
•	Система — комплекс взаимодействующих компонентов (Л. фон Берталанфи)\n
•	Система — совокупность элементов, находящихся в определённых отношениях друг с другом и со средой (Л. фон Берталанфи).\n
•	Система — множество взаимосвязанных элементов, обособленное от среды и взаимодействующее с ней, как целое (Ф. И. Перегудов, Ф. П. Тарасенко).\n
Дескриптивные определения характерны для раннего периода системной науки, при котором в них включали только элементы и связи. Затем, в процессе развития представлений о системе, стали учитывать её цель (функцию), а в последующем — и наблюдателя (лицо, принимающее решение, исследователя, проектировщика и т. п.). Таким образом, современное представление о системе подразумевает наличие функции, или цели системы с точки зрения наблюдателя или исследователя, который при этом явно или неявно вводится в определение.\n\n
Примеры конструктивных определений:\n
•	Система — комбинация взаимодействующих элементов, организованных для достижения одной или нескольких поставленных целей.\n
•	Система — конечное множество функциональных элементов и отношений между ними, выделенное из среды в соответствии с определённой целью в рамках определённого временного интервала (В. Н. Сагатовский).\n
•	Система — отражение в сознании субъекта (исследователя, наблюдателя) свойств объектов и их отношений в решении задачи исследования, познания (Ю. И. Черняк).\n
•	Система S на объекте А относительно интегративного свойства (качества) есть совокупность таких элементов, находящихся в таких отношениях, которые порождают данное интегративное свойство (Е. Б. Агошкова, Б. В. Ахлибининский).\n
•	Система — совокупность интегрированных и регулярно взаимодействующих или взаимозависимых элементов, созданная для достижения определённых целей, причём отношения между элементами определены и устойчивы, а общая производительность или функциональность системы лучше, чем у простой суммы элементов (PMBOK).\n
При исследовании некоторых видов систем дескриптивные определения системы считаются допустимыми; так, вариант теории систем Ю. А. Урманцева, созданный им для исследования относительно невысоко развитых биологических объектов типа растений, не включает понятие цели как несвойственное для этого класса объектов].\n\n
Выделяют следующиеосновные свойства системы:\n
· Система есть совокупность элементов. При определенных условиях элементы могут рассматриваться как системы.\n
· Наличие существенных связей между элементами.Под существенными связями понимаются такие, которые закономерно, с необходимостью определяют интегративные свойства системы.\n
· Наличие определенной организации, что проявляется в снижении степени неопределенности системы по сравнению с энтропией системоформирующих факторов, определяющих возможность создания системы. К этим факторам относят число элементов системы, число существенных связей, которыми может обладать элемент.\n
· Наличие интегративных свойств, т.е. присущих системе в целом, но не свойственных ни одному из ее элементов в отдельности. Их наличие показывает, что свойства системы, хотя и зависят от свойств элементов, но не определяются ими полностью. Система не сводится к простой совокупности элементов; декомпозируя систему на отдельные части, нельзя познать все свойства системы в целом.\n
· Эмерджентностъ – несводимость свойств отдельных элементов и свойств системы в целом.\n
· Целостность– это общесистемное свойство, заключающееся в том, что изменение любого компонента системы оказывает воздействие на все другие ее компоненты и приводит к изменению системы в целом; и наоборот, любое изменение системы отзывается на всех компонентах системы.\n
· Делимость– возможна декомпозиция системы на подсистемы с целью упрощения анализа системы.\n
· Коммуникативность. Любая система функционирует в окружении среды, она испытывает на себе воздействия среды и, в свою очередь, оказывает влияние на среду. Взаимосвязь среды и системы можно считать одной из основных особенностей функционирования системы, внешней характеристикой системы, в значительной степени определяющей ее свойства.\n
· Системе присуще свойство развиваться,адаптироваться к новым условиям путем создания новых связей, элементов со своими локальными целями и средствами их достижения. Развитие – объясняет сложные термодинамические и информационные процессы в природе и обществе.\n
· Иерархичность. Под иерархиейпонимается последовательная декомпозиция исходной системы на ряд уровней с установлением отношения подчиненности нижележащих уровней вышележащим. Иерархичность системысостоит в том, что она может быть рассмотрена как элемент системы более высокого порядка, а каждый ее элемент, в свою очередь, является системой.\n
· Важным системным свойством является системная инерция,определяющая время, необходимое для перевода системы из одного состояния в другое при заданных параметрах управления.\n
· Многофункциональность– способность сложной системы к реализации некоторого множества функций на заданной структуре, которая проявляется в свойствах гибкости, адаптации и живучести.\n
· Гибкость– это свойство системы изменять цель функционирования в зависимости от условий функционирования или состояния подсистем.
· Адаптивность– способность системы изменять свою структуру и выбирать варианты поведения сообразно с новыми целями системы и под воздействием факторов внешней среды. Адаптивная система – такая, в которой происходит непрерывный процесс обучения или самоорганизации.\n
· Надежность – это свойство системы реализовывать заданные функции в течение определенного периода времени с заданными параметрами качества.
· Безопасность – способность системы не наносить недопустимые воздействия техническим объектам, персоналу, окружающей среде при своем функционировании.\n
· Уязвимость– способность получать повреждения при воздействии внешних и (или) внутренних факторов.\n
· Структурированность – поведение системы обусловлено поведением ее элементов и свойствами ее структуры.\n
· Динамичность – это способность функционировать во времени.\n
· Наличие обратной связи.\n
</item>
        <!--53-->
        <item>53.МАТЕМАТИЧЕСКОЕ МОДЕЛИРОВАНИЕ.\n\n\n\n\n
Математическое моделирование - это средство изучения реального объекта, процесса или системы путем их замены математической моделью, более удобной для экспериментального исследования с помощью ЭВМ.\n
Математическая модель является приближенным представлением реальных объектов, процессов или систем, выраженным в математических терминах и сохраняющим существенные черты оригинала. Математические модели в количественной форме, с помощью логико-математических конструкций, описывают основные свойства объекта, процесса или системы, его параметры, внутренние и внешние связи.\n
В общем случае математическая модель реального объекта, процесса или системы представляется в виде системы функционалов\n
Фi (X,Y,Z,t)=0,\n
где X - вектор входных переменных, X=[x1,x2,x3, ... , xN]t,\n
Y - вектор выходных переменных, Y=[y1,y2,y3, ... , yN]t,\n
Z - вектор внешних воздействий, Z=[z1,z2,z3, ... , zN]t,\n
t - координата времени.\n
Построение математической модели заключается в определении связей между теми или иными процессами и явлениями, создании математического аппарата, позволяющего выразить количественно и качественно связь между теми или иными процессами и явлениями, между интересующими специалиста физическими величинами, и факторами, влияющими на конечный результат.\n
Обычно их оказывается настолько много, что ввести в модель всю их совокупность не удается. При построении математической модели перед исследованием возникает задача выявить и исключить из рассмотрения факторы, несущественно влияющие на конечный результат (математическая модель обычно включает значительно меньшее число факторов, чем в реальной действительности). На основе данных эксперимента выдвигаются гипотезы о связи между величинами, выражающими конечный результат, и факторами, введенными в математическую модель. Такая связь зачастую выражается системами дифференциальных уравнений в частных производных (например, в задачах механики твердого тела, жидкости и газа, теории фильтрации, теплопроводности, теории электростатического и электродинамического полей).\n
Конечной целью этого этапа является формулирование математической задачи, решение которой с необходимой точностью выражает результаты, интересующие специалиста.\n
Форма и принципы представления математической модели зависит от многих факторов.\n\n
По принципам построения математические модели разделяют на:\n
1. аналитические;\n
2. имитационные.\n
В аналитических моделях процессы функционирования реальных объектов, процессов или систем записываются в виде явных функциональных зависимостей.\n\n
Аналитическая модель разделяется на типы в зависимости от математической проблемы:\n
1. уравнения (алгебраические, трансцендентные, дифференциальные, интегральные),\n
2. аппроксимационные задачи (интерполяция, экстраполяция, численное интегрирование и дифференцирование),\n
3. задачи оптимизации,\n
4. стохастические проблемы.\n
Однако по мере усложнения объекта моделирования построение аналитической модели превращается в трудноразрешимую проблему. Тогда исследователь вынужден использовать имитационное моделирование.\n
В имитационном моделировании функционирование объектов, процессов или систем описывается набором алгоритмов. Алгоритмы имитируют реальные элементарные явления, составляющие процесс или систему с сохранением их логической структуры и последовательности протекания во времени. Имитационное моделирование позволяет по исходным данным получить сведения о состояниях процесса или системы в определенные моменты времени, однако прогнозирование поведения объектов, процессов или систем здесь затруднительно. Можно сказать, что имитационные модели - это проводимые на ЭВМ вычислительные эксперименты с математическими моделями, имитирующими поведение реальных объектов, процессов или систем.\n
В зависимости от характера исследуемых реальных процессов и систем математические модели могут быть:\n
1. детерминированные,\n
2. стохастические.\n
В детерминированных моделях предполагается отсутствие всяких случайных воздействий, элементы модели (переменные, математические связи) достаточно точно установленные, поведение системы можно точно определить. При построении детерминированных моделей чаще всего используются алгебраические уравнения, интегральные уравнения, матричная алгебра.\n
Стохастическая модель учитывает случайный характер процессов в исследуемых объектах и системах, который описывается методами теории вероятности и математической статистики.\n\n
По виду входной информации модели разделяются на:\n
1. непрерывные,\n
2. дискретные.\n
Если информация и параметры являются непрерывными, а математические связи устойчивы, то модель - непрерывная. И наоборот, если информация и параметры - дискретны, а связи неустойчивы, то и математическая модель - дискретная.\n
По поведению моделей во времени они разделяются на:\n
1. статические,\n
2. динамические.\n
Статические модели описывают поведение объекта, процесса или системы в какой-либо момент времени. Динамические модели отражают поведение объекта, процесса или системы во времени.\n
По степени соответствия между математической моделью и реальным объектом, процессом или системой математические модели разделяют на:
1. изоморфные (одинаковые по форме),\n
2. гомоморфные (разные по форме).\n\n
Модель называется изоморфной, если между нею и реальным объектом, процессом или системой существует полное поэлементное соответствие.\n Гомоморфной - если существует соответствие лишь между наиболее значительными составными частями объекта и модели.\n
Математические модели в количественной форме, с помощью логико-математических конструкций, описывают основные свойства объекта, процесса или системы, его параметры, внутренние и внешние связи.\n\n
Для построения математической модели необходимо:\n
1. тщательно проанализировать реальный объект или процесс;\n
2. выделить его наиболее существенные черты и свойства;\n
3. определить переменные, т.е. параметры, значения которых влияют на основные черты и свойства объекта;\n
4. описать зависимость основных свойств объекта, процесса или системы от значения переменных с помощью логико-математических соотношений (уравнения, равенства, неравенства, логико-математические конструкций);\n
5. выделить внутренние связи объекта, процесса или системы с помощью ограничений, уравнений, равенств, неравенств, логико-математических конструкций;\n
6. определить внешние связи и описать их с помощью ограничений, уравнений, равенств, неравенств, логико-математических конструкций.\n
Математическое моделирование, кроме исследования объекта, процесса или системы и составления их математического описания, также включает:
1. построение алгоритма, моделирующего поведение объекта, процесса или системы;\n
2. проверка адекватности модели и объекта, процесса или системы на основе вычислительного и натурного эксперимента;\n
3. корректировка модели;\n
4. использование модели.\n
Математическое описание исследуемых процессов и систем зависит от:\n
1. природы реального процесса или системы и составляется на основе законов физики, химии, механики, термодинамики, гидродинамики, электротехники, теории пластичности, теории упругости и т.д.\n
2. требуемой достоверности и точности изучения и исследования реальных процессов и систем.\n\n
На этапе выбора математической модели устанавливаются: линейность и нелинейность объекта, процесса или системы, динамичность или статичность, стационарность или нестационарность, а также степень детерминированности исследуемого объекта или процесса. При математическом моделировании сознательно отвлекаются от конкретной физической природы объектов, процессов или систем и, в основном, сосредотачиваются на изучении количественных зависимостей между величинами, описывающими эти процессы.\n
Математическая модель никогда не бывает полностью тождественна рассматриваемому объекту, процессу или системе. Основанная на упрощении, идеализации она является приближенным описанием объекта. Поэтому результаты, полученные при анализе модели, носят приближенный характер. Их точность определяется степенью адекватности (соответствия) модели и объекта.\n
Построение математической модели обычно начинается с построения и анализа простейшей, наиболее грубой математической модели рассматриваемого объекта, процесса или системы. В дальнейшем, в случае необходимости, модель уточняется, делается ее соответствие объекту более полным.\n
Возьмем простой пример. Нужно определить площадь поверхности письменного стола. Обычно для этого измеряют его длину и ширину, а затем перемножают полученные числа. Такая элементарная процедура фактически обозначает следующее: реальный объект (поверхность стола) заменяется абстрактной математической моделью – прямоугольником. Прямоугольнику приписываются размеры, полученные в результате измерения длины и ширины поверхности стола, и площадь такого прямоугольника приближенно принимается за искомую площадь стола.\n
Однако модель прямоугольника для письменного стола – это простейшая, наиболее грубая модель. При более серьезном подходе к задаче прежде, чем воспользоваться для определения площади стола моделью прямоугольника, эту модель нужно проверить. Проверки можно осуществить следующим образом: измерить длины противоположных сторон стола, а также длины его диагоналей и сравнить их между собой. Если, с требуемой степенью точности, длины противоположных сторон и длины диагоналей попарно равны между собой, то поверхность стола действительно можно рассматривать как прямоугольник. В противном случае модель прямоугольника придется отвергнуть и заменить моделью четырехугольника общего вида. При более высоком требовании к точности может возникнуть необходимость пойти в уточнении модели еще дальше, например, учесть закругления углов стола.\n
С помощью этого простого примера было показано, что математическая модель не определяется однозначно исследуемым объектом, процессом или системой. Для одного и того же стола мы можем принять либо модель прямоугольника, либо более сложную модель четырехугольника общего вида, либо четырехугольника с закругленными углами. Выбор той или иной модели определяется требованием точности. С повышением точности модель приходится усложнять, учитывая новые и новые особенности изучаемого объекта, процесса или системы.\n
Построение математической модели в прикладных задачах – один из наиболее сложных и ответственных этапов работы. Опыт показывает, что во многих случаях правильно выбрать модель – значит решить проблему более, чем наполовину. Трудность данного этапа состоит в том, что он требует соединения математических и специальных знаний. Поэтому очень важно, чтобы при решении прикладных задач математики обладали специальными знаниями об объекте, а их партнеры, специалисты, – определенной математической культурой, опытом исследования в своей области, знанием ЭВМ и программирования.\n
</item>
        <!--54-->
        <item>54.ИМИТАЦИОННОЕ МОДЕЛИРОВАНИЕ.\n\n\n\n\n
Имитационное моделирование является мощным инструментом исследования поведения реальных систем. Методы имитационного моделирования позволяют собрать необходимую информацию о поведении системы путем создания ее компьютерной модели. Эта информация используется затем для проектирования системы.\n
Цель имитационного моделирования состоит в воспроизведении поведения исследуемой системы на основе результатов анализа наиболее существенных взаимосвязей между ее элементами в предметной области для проведения различных экспериментов.\n
Имитационное моделирование позволяет имитировать поведение системы во времени. Причём плюсом является то, что временем в модели можно управлять: замедлять в случае с быстропротекающими процессами и ускорять для моделирования систем с медленной изменчивостью. Можно имитировать поведение тех объектов, реальные эксперименты с которыми дороги, невозможны или опасны.\n\n
К имитационному моделированию прибегают, когда:\n
1. Дорого или невозможно экспериментировать на реальном объекте.\n
2. Невозможно построить аналитическую модель: в системе есть время, причинные связи, последствие, нелинейности, стохастические (случайные) переменные.\n
3. Необходимо сымитировать поведение системы во времени.\n
Имитация, как метод решения нетривиальных задач, получила начальное развитие в связи с созданием ЭВМ в 1950х — 1960х годах.\n\n
Можно выделить две разновидности имитации:\n
1. Метод Монте-Карло (метод статистических испытаний);\n
2. Метод имитационного моделирования (статистическое моделирование).\n\n
В настоящее время выделяют три направления имитационных моделей:\n
1. Агентное моделирование — относительно новое (1990е-2000е гг.) направление в имитационном моделировании, которое используется для исследования децентрализованных систем, динамика функционирования которых определяется не глобальными правилами и законами (как в других парадигмах моделирования), а наоборот. Когда эти глобальные правила и законы являются результатом индивидуальной активности членов группы.\n
Цель агентных моделей — получить представление об этих глобальных правилах, общем поведении системы, исходя из предположений об индивидуальном, частном поведении ее отдельных активных объектов и взаимодействии этих объектов в системе. Агент — некая сущность, обладающая активностью, автономным поведением, может принимать решения в соответствии с некоторым набором правил, взаимодействовать с окружением, а также самостоятельно изменяться.\n\n
2. Дискретно-событийное моделирование — подход к моделированию, предлагающий абстрагироваться от непрерывной природы событий и рассматривать только основные события моделируемой системы, такие как: «ожидание», «обработка заказа», «движение с грузом», «разгрузка» и другие. Дискретно-событийное моделирование наиболее развито и имеет огромную сферу приложений — от логистики и систем массового обслуживания до транспортных и производственных систем. Этот вид моделирования наиболее подходит для моделирования производственных процессов.\n\n
3. Системная динамика — парадигма моделирования, где для исследуемой системы строятся графические диаграммы причинных связей и глобальных влияний одних параметров на другие во времени, а затем созданная на основе этих диаграмм модель имитируется на компьютере. По сути, такой вид моделирования более всех других парадигм помогает понять суть происходящего выявления причинно-следственных связей между объектами и явлениями. С помощью системной динамики строят модели бизнес-процессов, развития города, модели производства, динамики популяции, экологии и развития эпидемии.\n\n
Имитационное моделирование основано на воспроизведении с помощью компьютеров развернутого во времени процесса функционирования системы с учетом взаимодействия с внешней средой.\n
Основой всякой имитационной модели (ИМ) является:\n
· разработка модели исследуемой системы на основе частных имитационных моделей (модулей) подсистем, объединенных своими взаимодействиями в единое целое;\n
· выбор информативных (интегративных) характеристик объекта, способов их получения и анализа;\n
· построение модели воздействия внешней среды на систему в виде совокупности имитационных моделей внешних воздействующих факторов;\n
· выбор способа исследования имитационной модели в соответствии с методами планирования имитационных экспериментов (ИЭ).\n\n
Основными методами имитационного моделирования являются: аналитический метод, метод статического моделирования и комбинированный метод (аналитико-статистический) метод.\n
Аналитический метод применяется для имитации процессов в основном для малых и простых систем, где отсутствует фактор случайности. Метод назван условно, так как он объединяет возможности имитации процесса, модель которого получена в виде аналитически замкнутого решения, или решения полученного методами вычислительной математики.\n
Метод статистического моделирования первоначально развивался как метод статистических испытаний (Монте-Карло). Это – численный метод, состоящий в получении оценок вероятностных характеристик, совпадающих с решением аналитических задач (например, с решением уравнений и вычислением определенного интеграла). В последствии этот метод стал применяться для имитации процессов, происходящих в системах, внутри которых есть источник случайности или которые подвержены случайным воздействиям. Он получил название метода статистического моделирования.\n
Комбинированный метод (аналитико-статистический) позволяет объединить достоинства аналитического и статистического методов моделирования. Он применяется в случае разработки модели, состоящей из различных модулей, представляющих набор как статистических так и аналитических моделей, которые взаимодействуют как единое целое. Причем в набор модулей могут входить не только модули соответствующие динамическим моделям, но и модули соответствующие статическим математическим моделям.\n
</item>
        <!--55-->
        <item>55.НАДЕЖНОСТЬ ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ.\n\n\n\n\n\n
Решение любой задачи, выполнение любой функции, возложенной на ЭВМ, возможно только при соответствующем взаимодействии и функционировании аппаратурных и программных средств вычислительной машины. Поэтому при анализе надежности выполнения ЭВМ заданных функций ЭВМ следует рассматривать как единый комплекс аппаратурных и программных средств и учитывать, что надежность работы ЭВМ зависит не только от надежности аппаратуры, но и от надежности программного обеспечения.\n
По аналогии с терминологией, принятой для надежности технических средств, под надежностью программного обеспечения (ПО) будем понимать свойство выполнять заданные функции, сохранять свои характеристики в установленных пределах при определенных условиях эксплуатации.\n
Надежность программного обеспечения (или просто программы) определяется его (ее) безотказностью и восстанавливаемостью. Безотказность программы или программного обеспечения есть ее (его) свойство сохранять работоспособность при использовании в процессе обработки информации на ЭВМ.\n
Надежность программного обеспечения отличается от надежности аппаратуры на этапе пробной эксплуатации. Во время пробной эксплуатации разработчик аппаратуры обычно знает свойства заменяемой детали или элемента. Программист же обычно не знает многого о свойствах переделанной части программы и о том, как она будет взаимодействовать с остальной частью программы. Вполне возможно, что вводится новый источник ошибок при попытке улучшить программу.\n
Безотказность программного обеспечения можно оценить вероятностью его работы без отказов при определенных уровнях внешней среды в течение заданного периода наблюдения. В данном определении под отказом программы или системы программного обеспечения понимается недопустимое отклонение характеристик процесса функционирования программы от требуемых. Определенные условия внешней среды понимаются как совокупность входных данных и состояния вычислительной системы. Заданный период наблюдений соответствует, как правило, необходимому для выполнения решаемой на машине задачи.\n
Безотказность программного средства можно также характеризовать средним временем между возникновениями отказов в функционировании программы. При этом предполагается, что аппаратура ЭВМ находится полностью в работоспособном состоянии.\n
С точки зрения надежности принципиальное отличие программного обеспечения от аппаратуры состоит в том, что программы не изнашиваются и, следовательно, их выход из строя из-за поломки невозможен. Поэтому характеристики функционирования программного обеспечения зависят только от его качества, предопределяемого процессом разработки.\n
Безотказность программного обеспечения определяется его корректностью (правильностью) и, следовательно, целиком зависит от наличия в нем ошибок, внесенных на этапах его создания, в то время как безотказность аппаратуры определяется в основном случайными отказами, зависящими от изменений параметров аппаратуры, происходящих во время эксплуатации.\n
Надежность (или лучше безотказность) аппаратуры и программного обеспечения существенно по-разному зависит от входных данных и времени функционирования системы. Обрабатываемые данные, как правило, не влияют на отказы аппаратуры. Процесс выхода из строя отдельных элементов аппаратуры не зависит от поступающих входных данных. В то же время проявление ошибок программного обеспечения связано с тем, что в некоторые моменты времени на обработку поступают ранее не встречавшиеся совокупности данных, которые программа не в состоянии корректно обработать. Таким образом, входные данные в значительной мере влияют на функционирование программного обеспечения.\n
Интенсивность отказов аппаратуры по существу зависит от времени эксплуатации. Увеличение надежности программы является следствием того, что в процессе эксплуатации обнаруживаются и устраняются скрытые ошибки программы.\n
Важной характеристикой надежности программного обеспечения является его восстанавливаемость, которая определяется затратами времени и труда на устранение отказа из-за проявившейся ошибки в программе и его последствий. Восстановление после отказа в программе может заключаться в корректировке и восстановлении текста программы, исправлении данных, внесении изменений в организацию вычислительного процесса, что часто оказывается необходимым при работе ЭВМ в реальном масштабе времени. Восстанавливаемость программного обеспечения может быть оценена средней продолжительностью устранения ошибки в программе и восстановления ее работоспособности. Восстанавливаемость программного обеспечения зависит от многих факторов, в том числе от сложности структуры комплекса программ, структурированности самих программ, алгоритмического языка, на котором разрабатывалась программа, стиля программирования, качества документации на программу и т. п.\n
Можно также говорить об устойчивости функционирования программного обеспечения, понимая под этим его способность ограничивать последствия собственных ошибок и неблагоприятных воздействий внешней среды (неисправности аппаратуры, некорректность входных данных, ошибки оператора и др.) или противостоять им.\n
Устойчивость программного обеспечения может быть повышена с помощью разных форм структурной, информационной и временной избыточности, позволяющих иметь дублирующие модули программ, альтернативные программы для решения одних и тех же задач, осуществлять контроль за процессом исполнения программ т. п.\n
</item>
        <!--56-->
        <item>56.ЭТАПЫ РАЗРАБОТКИ ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ.\n\n\n\n\n\n
Процесс разработки программного обеспечения можно разбить на этапы (фазы):\n
– содержательная постановка задачи;\n
– разработка модели и выбор метода решения;\n
– разработка алгоритма решения задачи;\n
– кодирование алгоритма;\n
– компиляция программы;\n
– тестирование программы;\n
– создание документации;\n
– сопровождение и эксплуатация.\n\n
Содержательная постановка задачи. Постановка задачи - это точная формулировка решения задачи на компьютере с описанием входной и выходной информации.\n
В результате выполнения этого этапа работы составляется документ, называемый "Задание на разработку программного обеспечения (техническое задание)". В нем указывается следующее:\n
– название задачи. Дается краткое определение решаемой задачи, название программного комплекса, указывается система программирования для ее реализации и требования к аппаратному обеспечению;\n
– описание. Подробно излагается постановка задачи, цель и назначение задачи, ее место и связи с другими задачами, содержание функций обработки входной информации при решении задачи, требования к периодичности решения задачи.\n
– управление режимами работы программы. Формулируются основные требования к способу взаимодействия пользователя с программой (интерфейс пользователь-компьютер).\n
– входные данные. Описываются входные данные, указываются пределы, в которых они могут изменяться, значения, которые они не могут принимать, и т. д., а также источник данных, т.е. устройство, с помощью которого они должны быть переданы в программу.\n
– выходные данные. Описываются выходные данные, указывается, в каком виде они должны быть представлены – в числовом, графическом или текстовом, ограничения по срокам и точности выходной информации, а также указывается устройство отображения этих данных.\n
– ошибки. Перечисляются возможные ошибки пользователя при работе с про-граммой (например, ошибки при вводе данных и др.). Указываются способы диагностики (в данном случае под диагностикой понимается обнаружение ошибок при работе программного комплекса) и защиты от этих ошибок на этапе проектирования, а также возможная реакция пользователя при совершении им ошибочных действий и реакция программного комплекса (компьютера) на эти действия.\n
– пример работы программного комплекса. Приводится один или несколько примеров работы программного комплекса, на которых в простейших случаях проводится его отладка и тестирование.\n
Разработка модели и выбор метода решения. На этом этапе создается математическая или логическая модель исследуемого явления реального мира. При этом нужно уметь сформулировать на языке математики конкретные задачи физики, экономики, технологии и т.д. После того как определена математическая модель задачи, надо выбрать метод ее решения. Если программируемая задача носит вычислительный характер, то приводится вывод всех используемых формул с подробными комментариями. Если же задача невычислительная, то приводится словесное описание логической модели, например, в виде плана действий.\n
Разработка алгоритма решения задачи. На этом этапе формируется общая структура программного комплекса. Алгоритм – это система точно сформулированных правил, определяющая процесс преобразования допустимых исходных данных (входной информации) в желаемый результат (выходную информацию) за конечное число шагов.\n
В процессе разработки алгоритма могут быть использованы различные способы его описания: словесная запись, блок-схемы, псевдокод, структурограммы и т.п.\n
Предложения, не являющееся предложением какого-то языка программирования, хотя и очень напоминает то, что мы пишем на данном языке программирования, называют псевдокодом. Псевдокод очень эффективен при разработке логики программы. После того как логика покажется вам правильной, вы можете обратить особое внимание на детали перевода псевдокода на реальный язык программирования. Преимущество использования псевдокода состоит в том, что он позволяет сконцентрироваться на логике и структуре программы, не заботясь пока о способе перевода этих идей на язык машины. Если мы хотим улучшить программу, нам в первую очередь необходимо улучшить алгоритм!\n
Кодирование алгоритма. Этап кодирования (программирования) алгоритмов заключается в переводе алгоритмов, разработанных для каждого программного модуля, в программы на конкретном языке программирования. Результатом выполнения этого этапа являются файлы с исходными текстами программ. Эти файлы по своей природе текстовые, только они содержат тексты, написанные на языке программирования (в нашем случае это тексты, написанные на языке Си).\n
Компиляция программы. После того как закончено кодирование (написание программы на языке программирования) и исходный текст программы введен в память компьютера, производят компилирование программы, т.е. перевод исходного текста в машинный код. Этот процесс осуществляется специальной программой – компилятором.\n
Сначала программа передается препроцессору, который выполняет директивы, содержащиеся в ее тексте (например, #include - включение файла в текст программы).\n
Получившийся текст передается на вход компилятора (Compiler), который выделяет лексемы (отдельные слова), а затем на основе грамматики языка распознает выражения и операторы, построенные из этих лексем. При этом компилятор выявляет синтаксические ошибки и в случае их отсутствия строит объектный модуль.\n
Компоновщик, или редактор связей (Linker), формирует исполняемый модуль программы, подключая к объектному модулю другие объектные модули, в том числе содержащие функции библиотек, обращение к которым содержится в любой программе. При успешном завершении процесса образуется исполняемый файл программы (файл с расширением EXE).\n
Тестирование программы. Различается два вида тестирования: автономное и комплексное. При автономном тестированию подвергаются отдельные программные модули, из которых состоит программный комплекс. Комплексное тестирование заключается в проверке всего программного комплекса. Для тестирования подбираются такие исходные данные, для которых результат выполнения программы заранее известен.\n
Создание документации. Документация классифицируется по своему назначению и может быть разбита на несколько групп: описание применения, руководство пользователя, руководство программиста.\n
Описание применения – общая характеристика программного продукта и сферы его применения, требований к базовому программному обеспечению, комплексу технических средств обработки.\n
Руководство пользователя – детальное описание функциональных возможностей и технологии работы с программным продуктом для конечного пользователя. Документы данного вида могут оформляться в печатном виде и (или) "встраиваться" в программный комплекс (в последнем случае помощь в виде подсказки вызывается самим пользователем в процессе работы программного комплекса).\n
Руководство программиста предназначено для разработчиков программного обеспечения и специалистов, которые будут его сопровождать. В это руководство в качестве основных документов включаются:\n
- задание на разработку программного обеспечения (техническое задание);\n
- спецификация;\n
- прокомментированные исходные тексты (листинги) модулей программы и управляющего модуля;\n
- схема разбиения программного комплекса на программные модули;\n
- схема потоков данных программного комплекса;\n
- схема взаимодействия программных модулей;\n
- планы и данные для тестирования программного комплекса;\n
- другие материалы, иллюстрирующие проект, например: блок-схемы программного комплекса и программных модулей.\n
Сопровождение и эксплуатация. После завершения тестирования программного комплекса программное обеспечение сдается в эксплуатацию. В процессе эксплуатации может возникнуть необходимость добавления в программный комплекс новых функций, устранение ошибок, обнаруженных в процессе эксплуатации и т.д. Данный тип работ с программным комплексом в период его эксплуатации называется сопровождением.\n
</item>
        <!--57-->
        <item>57.ТРЕБОВАНИЯ К РАЗРАБОТКЕ ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ.\n\n\n\n\n\n
Требования к программному обеспечению — совокупность утверждений относительно атрибутов, свойств или качеств программной системы, подлежащей реализации. Создаются в процессе разработки требований к программному обеспечению, в результате анализа требований.
Требования могут выражаться в виде текстовых утверждений и графических моделей.\n
В классическом техническом подходе совокупность требований используется на стадии проектирования программного обеспечения (ПО). Требования также используются в процессе проверки ПО, так как тесты основываются на определённых требованиях.\n
Этапу разработки требований может предшествовать технико-экономическое обоснование или концептуальная фаза анализа проекта. Фаза разработки требований может быть разбита на выявление требований (сбор, понимание, рассмотрение и выяснение потребностей заинтересованных лиц), анализ (проверка целостности и законченности), спецификация (документирование требований) и проверка правильности.\n\n
 Виды требований по уровням \n
•	Бизнес-требования — определяют назначение ПО, описываются в документе о видении (vision) и границах проекта (scope).\n
•	Пользовательские требования — определяют набор пользовательских задач, которые должна решать программа, а также способы (сценарии) их решения в системе. Пользовательские требования могут выражаться в виде фраз утверждений, в виде сценариев использования (англ. use case), пользовательских историй (англ. user stories), сценариев взаимодействия (scenario).\n\n
Виды требований по характеру\n
•	Функциональный характер — требования к поведению системы\n
o	Бизнес-требования\n
o	Пользовательские требования\n
o	Функциональные требования\n
•	Нефункциональный характер — требования к характеру поведения системы\n
o	Бизнес-правила — определяют ограничения, проистекающие из предметной области и свойств автоматизируемого объекта (предприятия)\n
o	Системные требования и ограничения — определения элементарных операций, которые должна иметь система, а также различных условий, которым она может удовлетворять. К системным требованиям и ограничениям относятся:\n
	Ограничения на программные интерфейсы, в том числе к внешним системам\n
	Требования к атрибутам качества\n
	Требования к применяемому оборудованию и ПО\n
o	Требования к документированию\n
o	Требования к дизайну и юзабилити\n
o	Требования к безопасности и надёжности\n
o	Требования к показателям назначения (производительность, устойчивость к сбоям и т. п.)\n
o	Требования к эксплуатации и персоналу\n
o	Прочие требования и ограничения (внешние воздействия, мобильность, автономность и т. п.).\n\n
Источники требований \n
•	Законодательство (конституция, законы, распоряжения)\n
•	Нормативное обеспечение организации (регламенты, положения, уставы, приказы)\n
•	Текущая организация деятельности объекта автоматизации\n
•	Модели деятельности (диаграммы бизнес-процессов)\n
•	Представления и ожидания потребителей и пользователей системы\n
•	Журналы использования существующих программно-аппаратных систем\n
•	Конкурирующие программные продукты\n\n
Качество требований\n
Характеристики качества требований по-разному определены различными источниками. Однако, следующие характеристики являются общепризнанными:\n
Характеристика →→→ Объяснение\n
Единичность	→→→ Требование описывает одну и только одну вещь.\n
Завершённость	→→→ Требование полностью определено в одном месте и вся необходимая информация присутствует.\n
Последовательность	→→→ Требование не противоречит другим требованиям и полностью соответствует внешней документации.\n
Атомарность	→→→ Требование «атомарно». То есть оно не может быть разбито на ряд более детальных требований без потери завершённости.\n
Отслеживаемость	→→→ Требование полностью или частично соответствует деловым нуждам как заявлено заинтересованными лицами и документировано.\n
Актуальность	→→→ Требование не стало устаревшим с течением времени.\n
Выполнимость	→→→ Требование может быть реализовано в пределах проекта.\n
Недвусмысленность	→→→ Требование кратко определено без обращения к техническому жаргону, акронимам и другим скрытым формулировкам. Оно выражает объективные факты, не субъективные мнения. Возможна одна и только одна интерпретация. Определение не содержит нечётких фраз. Использование отрицательных утверждений и составных утверждений запрещено.\n
Обязательность	→→→ Требование представляет определённую заинтересованным лицом характеристику, отсутствие которой приведёт к неполноценности решения, которая не может быть проигнорирована. Необязательное требование — противоречие самому понятию требования.\n
Проверяемость	→→→ Реализованность требования может быть определена через один из четырёх возможных методов: осмотр, демонстрация, тест или анализ.\n\n
Методы выявления требований\n
•	Интервью, опросы, анкетирование\n
•	Мозговой штурм, семинар\n
•	Наблюдение за производственной деятельностью, «фотографирование» рабочего дня\n
•	Анализ нормативной документации\n
•	Анализ моделей деятельности\n
•	Анализ конкурентных продуктов\n
•	Анализ статистики использования предыдущих версий системы\n\n
Проверка требований\n
Все требования должны поддаваться проверке. Наиболее общепринятая методика проверки — тесты. Если проверка тестами невозможна, тогда должен использоваться другой метод проверки (анализ, демонстрация, осмотр или обзор дизайна).\n
Определённые требования, по своей сути, не поддаются проверке. Они включают требования, которые говорят, что система никогда не должна или всегда должна показывать специфическое свойство. Надлежащее тестирование этих требований потребовало бы бесконечного цикла тестирования. Такие требования должны быть переопределены так, чтобы они стали поддающимися проверке. Как указано выше, все требования должны поддаваться проверке.\n
Нефункциональные требования, которые не поддаются проверке на программном уровне, все равно должны быть сохранены как документация намерений клиента. Такие требования к продукту могут быть преобразованы в требования к процессу. Например, нефункциональное требование, чтобы ПО не содержало «потайных ходов», может быть удовлетворено заменой на требование использовать парное программирование. Сложные требования безопасности авиационного программного обеспечения могут быть удовлетворены следованием процессу разработки DO-178B (англ.).\n\n
Анализ требований\n
При разработке требований часто возникают проблемы двусмысленности, неполноты, и несогласованности отдельных требований. Устранение этих проблем на этапе разработки требований стоит на несколько порядков меньше, чем устранение этих же проблем на поздних стадиях разработки. Для решения и устранения этих проблем существует процесс разработки требований.\n
При разработке требований существует технический компромисс между слишком неопределёнными требованиями и требованиями столь детализированными, что они:\n
•	требуют много времени для разработки, иногда даже рискуют устареть к концу разработки;\n
•	ограничивают возможные способы реализации;\n
•	являются слишком дорогостоящими.\n\n
Документирование требований\n
Требования обычно используются как средство коммуникации между различными заинтересованными лицами. Это означает, что требования должны быть просты и понятны для обычных пользователей и разработчиков. Один общий способ задокументировать требование — это написать утверждение о том, что должна сделать система.\n
В практике встречаются следующие типы документов требований:\n
•	Спецификация требований программного обеспечения (англ. Software Requirements Specification, SRS)\n
Спецификацию программного обеспечения часто называют техническим заданием. Это ошибка. Спецификация требований является частью технического задания в случае создания автоматизированных информационных систем.\n
За создание спецификации программного обеспечения чаще всего в практике отвечает Системный аналитик, иногда — Бизнес-аналитик.\n
Для графических моделей требований исторически использовались диаграммы или методологии графического моделирования: ER (IDEF1FX), IDEF0, IDEF3, DFD, UML, OCL, SysML, ARIS (eEPC, VAD).\n\n
Изменение требований\n
В общем случае требования изменяются со временем. После того, как требования определены и одобрены, изменения должны попадать под контроль внесения изменений. Для многих проектов требования изменяются до завершения создания системы. Это происходит частично из-за сложности программного обеспечения и того факта, что пользователи не знают, что им нужно на самом деле. Эта особенность требований привела к появлению процесса управления требованиями.\n
</item>
        <!--58-->
        <item>58.ФОРМАЛЬНЫЕ ЯЗЫКИ ПРОГРАММИРОВАНИЯ.\n\n\n\n\n
Язык программирования - это формальный язык, который представляет собой совокупность алфавита, правил написания конструкций (синтаксис) и правил толкования конструкций (семантика).\n
В настоящее время насчитывается несколько сотен языков программирования, рассчитанных на разные сферы применения ЭВМ, т. е. на разные классы решаемых с помощью ЭВМ задач. Эти языки классифицируют по разным уровням, учитывая степень зависимости языка от конкретной ЭВМ.\n
Общепринятой и строгой классификации языков программирования не существует. Поэтому в курсе представлена классификация наиболее распространенных языков, сложившаяся исторически:\n\n
Языки программирования\n
Низкого уровня	Высокого уровня\n
Машинный	Машинно-зависимые	Машинно-независимые\n
 	Ассемблер	Универсальные\n
 	Автокод	Проблемно-ориентированные\n
 	 	Объектно-ориентированные\n
 	 	Командные языки баз данных\n
На самом нижнем уровне классификации находится машинный язык, т. е. внутренний язык ЭВМ, на котором в конечном итоге представляется и исполняется программа. Однако непосредственная запись алгоритма на машинном языке требует от разработчика чрезмерной детализации алгоритма, в результате чего запись получается не наглядной и трудной для понимания. Поэтому разработчики алгоритмов используют, как правило, языки программирования более высокого уровня, в которых принята символическая форма записи, близкая к общепринятой математической.\n
Универсальные языки высокого уровня обеспечивают создание различных программ (задач), например Алгол, Си, ПЛ/1 и т.д..\n
Проблемно-ориентированные языки создавались под какие-то конкретные классы задач, например, Фортран - научные расчеты, Кобол - экономические расчеты, Лисп и Пролог - искусственный интеллект и т.д.\n
Объектно-ориентированные языки четвертого поколения (4GL — forth-generation language) и программирование основаны на создании модели системы, как совокупности объектов и использует следующие базовые понятия: класс, объект, событие, свойства объекта, метод обработки. Первым языком программирования этой группы был - Симула-67. В настоящее время к этим языкам относятся - С++, Visual Basic, Java Script и динамический HTML и другие современные языки программирования.\n
Командные языки баз данныхпредназначены длярасширения возможностей среды управления базами данных, для создания собственных функций интерфейса - взаимодействия с пользователем.\n
Например, интересна эволюция языка программирования BASIC. Он был задуман как универсальный язык для начинающих (по аналогии с BASIC ENGLISH, — подмножеством английского языка, выделенным для обучения иностранцев). Первые версии (или «диалекты») этого языка содержали небольшое количество самых необходимых команд и предусматривали только режим интерпретации. Однако современные варианты языка BASIC не только не уступают по возможностям многим «грандам» (типа С), но иногда и превосходят их. Например, Visual Basic используется в суперсовременных системах, основанных на так называемой технологии «клиент-сервер». Одновременно BASIC стал своеобразным «эсперанто» в мире информационной технологии. На этом языке часто пишутся примеры программ или их фрагментов в книгах, статьях, инструкциях к программным продуктам.\n
Фирма Microsoft использует Visual Basic для расширения функций своих программных продуктов. Уже в пакете Microsoft Office для Windows 3-х пользователям и программистам предлагались диалекты Word Basic и Access Basic, а ныне в Microsoft Office предусмотрен универсальный язык Visual Basic for Applications (VBA — Visual Basic для приложений). Ранее этот язык использовался только в Excel 5.0. С помощью VBA можно создавать собственные программные модули, собственные интерфейсы для офисных приложений Word, Excel, Access.\n
При исполнении алгоритма на ЭВМ программа транслируется с языка высокого уровня на машинный язык, а затем уже исполняется. В силу того что и язык программирования высокого уровня и машинный язык формализованы, трансляция программы может быть автоматизирована и выполнена с помощью той же ЭВМ. При этом человек воспринимает это так, будто ЭВМ непосредственно понимает язык высокого уровня и исполняет алгоритм, записанный на этом языке.\n
Существует два типа программ-трансляторов, работающих с исходными текстами. Программа-компилятор (от слова compile — составлять, собирать) переводит исходный текст в машинный код и записывает его на диск в форме исполняемого (загрузочного) файла. После этого программа выполняется независимо от исходного текста. Раньше программы-компиляторы называли просто и точно — трансляторами (переводчиками).\n
Программа-интерпретатор всегда работает совместно с исходным текстом. Она разбирает каждую инструкцию исходного текста (интерпретирует ее) и немедленно исполняет (т. е. файл на машинном языке не создается). Программа в режиме интерпретации работает гораздо медленнее, чем такая же программа в машинном коде. Это связано с тем, что каждую инструкцию приходится разбирать во время выполнения (а не заранее, как при компиляции). Многие инструкции в программе выполняются многократно, — и при каждом выполнении интерпретируются заново. Поэтому всюду, где возможно, стремятся заменить режим интерпретации режимом компиляции. Правда, интерпретация имеет и свои преимущества: с ее помощью проще отлаживать программу. Иногда пользуются режимом «псевдокомпиляции»: ускоряют интерпретацию за счет предварительного запоминания тех или иных элементов разобранных команд в памяти машины.\n
Современное программирование существенно отличается от технологии разработки программ для старых ЭВМ. Среди относительно новых особенностей и направлений этой технологии:\n
Ø применение объектно-ориентированных языков;\n
Ø визуальное программирование (т. е. сборка экранной формы с помощью мыши из готовых «полуфабрикатов »-объектов);\n
Ø быстрая разработка приложений (RAD — Rapid Applications Development);\n
Ø программирование с использованием функций API Windows (Applications Programming Interface — интерфейс прикладного программирования);\n
Ø базы данных и многопользовательские приложения (т. е. приложения, с которыми одновременно работает несколько пользователей) и многие другие.\n
</item>
        <!--59-->
        <item>59.ОБЩИЕ ПОНЯТИЯ ПРОЦЕДУРНОГО ПРОГРАММИРОВАНИЯ.\n\n\n\n\n
Процеду́рное программи́рование — программирование на императивном языке, при котором последовательно выполняемые операторы можно собрать в подпрограммы, то есть более крупные целостные единицы кода, с помощью механизмов самого языка.\n
Процедурное программирование является отражением архитектуры традиционных ЭВМ, которая была предложена Фон Нейманом в 1940-х годах. Теоретической моделью процедурного программирования служит абстрактная вычислительная система под названием машина Тьюринга.\n\n
Основные сведения\n
Выполнение программы сводится к последовательному выполнению операторов с целью преобразования исходного состояния памяти, то есть значений исходных данных, в заключительное, то есть в результаты. Таким образом, с точки зрения программиста имеются программа и память, причем первая последовательно обновляет содержимое последней.\n
Процедурный язык программирования предоставляет возможность программисту определять каждый шаг в процессе решения задачи. Особенность таких языков программирования состоит в том, что задачи разбиваются на шаги и решаются шаг за шагом. Используя процедурный язык, программист определяет языковые конструкции для выполнения последовательности алгоритмических шагов.\n\n
Процедурные языки программирования\n
•	Ada (язык общего назначения)\n
•	Алгол 60\n
•	Алгол 68\n
•	Basic (до появления Visual Basic)\n
•	Си\n
•	КОБОЛ\n
•	Фортран\n
•	Модула-2\n
•	HAL/S\n
•	Pascal\n
•	PureBasic\n
•	ПЛ/1\n
•	РАПИРА\n
•	REXX\n
•	Go\n
•	Nim\n
</item>
        <!--60-->
        <item>60.ИСПОЛЬЗОВАНИЕ INTERNET В КАЧЕСТВЕ СРЕДЫ ПЕРЕДАЧИ ДАННЫХ. ПРЕИМУЩЕСТВА И НЕДОСТАТКИ ЭТОГО МЕТОДА.\n\n\n\n\n\n
Интерне́т  — всемирная система объединённых компьютерных сетей для хранения, обработки и передачи информации.\n
Упоминается как Всемирная сеть и Глобальная сеть, а также просто Сеть. Построена на базе стека протоколов TCP/IP. На основе Интернета работает Всемирная паутина (World Wide Web, WWW) и множество других систем передачи данных. К середине 2015 года число пользователей достигло 3,3 млрд человек. Во многом это было обусловлено широким распространением сотовых сетей с доступом в Интернет стандартов 3G и 4G, развитием социальных сетей и удешевлением стоимости интернет-трафика.\n\n
История\n
Принципы, по которым строится Интернет, впервые были применены в сети ARPANET, созданной в 1969 году по заказу американского агентства DARPA. Используя наработки ARPANET, в 1984 году Национальный научный фонд США создал сеть NSFNET для связи между университетами и вычислительными центрами. В отличие от закрытой ARPANET подключение к NSFNET было достаточно свободным и к 1992 году к ней подключились более 7500 мелких сетей, включая 2500 за пределами США. С передачей опорной сети NSFNET в коммерческое использование появился современный Интернет.\n\n
Разработка концепции\n
Американской исследовательской программой в направлении быстрой передачи сообщений руководил Джозеф Ликлайдер (Joseph Carl Robnett Licklider), опубликовавший в 1962 году работу «Galactic Network». Благодаря Ликлайдеру появилась первая детально разработанная концепция компьютерной сети. Она была подкреплена работами Леонарда Клейнрока (Leonard Kleinrock) — он описал технологию, способную разбивать файлы на части и передавать их различными путями через сеть (1961—1964).\n
В 1962 году Пол Бэран (Пейсах Баран, Paul Baran) из RAND Corporation подготовил доклад «On Distributed Communication Networks». В его предложении сеть напоминала рыбацкий невод. Все узлы наделены способностью маршрутизировать трафик, каждый из них связан с несколькими другими узлами. Он предложил децентрализовать систему узлов связи (все региональные узлы связи в сети равноправны), которая даже при разрушении её части будет работоспособна. Предлагалось передавать сообщения в цифровом, а не в аналоговом виде. Само сообщение предлагалось разбивать на небольшие порции — «пакеты», и передавать по распределённой сети все пакеты одновременно. Из принятых в месте назначения дискретных пакетов сообщение заново «собиралось».\n
Параллельно в Англии Дональд Дэвис (Donald Watts Davies) разработал концепцию Сети и добавил в неё существенную деталь — компьютерные узлы должны не только передавать данные, но и стать переводчиками для различных компьютерных систем и языков. Именно Дэвису принадлежит термин «пакет» для обозначения фрагментов файлов, пересылаемых раздельно.\n\n
Современное развитие\n
В 1991 году Всемирная паутина стала общедоступна в интернете, а в 1993 году появился знаменитый веб-браузер NCSA Mosaic. Всемирная паутина набирала популярность.\n
Можно считать, что существуют две ясно различимые эры в истории Web: [до браузера Mosaic] Марка Андриссена и после.\n
Именно сочетание веб-протокола от Тима Бернерс-Ли, который обеспечивал коммуникацию, и браузера (Mosaic) от Марка Андриссена, который предоставил функционально совершенный пользовательский интерфейс, создало условия для наблюдаемого взрыва (интереса к Веб). За первые 24 месяца, истёкшие после появления браузера Моsaic, Web прошёл стадию от полной неизвестности (за пределами считанного числа людей внутри узкой группы учёных и специалистов лишь одного мало кому известного профиля деятельности) до полной и абсолютно везде в мире его распространённости.
— A Brief History of Cyberspace, Mark Pesce, ZDNet, 15 октября 1995\n
В 1995 году NSFNet вернулась к роли исследовательской сети, маршрутизацией всего трафика интернета теперь занимались сетевые провайдеры, а не суперкомпьютеры Национального научного фонда.\n
В том же 1995 году Всемирная паутина стала основным поставщиком информации в интернете, обогнав по трафику протокол пересылки файлов FTP. Был образован Консорциум Всемирной паутины (W3C). Можно сказать, что Всемирная паутина преобразила интернет и создала его современный облик. С 1996 года Всемирная паутина почти полностью подменяет собой понятие «интернет».\n
В 1990-е годы интернет объединил в себе большинство существовавших тогда сетей (хотя некоторые, как Фидонет, остались обособленными). Объединение выглядело привлекательным благодаря отсутствию единого руководства, а также благодаря открытости технических стандартов интернета, что делало сети независимыми от бизнеса и конкретных компаний. К 1997 году в интернете насчитывалось уже около 10 млн компьютеров, было зарегистрировано более 1 млн доменных имён. Интернет стал очень популярным средством для обмена информацией.\n
В настоящее время подключиться к интернету можно через спутники связи, радиоканалы, кабельное телевидение, телефон, сотовую связь, специальные оптико-волоконные линии или электропровода. Всемирная сеть стала неотъемлемой частью жизни в развитых и развивающихся странах.\n
В течение пяти лет Интернет достиг аудитории свыше 50 миллионов пользователей. Другим средствам коммуникации требовалось гораздо больше времени для достижения такой популярности:\n\n
Информационная среда	Время, лет\n
Радио	38\n
Телевидение	13\n
Кабельное телевидение	10\n
Интернет	5\n\n
С 22 января 2010 года прямой доступ в интернет получил экипаж Международной космической станции.\n
В сентябре 2017 года ООН сообщила о том, что доступ к интернету имеют меньше половины (48 %) населения Земли. При этом с 2010 года количество интернет-пользователей увеличилось на 1,5 млрд человек.\n\n

Internet как среда распространения информации в режиме реального времени предоставляет пользователю следующие несомненные преимущества:\n
Открытость и разработанность стандартов. Наличие надежного набора технических средств для конструирования сервиса.\n
Относительная дешевизна каналов связи.\n
Доступность. Возможность доступа пользователя к информации из любой точки без каких-либо дополнительных затрат.\n\n
Тем не менее, существует ряд факторов, ограничивающих широкое использование Internet в качестве среды распространения финансовой информации. Перечислим проблемы, возникающие при использовании Internet, и приведем их возможные решения:\n
Неопределенность стандартов защиты данных от несанкционированного доступа и стандартов электронных платежей (можно ожидать утверждения необходимых стандартов в ближайшем будущем).\n
Перегруженность сети, необходимость в повышенных требованиях к производительности серверов и пропускной способности каналов связи из-за растущего объема передаваемых данных и необходимости их постоянного обновления (эта проблема иногда решается путем использования выделенной полосы пропускания в пределах каналов Internet общего назначения).\n
Различные ограничения возможностей обработки информации стандартными средствами доступа (существует несколько решений этой проблемы. Одно из них уже широко распространено в мире и заключается в написании специализированного программного обеспечения, использующего стандарты Internet, другое связано с использованием языка программирования Java, разработанного компанией Sun Microsystems специально для использования в среде Internet).\n
</item>
        <!--61-->
        <item>61.ПРЕИМУЩЕСТВА И НЕДОСТАТКИ СТРУКТУРИРОВАННОЙ КАБЕЛЬНОЙ СИСТЕМЫ (СКС). ЧТО ТАКОЕ СКС. СТРУКТУРА СКС. ВЕРТИКАЛЬНАЯ И ГОРИЗОНТАЛЬНАЯ РАЗВОДКА. НАЗНАЧЕНИЕ ПРОВОДКИ СКС.\n
Структурированная кабельная система (СКС) – это физическая основа инфраструктуры здания, которая объединяет в единый комплекс различные сетевые информационные сервисы.\n
Такими сервисами являются:\n
•	электросиловая сеть и освещение;\n
•	компьютерная сеть;\n
•	IP-телефония;\n
•	система контроля и управления доступом (СКУД);\n
•	система пожарной сигнализации и пожаротушения;\n
•	система охранных датчиков;\n
•	системы видеонаблюдения;\n
•	аудиосистема (системы оповещения и радио).\n\n
Кабельная система является фундаментом любой сети. Если она будет низкого качества, то даже самое современное и производительное оборудование будет работать медленно, нестабильно и будет неудовлетворять требованиям пользователей. Причем проблем с кабельной системой становится намного больше при увеличении размеров сети.\n
Ответом на высокие требования к качеству кабельной системы стали структурированные кабельные системы.\n
Структурированная кабельная система (Structured Cabling System, SCS) - это набор коммутационных элементов (кабелей, разъемов, коннекторов, кроссовых панелей и шкафов), а также методика их совместного использования, которая позволяет создавать регулярные, легко расширяемые структуры связей в вычислительных сетях.\n
Структурированная кабельная система представляет своего рода «конструктор», с помощью которого проектировщик сети строит нужную ему конфигурацию из стандартных кабелей, соединенных стандартными разъемами и коммутируемых на стандартных кроссовых панелях. При необходимости конфигурацию связей можно легко изменить - добавить компьютер, сегмент, коммутатор, изъять ненужное оборудование, а также поменять соединения между компьютерами и концентраторами.\n
При построении структурированной кабельной системы подразумевается, что каждое рабочее место на предприятии должно быть оснащено розетками для подключения телефона и компьютера, даже если в данный момент этого не требуется. То есть хорошая структурированная кабельная система строится избыточной, В будущем это может сэкономить средства, так как изменения в подключении новых устройств можно производить за счет перекоммутации уже проложенных кабелей.\n
Структурированная кабельная система планируется и строится иерархически, с главной магистралью и многочисленными ответвлениями от нее.\n
Типичная иерархическая структура структурированной кабельной системы включает:\n
	горизонтальные подсистемы (в пределах этажа);\n
	вертикальные подсистемы (внутри здания);\n
	подсистему кампуса (в пределах одной территории с несколькими зданиями).\n\n
Горизонтальная подсистема соединяет кроссовый шкаф этажа с розетками пользователей. Подсистемы этого типа соответствуют этажам здания. Вертикальная подсистема соединяет кроссовые шкафы каждого этажа с центральной аппаратной здания. Следующим шагом иерархии является подсистема кампуса, которая соединяет несколько зданий с главной аппаратной всего кампуса. Эта часть кабельной системы обычно называется магистралью (backbone).\n
Использование структурированной кабельной системы вместо хаотически проложенных кабелей дает предприятию много преимуществ.
	Универсальность. Структурированная кабельная система при продуманной организации может стать единой средой для передачи компьютерных данных в локальной вычислительной сети, организации локальной телефонной сети, передачи видеоинформации и даже передачи сигналов от датчиков пожарной безопасности или охранных систем. Это позволяет автоматизировать многие процессы контроля, мониторинга и управления хозяйственными службами и системами жизнеобеспечения предприятия.\n
	Увеличение срока службы. Срок морального старения хорошо структурированной кабельной системы может составлять 10-15 лет.\n
	Уменьшение стоимости добавления новых пользователей и изменения их мест размещения. Известно, что стоимость кабельной системы значительна и определяется в основном не стоимостью кабеля, а стоимостью работ по его прокладке. Поэтому более выгодно провести однократную работу по прокладке кабеля, возможно, с большим запасом по длине, чем несколько раз выполнять прокладку, наращивая длину кабеля. При таком подходе все работы по добавлению или перемещению пользователя сводятся к подключению компьютера к уже имеющейся розетке.\n
	Возможность легкого расширения сети. Структурированная кабельная система является модульной, поэтому ее легко расширять. Например, к магистрали можно добавить новую подсеть, не оказывая никакого влияния на существующие подсети. Можно заменить в отдельной подсети тип кабеля независимо от остальной части сети. Структурированная кабельная система является основой для деления сети на легко управляемые логические сегменты, так как она сама уже разделена на физические сегменты.\n
	Обеспечение более эффективного обслуживания. Структурированная кабельная система облегчает обслуживание и поиск неисправностей по сравнению с шинной кабельной системой. При шинной организации кабельной системы отказ одного из устройств или соединительных элементов приводит к трудно локализуемому отказу всей сети. В структурированных кабельных системах отказ одного сегмента не действует на другие, так как объединение сегментов осуществляется с помощью концентраторов. Концентраторы диагностируют и локализуют неисправный участок.\n
	Надежность. Структурированная кабельная система имеет повышенную надежность, поскольку производитель такой системы гарантирует не только качество ее отдельных компонентов, но и их совместимость.\n\n
В чем заключаются основные недостатки СКС?\n
Структурированные кабельные системы имеют весьма сложную архитектуру и для того, что разработать и реализовать адекватный проект, необходимо привлекать Высококвалифицированных специалистов, стоимость услуг которых весьма и весьма Высока. Кроме того, для создания таких систем используются самые надежные и долговечные комплектующие, а это также отражается на стоимости создания такой системы. Впрочем, как показала практика, Высокие затраты полностью окупаются благодаря исключительной надежности простоте эксплуатации системы, а также и отсутствию необходимости в ее модернизации.\n\n
При выборе кабеля принимаются во внимание следующие характеристики: полоса пропускания, расстояние, физическая защищенность, электромагнитная помехозащищенность, стоимость. Кроме того, при выборе кабеля нужно учитывать, какая кабельная система уже установлена на предприятии, а также какие тенденции и перспективы существуют на рынке в данный момент.\n
Назначение проводки СКС заключается в передаче электроэнергии, речи, данных, текста, изображений и видео.\n
</item>
        <!--62-->
        <item>62.ТЕХНОЛОГИЯ ISDN. ОПИСАНИЕ ТЕХНОЛОГИИ, АДРЕСАЦИЯ В ISDN. B И D КАНАЛЫ. ЧТО ТАКОЕ ISDN PRI И ISDN BRI.\n\n
Технология ISDN\n
В современных телекоммуникационных сетях используется множество разнообразных технологий и протоколов. Аналоговые системы связи все меньше отвечают требованиям времени, хотя из-за своей доступности они еще достаточно широко используются для телефонии и низкоскоростной передачи данных, в частности по протоколу Х.25. Более высокими скоростями передачи отличаются выделенные цифровые каналы связи, построенные на основе меди, оптоволокна, беспроводных и спутниковых каналов связи. Но их строительство и аренда обходятся значительно дороже. Развиваются очень перспективные сети c асинхронным режимом передачи (ATM), позволяющие передавать с максимальной эффективностью любые виды трафика и масштабировать полосу пропускания. Реально доступны, в том числе в ряде городов России, услуги сетей с ретрансляцией кадров (frame relay), обычно базирующихся на выделенных линиях и поддерживающих многоточечные топологии. Сети frame relay могут использоваться для передачи различных видов трафика, в том числе чувствительного к задержкам. В ряде стран, прежде всего в США, началось внедрение технологий высокоскоростной передачи интегрированных данных по сетям кабельного телевидения (КТВ) и обычным телефонным проводам (xDSL). Получают развитие такие технологии, как SMDS (Synchronous Multimegabit Digital Service - многоточечная передача данных на основе коммутации ячеек) и B-ISDN (Broadband ISDN - широкополосная ISDN). Эти технологии очень перспективны, но пока мало доступны и дороги.\n
Во всем мире растет количество цифровых сетей с интеграцией услуг (ISDN - Integrated Services Digital Network). Они основываются на "зрелой" технологии и создаются отчасти на базе оборудования и каналов существующих телефонных сетей общего пользования (ТСОП).\n
Сети АТМ, frame relay и ISDN начинают использоваться и в России. Более того, усилиями целого ряда российских операторов, совместных предприятий и зарубежных компаний, строящих наложенные сети на основе самых современных технологий SDH и ATM, создаются условия для реализации качественно новых возможностей в области телекоммуникаций.\n
При построении территориально-распределенных сетей компаний и подключении к основной локальной вычислительной сети (ЛС) удаленных филиалов и мобильных пользователей перед администраторами ЛС, специалистами в области информационных технологий встает непростая задача оптимального выбора стандарта передачи информации. В данной статье рассматриваются практические аспекты использования каналов ISDN для построения интегрированных информационных сетей.\n\n

Краткая историческая справка\n
Технология ISDN была разработана в 1974 году. Первая ISDN станция была введена в эксплуатацию в 1976г. С самого начала внедрение этой технологии воспринималось как переход от существующей аналоговой телефонии к цифровой сети. Но технология ISDN изначально предполагала более широкий спектр возможностей, нежели простая замена устаревшей телефонной сети, применение её в качестве передачи голосового трафика не оправдывало финансовых затрат на организацию сети. Несмотря на первоначальный интерес к технологии ISDN, она не получила должного развития и, в течении двадцати лет человечество предпочитало жить "по старинке". Интерес к цифровой технологии возник только в последние несколько лет, в период бума развития компьютерных технологий, который в настоящий момент охватил не только сферы производства и обслуживания, но и сферу быта. Существующая аналоговая сеть уже не удовлетворяет современным требованиям по качеству и скорости передачи данных, а организация оптической линии для сетей абонентского доступа пока не является экономически целесообразным. Наиболее приемлемым выходом в этой ситуации стала технология ISDN позволяющая использовать старые медные линии для высокоскоростной передачи данных. Хотя эволюция сетевых технологий передачи данных до сих пор значительно отстаёт от темпов внедрения компьютерных технологий. В основном это объясняется отсутствием единой транспортной среды на основе технологии наложенной сети передачи данных. Технология ISDN позволит решить эту задачу в кратчайшие сроки и с высокой экономической эффективностью.\n
Благодаря усилиям со стороны ETSI (European Telecommunications Standards Institute) фактическим стандартом в Европе становится EuroISDN, который поддерживают большинство европейских телекоммуникационных провайдеров и производителей оборудования. В России также ведутся работы по стандартизации и обеспечению совместимости строящихся в различных регионах сетей ISDN.\n\n

Что такое ISDN?\n
ISDN (Integrated Services Digital Network) что в переводе на русский язык означает цифровая сеть с интеграцией служб. Это наложенная цифровая сеть, которая организуется на существующей аналоговой телефонной сети общего пользования. Принципиальное отличие ISDN от существующей аналоговой сети заключается в том, что технология ISDN позволяет организовать коммутируемые цифровые каналы непосредственно от пользователя к пользователю. Использовать этот цифровой канал можно по-разному.\n
Во-первых, Вы получаете качественную телефонную связь с мгновенным установлением соединения, в добавок большое количество сервисных функций (до 230), высокую гарантию сохранности информации при ее прохождении по каналам связи.\n
Во-вторых, Вы получаете вторую телефонную линию без каких либо затрат, разве что Вам придётся купить ещё один телефонный аппарат.\n
В-третьих, если Вы желаете не только говорить с собеседником, но и видеть его то ISDN предоставляет и эту возможность. Более того, с помощью ISDN технологии, возможно, организовать видео конференцию в реальном времени с участием нескольких абонентов. Эта услуга может быть полезна в тех сферах деятельности, где необходим оперативный обмен видео информацией.\n
В-четвёртых, при существующем дефиците абонентских линий Вы можете телефонизировать офис, используя всего лишь одну медную телефонную пару.\n
В-пятых, ISDN предоставляет уникальную возможность, объединения удалённых офисов в единую локальную сеть как внутри города, так и между городами, со скоростью до 128 кB/с.\n\n

Адресация в ISDN\n
Адрес абонента ISDN состоит из международного номера ISDN и субадреса. Из адреса ISDN сеть получает информацию о соответствующей стране и желаемом абонентском окончании или группе. Адрес ISDN содержит 15 десятичных цифр, включая индекс страны, код сети и индекс местной сети, однако не допускается использование в кодах некоторых определенных последовательностей цифр.\n
Субадрес ISDN служит для уточнения адресации внутренних компонент устройства пользователя, выбранного с помощью адреса ISDN. Субадрес ISDN передается при установлении соединения в своем информационном поле без каких-либо изменений от вызывающего устройства пользователя к вызываемому.\n\n

Каналы ISDN\n
В традиционной телефонной сети пользователь связывается с центральным коммутатором (АТС) через абонентскую линию. Местная абонентская линия состоит из одного аналогового канала, применяемого для передачи в сеть сигналов (например, при наборе телефонного номера) и информации (разговора, звука, видео или двоичных данных). В ISDN местная абонентская линия передает только цифровые данные, хотя она может быть любого типа, который доступен в современной коммуникационной среде. Местная линия ISDN связывает с установленной у пользователя аппаратурой ISDN местную коммуникационную компанию (LE - local exchange ) - эквивалент АТС в ISDN. Абонентская линия ISDN состоит из отдельных логических каналов, которые можно комбинировать для предоставления пользователю интерфейса с ISDN. Эти логические каналы разделяются на три базовых типа. При передаче в местной абонентской линии каждому каналу отводится свой квант времени. Для этого используется процесс мультиплексирования с разделением (квантованием) по времени (TDM), описанный в предыдущей главе. Кроме того, каналам ISDN присваивается категория согласно их использованию (передача сигналов или передача данных) и стандартной скорости передачи данных для канала конкретного типа. Для объединения в сети ISDN различных видов трафика используется технология TDM (англ. Time Division Multiplexing, временноме разделение). Для каждого типа данных выделяется отдельная полоса, называющаяся элементарным каналом (или стандартным каналом). Для этой полосы гарантируется фиксированная, согласованная доля полосы пропускания. Выделение полосы происходит после подачи сигнала CALL по отдельному каналу, называющемуся каналом внеканальной сигнализации.\n
В стандартах ISDN определяются базовые типы каналов, из которых формируются различные пользовательские интерфейсы.\n\n
В-канал\n
В-канал ISDN, иногда называемый каналом-носителем или информационным каналом, используется для передачи информации, необходимой службам ISDN. Это означает, что В-канал применяется для обмена такой пользовательской информацией, как оцифрованная речь, звук, видео и двоичные данные, и допускает мультиплексирование для передачи любой комбинации разных типов данных. Ограничением является лишь пропускная способность канала. В-канал - основной пользовательский канал передачи данных, описываемый в стандартах ISDN. Для него была определена скорость передачи данных 64 Кбит/с, соответствующая полосе частот, которая необходима для эффективного обмена оцифрованной речью за установленное этими стандартами время. В-каналы обслуживают соединения с коммутацией каналов, коммутацией пакетов или полупостоянные соединения (эквивалент выделенной линии в ISDN )\n
Канал "B" (Bearer) - канал для передачи голоса, данных, видео c пропускной способностью 64 Кбит/с. Он предоставляется "чистым", т.е. вся его полоса пропускания доступна для передачи информации, а вызовы, сигнализация и другая системная информация передается по D-каналу.\n\n
Передача в D-каналах\n
D-каналы используются в основном для передачи сигналов между пользователем ISDN и самой сетью ISDN. В различных пользовательских устройствах ISDN (телефонах, факсимильных аппаратах и компьютерах) применяются разные способы соединения с ISDN, но все они работают с помощью общего протокола передачи и приема сигналов из сети, используя для коммуникаций D-канал. В каждый момент времени передача сигналов данных не занимает всей полосы частот, предусмотренной для D-канала. Следовательно, при доступной полосе частот возможно вторичное использование этого капала. Такой метод применяется достаточно редко, однако дополнительная полоса частот полезна для передачи в сетях с коммутацией пакетов, например в сетях IP (Internet Protocol - с протоколом Интернета) или Х.25. В зависимости от типа предоставляемого пользователю интерфейса D-канал может иметь скорость передачи данных 16 или 64 Кбит/с.\n
Канал "D" (Delta) - служебный канал для передачи управляющих сигналов с пропускной способностью 16 (BRI) или 64 (PRI) Кбит/с. Один канал типа "D" обслуживает 2 или 30 (Европа) В-каналов и обеспечивает возможность быстрой генерации и сброса вызовов, а также передачу информации о поступающих вызовах, в том числе о номере обращающегося к сети абонента. Некоторые операторы и производители телекоммуникационного оборудования поддерживают передачу через D-канал дополнительной информации, например организуют канал X.25 или поток данных с телеметрической информацией со скоростью передачи до 9,6 Кбит/c. Но такое расширение возможностей канала не соответствует стандарту.\n\n
BRI (Basic Rate Interface) - стандартный базовый интерфейс с пропускной способностью 144 Кбит/с (EuroISDN); он объединяет два канала "B" и один канал "D". К интерфейсу BRI можно подключить до восьми различных ISDN-устройств. При этом каждому устройству выделяется свой индивидуальный номер (multiple subscriber numbers). Очень важная особенность ISDN состоит в том, что для установки BRI-розетки оператору обычно не требуется прокладывать новую телефонную пару - используется обычная линия ТСОП.\n
Физическим уровнем интерфейса BRI, определяющего правила взаимодействия конечных пользователей и коммутатора ISDN, служит обычная витая пара, которая работает в дуплексном режиме передачи данных, - так называемый U-интерфейс. Внутри зданий используется кабель из двух витых пар - S/T- интерфейс, позволяющий подключать до восьми оконечных ISDN-устройств. Поэтому для подсоединения внутренней проводки к внешней линии необходимо устройство NT1 (одно на каждый BRI-интерфейс).\n\n
PRI (Primary Rate Interface) - этот интерфейс объединяет несколько B-каналов (например, в Европе - 30 В-каналов с общей полосой пропускания 2,048 Мбит/с). В отличие от BRI, он поддерживает только одно оконечное устройство. Но подключив, например, локальную АТС или маршрутизатор c поддержкой ISDN, можно разбить PRI на множество BRI-интерфейсов. В настоящее время для предоставления офисам PRI-сервиса широко используется абонентская цифровая линия на одной (SDSL) или двух (HDSL) телефонных парах.
</item>
        <!--63-->
        <item>63.ТЕХНОЛОГИЯ FRAME RELAY. ОПИСАНИЕ ТЕХНОЛОГИИ. ЧТО ТАКОЕ EIR, CIR, PVC, SVC. СКОРОСТЬ ПЕРЕДАЧИ.\n\n\n
Технология Frame Relay(FR, ретрансляция кадров) ориентирована на использование в сетях с коммутацией пакетов. Сама технология охватывает только физический и канальный уровни OSI. Сетью Frame Relay принято считать любую сеть, использующую на нижних двух уровнях управления одноименную технологию. Основное отличие Frame Relay от Х.25 — в механизме обеспечения достоверности информации. Сеть Х.25 разрабатывалась с учетом плохих аналоговых каналов связи, имевшихся в то время, и поэтому в ней приняты весьма трудоемкие меры по обеспечению достоверности, требующие для своей реализации больших временных затрат. Именно поэтому сеть Х.25 является сетью с гарантированной доставкой информации.\n
Технология FR разрабатывалась с учетом уже достигнутых в телекоммуникациях высоких скоростей передачи данных и низкого уровня ошибок в современных сетях. Таким образом, сеть Frame Relay ориентирована на хорошие цифровые каналыпередачи информации, и в ней отсутствует проверка выполнения соединения между узлами и контроль достоверности информации(контроль за появлением ошибок) на канальном уровне, а именно на этом уровне в FR выполняется мультиплексирование потока данных в кадры. Каждый кадр канального уровня содержит заголовок, который используется для маршрутизации трафика. Контроль достоверности передачи осуществляется на верхних уровнях модели OSI. При обнаружении ошибки повторная передача кадра не производится, а искаженный кадр просто выбрасывается.\n
Таким образом в сети Frame Relay обеспечивается гарантированная согласованная скорость передачи информации. Скорость передачи может быть весьма большой: в диапазоне от 56 Кбит/с до 44 Мбит/с, но без гарантии достоверности доставки.\n
Компонентами сети Frame Relay являются устройства трех основных категорий:\n
- устройства DTE (Data Terminal Equipment);\n
- устройства DCE (Data Circuit-Terminating Equipment);\n
- устройства FRAD (Frame Relay Access Device).\n
Также как и в сети X.25, основу Frame Relay составляют виртуальные каналы (virtual circuits). Виртуальный канал в сети Frame Relay представляет собой логическое соединение, создаваемое между двумя устройствами DTE в сети Frame Relay и используемое для передачи данных.\n
В сети Frame Relay используется два типа виртуальных каналов — коммутируемые (SVC) и постоянные (PVC).\n
Коммутируемые виртуальные каналы представляют собой временные соединения, предназначенные для передачи импульсного трафика между двумя устройствами DTE в сетях Frame Relay. Процесс передачи данных с использованием SVC состоит из четырёх последовательных фаз:\n
- установление вызова (Call Setup) — на этом этапе организуется виртуальное соединение между двумя DTE;\n
- передача данных (Data Transfer) — непосредственная передача данных;\n
- ожидание (Idle) — передача данных через уже существующее виртуальное соединение не производится; если период ожидания превысит установленное значение, соединение может быть завершено автоматически;\n
- завершение вызова (Call Termination) — выполняются операции, необходимые для завершения соединения.\n
Постоянные каналы представляют собой постоянное соединение, обеспечивающее информационный обмен между двумя DTE-устройствами. Процесс передачи данных по каналу PVC имеет всего две фазы: передача данных и ожидание.\n
Для обозначения виртуальных каналов в сети Frame Relay используются идентификаторы DLCI (Data-Link Connection Identifier), выполняющие ту же роль, что и номера логического канала в сетях X.25. DLCI определяет номер виртуального порта для процесса пользователя.\n
В технологии Frame Relay задействуются протоколы только на физическом и канальном уровнях. Протокол физического уровня описывается весьма распространенным стандартом I.430/431.\n
Протоколом канального уровня в Frame Relay является LAP-F — весьма упрощенная версия протокола LAP-D, описывающего взаимодействие соседних узлов либо как процедуру без установления соединения, либо как процедуру с установлением соединения без подтверждения.\n
На остальных уровнях могут работать протоколы любых сетей с коммутацией пакетов. В частности, с технологией Frame Relay хорошо согласуются стек протоколов TCP/IPи протоколы сети Х.25.\n
Протокол LAP-F в сетях Frame Relay имеет два режима работы: основной и управляющий. В основном режиме кадры передаются без преобразования и контроля, как в обычных коммутаторах. Поэтому достигается высокая производительность, тем более, что подтверждения передачи не требуется.
Упрощена и процедура передачи пакетов из локальных сетей: они просто вкладываются в кадры канального уровня, а не в пакеты сетевого уровня, как в Х.25.\n
Кадр протокола Frame Relay содержит минимально необходимое количество служебных полей. Его формат, реализованный в соответствии с протоколом HDLC, показан ниже.\n
флаг — 1байт	Заголовок кадра — 2 байта	Данные	FCS — 2 байта	флаг — 1 байт\n
В поле заголовка кадра размещается информация, используемая для управления виртуальными соединениями и процессами передачи данных в сети (в частности, поле адреса, содержащее адреса сетевых узлов источника и получателя кадра).\n
Поле данных в кадре Frame Relay имеет переменную длину (но не более 8000 байтов, большинство сетей Frame Relay работает с кадрами длиной 1024 байта) и предназначено для переноса блоков данных протоколов верхних уровней. Поле FCS содержит 16-разрядную контрольную сумму всех полей кадра Frame Relay, за исключением поля «флаг».\n
Проверка достоверности преобразования информации в сетях Frame Relay должна выполняться, как уже упоминалось, на верхних уровнях управления. В этом отношении технология Frame Relay подобна основным технологиям локальных сетей, таким как Ethernet, Token Ring, FDDI, которые тоже искаженные кадры не корректируют, а просто выбрасывают.\n
Поддержка «качества обслуживания» обеспечивается выполнением заказа качества обслуживания, в котором указывается согласованная скорость передачи данных (Committed Information Rate) и некоторые дополнительные параметры: гарантируемый объем передаваемых данных (committed burst size) и не гарантируемый объем передаваемых данных (excess burst size). Если пользователь сам нарушает согласованную скорость ввода информации в сеть, кадр с такой информацией получает низший приоритет обслуживания и ему не гарантируется качество обслуживания, он может быть даже выброшен из сети в случае перегрузки последней.\n\n
CIR и EIR \n
CIR (англ. Committed Information Rate) — гарантированная полоса пропускания виртуального канала PVC в сетях FR.\n
В первоначальном наборе стандартов (ANSI T1S1) CIR как отдельный параметр отсутствует, но для отдельного виртуального канала были определены параметры B(c) (bits committed, Committed Burst Size), B(e) (bits excess) и T(c) (Committed Rate Measurement Interval). B(c) при этом определяется как количество бит, гарантированно передаваемых за время T(c) даже при перегрузке сети, B(e) — максимальное количество бит, которые могут быть переданы за время T(c) при недогрузке сети, то есть без гарантии доставки: заголовки пакетов, отправляемые после превышения B(c) метятся битом DE (discard eligible, аналогичен CLP в ATM) и в случае возникновения в сети перегрузки уничтожаются на коммутаторах перегруженного участка.\n
Таким образом, для виртуального канала могут быть определены две полосы пропускания:\n
•	CIR=B(c)/T(c) — гарантированная полоса пропускания;\n
•	EIR=B(e)/T(c) — максимальная негарантированая полоса пропускания (добавляется возможный дополнительный объем трафика).\n
Возможна настройка и работа FR-каналов со значением CIR, равным нулю.\n
В ANSI T1S1 значение T(c) не было определено, так как значения T(c), B(c) и B(e) являются связанными параметрами, зависящими от скоростей физических интерфейсов, агрегированных полос пропускания виртуальных каналов, размеров буферов FR-коммутатора и других параметров, зависящих от реализации и настроек коммутатора.\n
Однако CIR и EIR оказались удобными показателями для описания параметров каналов при заключении соглашений между операторами FR-сетей и потребителями их услуг, более того, во многих случаях T(c) может динамически пересчитываться в зависимости от характера трафика, поэтому в RFC 3133 (Terminology for Frame Relay Benchmarking) CIR является первичным параметром и T(c) определяется как временной интервал, необходимый для поддержания CIR, то есть T(c)=B(c)/CIR, выступая в качестве аналога TCP Sliding Window.\n
В сетевых технологиях при множественном доступе к разделяемому каналу с двухуровневой приоритизацией (некоторые беспроводные и спутниковые сети и т. д.) также используют термин CIR для приоритезируемой клиентской полосы пропускания, при этом CIR является одним из целевых параметров конфигурации шейперов (shapers) — подсистем сглаживания трафика с буферизацией (RFC 2963, A Rate Adaptive Shaper for Differentiated Services), в этом случае вместо EIR используется комбинация параметров MIR (Maximum Information Rate) и PIR (Peak Information Rate).\n\n

Виртуальные каналы\n
Для передачи данных от отправителя к получателю в сети Frame Relay создаются виртуальные каналы, VC (англ. Virtual Circuit), которые бывают двух видов:\n
•	постоянный виртуальный канал, PVC (Permanent Virtual Circuit), который создаётся между двумя точками и существует в течение длительного времени, даже в отсутствие данных для передачи;\n
•	коммутируемый виртуальный канал, SVC (Switched Virtual Circuit), который создаётся между двумя точками непосредственно перед передачей данных и разрывается после окончания сеанса связи\n
</item>
        <!--64-->
        <item>64.ТЕХНОЛОГИЯ ATM. ОПИСАНИЕ ТЕХНОЛОГИИ, ОСНОВНЫЕ ПРИНЦИПЫ. ПРИНЦИП ОРГАНИЗАЦИИ СОЕДИНЕНИЯ В СЕТЯХ ATM. СКОРОСТЬ ПЕРЕДАЧИ. ТИПЫ ATM ТРАФИКА.\n\n\n
ATM (англ. Asynchronous Transfer Mode — асинхронный способ передачи данных) — сетевая высокопроизводительная технология коммутации и мультиплексирования пакетов. Пакеты представляют собой ячейки (англ. cell) фиксированного размера в 53 байта, где первые 5 байт используются под заголовок. Является разновидностью быстрой коммутации пакетов (англ. fast packet switching).\n
ATM лучше приспособлен для предоставления услуг передачи данных с сильно различающимся или изменяющимся битрейтом.\n\n
ATM-сеть включает в себя следующие компоненты:\n
• ATM-коммутаторы - устройства, обеспечивающие передачу сообщений, содержащих информацию управления или информацию пользователей. Взаимодействие между ATM-коммутаторами осуществляется в соответствии с интерфейсом «сеть - сеть» NNI (Network to Network Interface);\n
• магистральные каналы связи - линии связи и аппаратура передачи данных между АТМ-коммутаторами;\n
• каналы доступа - линии связи и аппаратура передачи данных между АТМ-коммутаторами и терминальным оборудованием пользователей, подключённых к сети ATM. В качестве терминального оборудования пользователей могут выступать персональные компьютеры, маршрутизаторы и коммутаторы ЛВС, терминалы и др. Взаимодействие терминального оборудования пользователей с АТМ-коммутаторами осуществляется в соответствии с интерфейсом «пользователь - сеть» UNI (User to Network Interface). Взаимодействие ATM-сети с сетями, построенными на базе других технологий, обеспечивается специальными устройствами, называемыми АТМ-шпюзами.\n\n
Сеть ATM реализует трёхуровневый стек протоколов, включающий в себя: уровень адаптации, уровень ATM и физический уровень, соответствующие первым трём уровням модели ЭМВОС. Протоколы стека сети ATM обеспечивают транспортные функции передачи сообщений, содержащих информацию пользователей и информацию управления.\n
 Основной функцией уровня адаптации стека протоколов сети ATM является формирование сервисных блоков данных(Service Data Units, SDU), содержащих блоки данных, сформированные протоколами транспортного уровня модели ЭМВОС. Сервисные блоки данных имеют 48-байтовую длину и выступают в роли информационных единиц уровня адаптации. Если длина блока данных транспортного уровня, поступающего на уровень адаптации, превышает 48 байт, то он фрагментируется на несколько сервисных блоков данных на уровне адаптации.\n
Функции уровня ATM включают в себя:\n
• формирование ячеек(cells) - информационных единиц уровня ATM - на основе сервисных блоков данных, сформированных на уровне адаптации. Длина каждой ячейки составляет 53 байта, из которых 5 байт занимает заголовок ячейки, а 48 байт - поле данных. Поскольку все ячейки имеют одну и ту же длину, ATM-коммутаторы могут заранее определить их расположение в потоке поступающих данных, что значительно сокращает время их обработки и передачи через сеть ATM;\n
• коммутацию ячеек на основе числовых идентификаторов коммутируемого и постоянного виртуального соединения, содержащихся в полях заголовка ячеек. Идентификаторы виртуальных соединений формируются на основе протоколов вышележащих уровней, не входящих в стек протоколов сети ATM.\n
Физический уровень стека протоколов сети АТМ определяет механические, электрические и функциональные характеристики каналов доступа и магистральных каналов связи, по которым передаются ячейки.\n
Технология ATM не предусматривает обязательное наличие системы управления сетью ATM. Для реализации системы управления необходимо включить в состав ATM-сети ЦУС, предназначенный для управления ATM-коммутаторами, а также снабдить программно-аппаратное обеспечение ATM-коммутаторов дополнительными функциями, способными обеспечить взаимодействие коммутаторов с ЦУС. Система управления сети ATM может быть реализована при помощи функций семи уровней модели ЭМВОС. На первых трёх уровнях системы управления используются протоколы стека сети ATM, обеспечивающие функции транспортной среды передачи сообщений, содержащих информацию управления. На транспортном, сеансовом, представительском и прикладном уровнях в ЦУС и АТМ-коммутаторах формируются и обрабатываются сообщения, содержащие информацию управления. Одной из функций системы управления сети ATM является установление и закрытие постоянных виртуальных соединений.\n\n
Основные принципы технологии ATM\n
Глобальные сети (Wide Area Networks, WAN), которые также называются территориальными компьютерными сетями, служат для того, чтобы предоставлять свои сервисы большому количеству абонентов, разбросанных по большой территории. Ввиду большой протяженности каналов связи построение глобальной сети требует очень больших затрат, в которую входят стоимость кабелей и работ по их прокладке, затраты на коммутационное оборудование и промежуточную усилительную аппаратуру, обеспечивающую необходимую полосу пропускания канала, а также эксплутационные затраты на постоянное поддержание в работоспособном состоянии разбросанной по большой территории аппаратуры сети.\n
Типичными абонентами глобальной компьютерной сети является локальные сети предприятий, расположенные в разных городах и странах, которым нужно обмениваться данными между собой. Услугами глобальных сетей пользуются также и отдельные компьютеры. Крупные компьютеры класса мэйнфреймов обычно обеспечивают доступ к корпоративным данным, в то время как персональные компьютеры используются для доступа к корпоративным данным и публичным данным Internet. Широкое распространение корпоративных сетей, которое сегодня стало очевидной тенденцией, приводит к существенным изменениям в архитектуре объединенных вычислительных сетей, в том числе Интернета.\n
Сегодняшние корпоративные вычислительные сети изначально возникли как островки локальных сетей, связанные друг с другом тоненькими мостиками межсетевых коммуникаций. Простая магистраль Ethernet с небольшой полосой пропускания вполне удовлетворяла тем требованиям, которые предъявлялись к ней при таком взаимодействии между сетями. Однако по мере того, как все большая часть информации и услуг сосредотачивалась на мощных централизованных серверах, перегруженные маршрутизаторы сетевой магистрали превратились в ее самое узкое место и начали существенно ограничивать взаимодействие между сетями.\n
Альтернативой технологии Ethernet является технология асинхронного режима передачи (Asynchronous Transfer Mode, АТМ), разработанная как единый универсальный транспорт для нового поколения сетей с интеграцией услуг, которые называются широкополосными сетями ISDN. Технология АТМ с самого начала разрабатывалась как технология, способная обслужить все виды трафика в соответствии с их требованиями.\n
По планам разработчиков единообразие, обеспечиваемое АТМ, будет состоять в том, что одна транспортная технология сможет обеспечить несколько перечисленных ниже возможностей.\n
•	Передачу в рамках одной транспортной системы компьютерного и мультимедийного (голос, видео) трафика, чувствительного к задержкам, причем для каждого вида трафика качество обслуживания будет соответствовать его потребностям.\n
•	Иерархию скоростей передачи данных, от десятков мегабит до нескольких гигабит в секунду с гарантированной пропускной способностью для ответственных приложений.\n
•	Общие транспортные протоколы для локальных и глобальных сетей.\n
•	Сохранение имеющейся инфраструктуры физических каналов или физических протоколов: T1/E1, T3/E3, SDH STM-n, FDDI.\n
•	Взаимодействие с унаследованными протоколами локальных и глобальных сетей: IP, SNA, Ethernet, ISDN.\n
Сеть ATM имеет классическую структуру крупной территориальной сети - конечные станции соединяются индивидуальными каналами с коммутаторами нижнего уровня, которые в свою очередь соединяются с коммутаторами более высоких уровней. Коммутаторы ATM пользуются 20-байтными адресами конечных узлов для маршрутизации трафика на основе техники виртуальных каналов. Для частных сетей ATM определен протокол маршрутизации PNNI (Private NNI), с помощью которого коммутаторы могут строить таблицы маршрутизации автоматически. В публичных сетях AТМ таблицы маршрутизации могут строиться администраторами вручную, как и в сетях Х.25, или могут поддерживаться протоколом PNNI.\n
Коммутация пакетов происходит на основе идентификатора виртуального канала (Virtual Channel Identifier, VCI), который назначается соединению при его установлении и уничтожается при разрыве соединения. Адрес конечного узла ATM, на основе которого прокладывается виртуальный канал, имеет иерархическую структуру, подобную номеру в телефонной сети, и использует префиксы, соответствующие кодам стран, городов, сетям поставщиков услуг и т. п., что упрощает маршрутизацию запросов установления соединения, как и при использовании агрегированных IP-адресов в соответствии с техникой CIDR. Виртуальные соединения могут быть постоянными (Permanent Virtual Circuit, PVC) и коммутируемыми (Switched Virtual Circuit, SVC). Для ускорений коммутации в больших сетях используется понятие виртуального пути - Virtual Path, который объединяет виртуальные каналы, имеющие в сети ATM общий маршрут между исходным и конечным узлами или общую часть маршрута между некоторыми двумя коммутаторами сети. Идентификатор виртуального пути (Virtual Path Identifier, VPI) является старшей частью локального адреса и представляет собой общий префикс для некоторого количества различных виртуальных каналов. Таким образом, идея агрегирования адресов в технологии ATM применена на двух уровнях - на уровне адресов конечных узлов (работает на стадии установления виртуального канала) и на уровне номеров виртуальных каналов (работает при передаче данных по имеющемуся виртуальному каналу).\n
Соединения конечной станции ATM с коммутатором нижнего уровня определяются стандартом UNI (User Network Interface). Спецификация UNI определяет структуру пакета, адресацию станций, обмен управляющей информацией, уровни протокола ATM, способы установления виртуального канала и способы управления трафиком. В настоящее время принята версия UNI4.0, но наиболее распространенной версией, поддерживаемой производителями оборудования,является версия UNI 3.1.\n
Стандарт ATM не вводит свои спецификации на реализацию физического уровня. Здесь он основывается на технологии SDH/SONET, принимая ее иерархию скоростей. В соответствии с этим начальная скорость доступа пользователя сети - это скорость ОС-3 155 Мбит/с. Организация ATM Forum определила для ATM не все иерархии скоростей SDH, а только скорости ОС-З и ОС-12 (622 Мбит/с). На скорости 155 Мбит/с можно использовать не только волоконно-оптический кабель, но и неэкранированную витую пару категории 5. На скорости 622 Мбит/с допустим только волоконно-оптический кабель, причем как SMF, так и MMF. Имеются и другие физические интерфейсы к сетям ATM, отличные от SDH/SONET. К ним относятся интерфейсы Т1/Е1 и ТЗ/ЕЗ, распространенные в глобальных сетях, и интерфейсы локальных сетей - интерфейс с кодировкой 4В/5В со скоростью 100 Мбит/с (FDDI) и интерфейс со скоростью 25 Мбит/с, предложенный компанией IBM и утвержденный ATM Forum. Кроме того, для скорости 155,52 Мбит/с определен так называемый "cell-based" физический уровень, то есть уровень, основанный на ячейках, а не на кадрах SDH/SONET. Этот вариант физического уровня не использует кадры SDH/SONET, а отправляет по каналу связи непосредственно ячейки формата ATM, что сокращает накладные расходы на служебные данные, но несколько усложняет задачу синхронизации приемника с передатчиком на уровне ячеек.\n
Технологии ATM не свидетельствуют о том, что это некая "особенная" технология, а скорее представляют ее как типичную технологию глобальных сетей, основанную на технике виртуальных каналов. Особенности же технологии ATM лежат в области качественного обслуживания разнородного трафика и объясняются стремлением решить задачу совмещения в одних и тех же каналах связи и в одном и том же коммуникационном оборудовании компьютерного и мультимедийного трафика таким образом, чтобы каждый тип трафика получил требуемый уровень обслуживания и не рассматривался как "второстепенный".\n\n
Очевидно, что только качественных характеристик, задаваемых классом трафика, для описания требуемых услуг оказывается недостаточно. В технологии ATM для каждого класса трафика определен набор количественных параметров, которые приложение должно задать. Например, для трафика класса А необходимо указать постоянную скорость, с которой приложение будет посылать данные в сеть, а для трафика класса В - максимально возможную скорость, среднюю скорость и максимально возможную пульсацию. Для голосового трафика можно не только указать на важность синхронизации между передатчиком и приемником, но и количественно задать верхние границы задержки и вариации задержки ячеек.\n
В технологии ATM поддерживается следующий набор основных количественных параметров:\n
•	Peak Cell Rate (PCR) - максимальная скорость передачи данных;\n
•	Sustained Cell Rate (SCR) - средняя скорость передачи данных;\n
•	Minimum Cell Rate (MCR) - минимальная скорость передачи данных;\n
•	Maximum Burst Size (MBS) - максимальный размер пульсации;\n
•	Cell Loss Ratio (CLR) - доля потерянных ячеек;\n
•	Cell Transfer Delay (CTD) - задержка передачи ячеек;\n
•	Cell Delay Variation (CDV) - вариация задержки ячеек.\n
Параметры скорости измеряются в ячейках в секунду, максимальный размер пульсации - в ячейках, а временные параметры - в секундах. Максимальный размер пульсации задает количество ячеек, которое приложение может передать с максимальной скоростью PCR, если задана средняя скорость. Доля потерянных ячеек является отношением потерянных ячеек к общему количеству отправленных ячеек по данному виртуальному соединению. Так как виртуальные соединения являются дуплексными, то для каждого направления соединения могут быть заданы разные значения параметров.\n
В технологии ATM принят не совсем традиционный подход к трактовке термина "качество обслуживания" - QoS. Обычно качество обслуживания трафика характеризуется параметрами пропускной способности (здесь это RCR, SCR, MCR, MBS), параметрами задержек пакетов (CTD и CDV), а также параметрами надежности передачи пакетов (CLR). В ATM характеристики пропускной способности называют параметрами трафика и не включают их в число параметров качества обслуживания QoS, хотя по существу они таковыми являются. Параметрами QoS в ATM являются только параметры CTD, CDV и CLR. Сеть старается обеспечить такой уровень услуг, чтобы поддерживались требуемые значения и параметров трафика, и задержек ячеек, и доли потерянных ячеек.\n
В случае насыщения пропускной способности для сохранения минимальной задержки ATM может отбрасывать отдельные ячейки при насыщении. Реализация стратегии отбрасывания ячеек зависит от производителя оборудования ATM, но в общем случае обычно отбрасываются ячейки с низким приоритетом (например, данные) для которых достаточно просто повторить передачу без потери информации. Коммутаторы ATM с расширенными функциями могут при отбрасывании ячеек, являющихся частью большого пакета, обеспечить отбрасывание и оставшихся ячеек из этого пакета - такой подход позволяет дополнительно снизить уровень насыщения и избавиться от излишнего объема повторной передачи. Правила отбрасывания ячеек определяются QoS.\n
Соглашение между приложением и сетью ATM называется трафик-контрактом. Основным его отличием от соглашений, применяемых в сетях frame relay, является выбор одного из нескольких определенных классов трафика, для которого наряду с параметрами пропускной способности трафика могут указываться параметры задержек ячеек, а также параметр надежности доставки ячеек. В сети frame relay класс трафика один, и он характеризуется только параметрами пропускной способности. Необходимо подчеркнуть, что задание только параметров трафика (вместе с параметрами QoS) часто не полностью характеризует требуемую услугу, поэтому задание класса трафика полезно для уточнения нужного характера обслуживания данного соединения сетью.\n
В некоторых случаях специфика приложения такова, что ее трафик не может быть отнесен к одному из четырех стандартных классов. Поэтому для этого случая введен еще один класс X, который не имеет никаких дополнительных описаний, а полностью определяется теми количественными параметрами трафика и QoS, которые оговариваются в трафик-контракте.\n
Если для приложения не критично поддержание параметров пропускной способности и QoS, то оно может отказаться от задания этих параметров, указав признак "Best Effort" в запросе на установление соединения. Такой тип трафика получил название трафика с неопределенной битовой скоростью - Unspecified Bit Rate, UBR. После заключения трафик-контракта, который относится к определенному виртуальному соединению, в сети ATM работает несколько протоколов и служб, обеспечивающих нужное качество обслуживания. Для трафика UBR сеть выделяет ресурсы по возможности, то есть те, которые в данный момент свободны от использования виртуальными соединениями, заказавшими определенные параметры качества обслуживания.\n
Технология ATM изначально разрабатывалась для поддержки как постоянных, так и коммутируемых виртуальных каналов (в отличие от технологии frame relay, долгое время не поддерживающей коммутируемые виртуальные каналы). Автоматическое заключение трафик-контракта при установлении коммутируемого виртуального соединения представляет собой весьма непростую задачу, так как коммутаторам ATM необходимо определить, смогут ли они в дальнейшем обеспечить передачу трафика данного виртуального канала наряду с трафиком других виртуальных каналов таким образом, чтобы выполнялись требования качества обслуживания каждого канала.\n

</item>
        <!--65-->
        <item>65.ЧТО ТАКОЕ SDH. ОПИСАНИЕ ТЕХНОЛОГИИ. СКОРОСТЬ ПЕРЕДАЧИ. ЧТО ТАКОЕ РАССИНХРОНИЗАЦИЯ ГЕНЕРАТОРОВ И КАК ОНА ВЛИЯЕТ НА КОЛИЧЕСТВО ОШИБОК. ЧТО ТАКОЕ МУЛЬТИПЛЕКСОРЫ И ДЕМУЛЬТИПЛЕКСОРЫ. ЗАЧЕМ ОНИ.\n\n
Синхронная цифровая иерархия (СЦИ: англ. SDH — Synchronous Digital Hierarchy, SONET) — это система передачи данных, основанная на синхронизации по времени передающего и принимающего устройства. Стандарты СЦИ определяют характеристики цифровых сигналов, включая структуру фреймов (циклов), метод мультиплексирования, иерархию цифровых скоростей и кодовые шаблоны интерфейсов и т. д.\n
Технология SDH (Synchronous Digital Hierarchy) обозначает стандарт для транспорта трафика. Стандарт определяет уровни скорости прохождения сигнала синхронного транспортного модуля (Synchronous Transport Module, STM).\n
Стандарт также определяет физический (оптический) уровень, необходимый для совместимости оборудования от различных производителей.
Основная скорость передачи - 155,250 Мбит/с (STM-1). Более высокие скорости определяются как кратные STM-1: STM-4 - 622 Мбит/с, STM-16 - 2488,32 Мбит/с, STM-64 - 9953,28 Мбит/с.\n
Технология предполагает использование метода временного мультиплексирования (TDM) и кросс-коммутации тайм-слотов. При этом оконечное оборудование SDH оперирует потоками E1 (2,048 Мбит/с), к которым подключается клиентское оборудование. Основными устройствами сети являются SDH-мультиплексоры.\n
Важной особенностью сетей SDH является необходимость синхронизации временных интервалов трафика между всеми элементами сети. Обычно мультиплексор может синхронизироваться с любым внешним сигналом, с опорным тактовым сигналом (PRC) или с собственным внутренним генератором синхронизирующих импульсов. Синхронизация на основе опорного тактового сигнала может распространяться по цепи, в которой находится не более 20 сетевых элементов (G.803).\n
Выбор источника синхронизации может осуществляться либо автоматически под управлением программы, либо задаваться оператором.\n
При построении сетей SDH обычно используется топология сети типа «кольцо» с двумя контурами. По одному из контуров передается синхронизирующая и сигнальная информация, по другому - основной трафик. Имеются специальные механизмы резервирования сети на случай выхода из строя одного из контуров. Возможно также подключение устройств по топологии «точка-точка», однако в таком случае отказоустойчивость решения будет ниже.\n
Централизованное управление сетью обеспечивает полный мониторинг состояния каналов и узлов (мультиплексоров). Использование кольцевых топологий создает возможность автоматического переключения каналов при любых аварийных ситуациях на резервный путь. Оборудование SDH предусматривает возможность резервирования линии и основных аппаратных блоков по схеме 1+1, при аварии автоматически переключая трафик на резервное направление. Данное свойство значительно повышает «живучесть» сети и позволяет проводить различного типа технологические работы без перерыва трафика.\n
Управление конфигурацией сети, отслеживание и регистрация аварийных ситуаций осуществляются программными средствами с единой консоли управления. В функции центральной управляющей системы входят также средства поддержки тестирования каналов и контроля за качеством работы основных блоков мультиплексоров.\n
Сеть на базе SDH может служить в качестве транспортной сети для большинства существующих технологий высокоскоростной передачи информации по оптическим сетям (в том числе ATM и POS).\n
Существующее сегодня оборудование SDH способно передавать информацию со следующими линейными скоростями: 155 Мбит/c (STM-1), 622 Мбит/c (STM-4), 2,5 Гбит/c (STM-16). При этом для подключения пользователям предлагаются интерфейсы E1-E3.\n
Функционально мультиплексор SDH имеет два набора интерфейсов: пользовательский и агрегатный. Пользовательский набор отвечает за подключение пользователей, а агрегатный - за создание линейных межузловых соединений.\n
Данные интерфейсы позволяют создавать следующие базовые топологии: «кольцо», «цепочка», «точка-точка».\n
Из указанных базовых элементов складывается топология всей сети мультиплексоров. Сложные сети обычно имеют многоуровневую структуру. Первый уровень - оборудование доступа пользователей. Этот уровень состоит из оборудования «последней мили» и, как правило, из мультиплексоров STM-1. Оборудование «последней мили» отвечает за доведение сигнала пользователей (чаще - сигнала E1, E3) до мультиплексоров первого уровня. В роли оборудования «последней мили» обычно выступают так называемые оптические модемы, по сути являющиеся конверторами электрического сигнала в оптический и обратно. Мультиплексоры первого уровня собирают каналы пользователей для дальнейшей транспортировки. Следующий уровень могут составлять мультиплексоры уровня STM-4 и STM-16.\n\n
Основные преимущества технологии SDH:\n
•	простая технология мультиплексирования/демультиплексирования;\n
•	доступ к низкоскоростным сигналам без необходимости мультиплексирования/демультиплексирования всего высокоскоростного канала. Это позволяет достаточно просто осуществлять подключение клиентского оборудования и производить кросс-коммутацию потоков;\n
•	наличие механизмов резервирования на случай отказов каналов связи или оборудования;\n
•	возможность создания «прозрачных» каналов связи, необходимых для решения определенных задач, например для передачи голосового трафика между выносами АТС или передачи телеметрии;\n
•	возможность наращивания решения;\n
•	совместимость оборудования от различных производителей;\n
•	относительно низкие цены оборудования;\n
•	быстрота настройки и конфигурирования устройств.\n\n
Недостатки технологии SDH:\n
•	использование одного из каналов полностью под служебный трафик;\n
•	неэффективное использование пропускной способности каналов связи. Сюда относятся как необходимость резервирования полосы на случай отказов, так и особенности технологии TDM, не способной динамически выделять полосу пропускания под различные приложения, а также отсутствие механизмов приоритезации трафика;\n
•	необходимость использовать дополнительное оборудование (зачастую от других производителей), чтобы обеспечить передачу различных типов трафика (данные, голос) по опорной сети.\n\n
Технологию SDH можно рекомендовать для использования в задачах построения опорных сетей при следующих условиях:\n
•	загрузка каналов далека от предельной;\n
•	имеется необходимость предоставлять «прозрачные» каналы связи, например для передачи голосового трафика между АТС;\n
•	в коммерческом плане более выгодно и удобно предоставлять клиентам каналы с фиксированной пропускной способностью, а не определять стоимость услуг по количеству переданного трафика и по качеству предоставляемого сервиса.\n\n
Существующее сегодня оборудование SDH способно передавать информацию со следующими линейными скоростями: 155 Мбит/c (STM-1), 622 Мбит/c (STM-4), 2,5 Гбит/c (STM-16). При этом для подключения пользователям предлагаются интерфейсы E1-E3.\n\n
Мультиплексором называются комбинационные устройство, обеспечивающее передачу в желаемом порядке цифровой информации, поступающей по нескольким входам на один выход. Мультиплексоры обозначают через MUX (от англ. multiplexor), а также через MS (от англ. Multiplexor selector). Схематически мультиплексор можно изобразить в виде коммутатора, обеспечивающего подключение одного из нескольких входов (их называют информационными) к одному выходу устройства. Кроме информационных входов в мультиплексоре имеются адресные входы и, как правило, разрешающие (стробирующие). Сигналы на адресных входах определяют, какой конкретно информационный канал подключен к выходу. Если между числом информационных входов n и число адресных входов m действуют соотношение n =2m, то такой мультиплексор называют полным. Если n&lt;2m, то мультиплексор называют неполным.\n
Количество мультиплексируемых входов называется количеством каналов мультиплексора, а количество выходов называется числом разрядов мультиплексора.\n
Число каналов мультиплексоров, входящих в стандартные серии, составляет от 2 до 16, а число разрядов — от 1 до 4, при чём чем больше каналов имеет мультиплексор, тем меньше у него разрядов.\n
Управление работой мультиплексора (выбор номера канала) осуществляется с помощью входного кода адреса. Например, для 4 — канального мультиплексора необходим 2 — разрядный управляющий (адресный) код, а для 16 — канального — 4 разрядный код. Разряды кода обозначаются 1, 2, 4, 8 или А0, А1, A2, А3. Мультиплексоры бывают с выходом 2С и с выходом 3С. Выходы мультиплексоров бывают прямыми и инверсивными. Выход 3С позволяет объединить выходы мультиплексоров с выходами других микросхем, а также получать двунаправленные и мультиплексированные линии.
УГО мультиплексора, имеющего 8 информационных входов, 3 адресных входа, вход разрешения V, и два выхода (прямой инверсный).\n
 При V = 1 мультиплексор блокируется.\n
Вход разрешения V используется для расширения функциональных возможностей мультиплексора, например, позволяет увеличивать число коммутируемых информационных входов:\n
 Два 8 — канальных мультиплексора объединены в 16 — ти канальный. Старший разряд А3 выбирает один из 2 — ух мультиплексоров.\n
Расширение разрядности мультиплексоров в общем случае реализуется их каскадным включением:\n
Мультиплексорное дерево содержит четыре четырёхвходовых мультиплексора MUX1 — MUX4 c запараллеленными адресными входами А0, А1, которыми одновременно выбирается один из входов всех четырёх элементов, а мультиплексор MUX5 кодом на адресных входах А2, А3 выбирает один из выходов Y0 — Y3. Таким образом, четырёхразрядный код на входах А0 — А3соединяется с входом только один из 16 входов (16 =24) D0 — D15.\n\n
Демультиплексором называют устройство, в котором сигналы с одного информационного входа поступают в желаемой последовательности по нескольким выходам в зависимости от кода на адресных шинах. Таким образом, демультиплексор в функциональном отношении противоположен мультиплексору. Демультиплексоры обозначают через DMX или DMS.\n
 При использовании КМОП — технологии можно построить двунаправленные ключи, которые обладают возможностью пропускать ток в обоих направлениях и передавать не только цифровые, но и аналоговые сигналы. Благодаря этому можно строить мультиплексоры — демультиплексоры, которые могут использоваться либо как мультиплексоры, либо как демультиплексоры. Мультиплексоры — демультиплексоры обозначаются через MX.\n
</item>
        <!--66-->
        <item>66.ОПТИЧЕСКИЕ ПРИЕМОПЕРЕДАТЧИКИ. ИХ ПРЕИМУЩЕСТВА И НЕДОСТАТКИ. ПРОПУСКНАЯ СПОСОБНОСТЬ.\n\n\n
Оптический передатчик (англ. optical transmitter) — устройство, преобразующее входной электрический сигнал в выходной оптический сигнал, предназначенный для передачи по оптической передающей среде.\n
Оптические передатчики содержат источники оптического излучения и устройства, осуществляющие модуляцию оптического излучения в соответствии с управляющим электрическим сигналом. По способу модуляции оптические передатчики делятся на передатчики с прямой (внутренней) и внешней модуляцией.\n
В оптических передатчиках с прямой модуляцией мощность излучения источника света модулируется электрическим током питания. Важнейшее достоинство таких передатчиков — простота конструкции. Недостатками передатчиков с прямой модуляцией являются ограниченное быстродействие (скорость передачи информации в цифровых системах связи) и возможность использования только одного параметра (мощности) световой волны для модуляции. В качестве источников излучения в передатчиках с прямой модуляцией используются светодиоды или лазеры с прямой модуляцией.\n
В оптических передатчиках с внешней модуляцией непрерывное оптическое излучение модулируется внешним модулятором, управляемым информационным электрическим сигналом. Источниками излучения в таких передатчиках, как правило, являются узкополосные одномодовые непрерывные полупроводниковые лазеры: РОС-лазеры или РБО-лазеры.\n
Это обеспечивает формирование оптического сигнала с минимальной шириной спектра. Кроме того, в передатчиках с внешней модуляцией для кодирования информации наряду с модуляцией амплитуды (мощности) используется модуляция и других параметров световых волн: фазы, частоты и поляризации, а также их комбинации. Передатчики с внешней модуляцией используются в системах дальней связи, в которых требования к качеству оптического сигнала максимальны. Наиболее широко используемыми в системах связи типами модуляторов являются модуляторы Маха-Цандера и электроабсорбционные модуляторы.\n
В системах связи со спектральным мультиплексированием (DWDM) используются передатчики с перестраиваемой длиной волны излучения. Для увеличения мощности оптического сигнала в состав оптических передатчиков могут быть включены оптические усилители.
Передатчики цифровых волоконно-оптических систем связи часто изготавливаются в одном корпусе с приёмниками, образуя приёмопередающие оптические модули, или транспондеры.\n\n
Оптическое волокно с каждым днем набирает все большую популярность как среда для передачи информации. Это обусловлено множеством преимуществ по сравнению с медными парами. Рассмотрим основные преимущества и недостатки оптических волокон.\n\n
Преимущества оптических волокон:\n
1.	Помехозащищенность.\n
Никакие виды электромагнитных  помех не влияют на качество передачи информации в оптическом волокне.  Благодаря этому, оптическое волокно может располагаться вблизи таких мощных источников электромагнитных помех как: радиоантенны, неоновая реклама, оборудование АТС (особенно декадно шаговых), станки на заводах и др. Кроме того, многие ЛЭП уже имеют в своем составе ВОЛС, вмонтированную в грозо трос.\n
2.	Вследствие того, что оптическое волокно не проводит электрический сигнал, то обеспечивается полная гальваническая развязка между  передатчиком и приемником. Это облегчает схема технику канало образующего оборудования.\n
3.	Электро магнитная совместимость и информационная безопасность\n
Оптическое волокно не только не чувствительно к внешним электро магнитным воздействиям, но и само не излучает никаких сигналов в окружающую среду. Последнее существенно усложняет перехват информации, которая передается по оптическому волокну. Для того, чтобы перехватить информацию, необходимо удалить слой за слоем оболочку оптического кабеля до самого оптического волокна. (см рисунок 1). Далее необходимо изогнуть оптическое волокно, после чего часть сигнала будет выходить за пределы волокна. Эта часть излучения и может быть перехвачена. Вместе с тем, этот изгиб (макро изгиб) оптического волокна легко зафиксировать при помощи оптического рефлектометра. В отличии от этого, подняв в неподходящий момент трубку домашнего аналогового (если у кого-то остался) телефона можно случайно «подслушать» соседа, или послушать радио.\n
Такой способ «врезки» в оптическое волокно активно используется связистами для организации служебного канала связи. В качестве устройства для ответвления трафика в этом случае используются ответвители-прищепки.\n
4.	Оптическое волокно имеет малое погонное затухание. Уровень затухания сигнала зависит от рабочей длины волны, но он имеет намного меньшие значения чем медный кабель. Вследствие этого, возможна организация протяженных высокоскоростных систем передачи. (Например, применение одного оптического усилителя позволяет передавать цифровую информацию со скоростью до 10 Гбит/с на расстояние до 250 км.)\n
5.	Оптические волокна имеют большую широкополосность и пропускную способность. Благодаря улучшенной очистке оптического волокна, удалось расширить количество окон прозрачности, что привело к появлению систем волнового уплотнения WDM (СWDM, DWDM. DWDM мультиплексирование  позволяет по одному оптическому волокну организовать до 160 независимых каналов передачи, в каждом из которого передавать информацию со скоростью до 40 а то и больше Гбит/с.\n
6.	Оптические кабели имеют меньшие габариты и вес, а зачастую и стоимость.\n\n
Недостатки оптических волокон\n
Основным недостатком оптических волокон являются повышенные требования к обслуживающему персоналу как на этапе монтажа оптического кабеля, так и в ходе обслуживания. Львиная доля повреждений в ВОЛС как раз и связана с недостатком знаний и навыков по работе с активными и пассивными компонентами ВОЛС. Среди основных проблем, которые допускаются по незнанию или халатности можно выделить грязные коннекторы и макро изгибы.\n
 Еще одним недостатком является появление микротрещин и повышение затухания оптического волокна за счет водородной коррозии. Распространенным заблуждением является утверждение, что оптическое волокно не боится попадания воды в оптическую муфту.\n
</item>
        <!--67-->
        <item>67.СИСТЕМА СЕРТИФИКАТОВ. ЧТО ТАКОЕ И ЗАЧЕМ ЭЛЕКТРОННЫЙ СЕРТИФИКАТ. ИЕРАРХИЯ ЦЕНТРОВ СЕРТИФИКАЦИИ.\n\n
Цифровой сертификат — выпущенный удостоверяющим центром электронный или печатный документ, подтверждающий принадлежность владельцу открытого ключа или каких-либо атрибутов.\n
Сертификат открытого ключа (цифровой сертификат) – это электронный или бумажный документ, содержащий открытый (публичный) ключ, а так же информацию о владельце ключа позволяющую его однозначно идентифицировать.\n
Кроме этого сертификат содержит сведения о периоде действия, назначении ключа, серийный номер, информацию о центре сертификации и т.д., в зависимости от формата и версии.\n
Центр сертификации (также встречается термин поставщик сертификатов) (Certification Authority, CA) представляет собой службу, которой доверен выпуск сертификатов, если индивидуальный пользователь или организация, которые запрашивают сертификат, удовлетворяют условиям установленной политики. Это осуществляется путем принятия запроса на получение сертификата, проверки и регистрации имени запрашивающего сертификат пользователя и открытого ключа в соответствии с политикой. Каждый ЦС должен получить от запрашивающей сертификат стороны подтверждение ее идентичности, такое как удостоверение личности или физический адрес.\n
Центры сертификации также имеют собственные сертификаты. Причем вышестоящий центр подписывает сертификаты для нижестоящих центров. Таким образом, формируется иерархия сертификатов (certificate hierarchy).\n
Доверие центру сертификации устанавливается при наличии копии корневого сертификата в хранилище доверяемых корневых центров сертификации, а также действительного пути к сертификату. Это означает, что ни один из сертификатов иерархии (пути сертификатов) не был отозван и не имеет истекшего срока действия.\n
Если в организации используется Active Directory, то доверие к центрам сертификации вашей организации устанавливается автоматически на основе решений и установок, выполненных системным администратором.\n
Сертификат удостоверяет, что индивидуальный пользователь или ЦС, представляющий сертификат, был авторизован в соответствии с политикой, которая была установлена для ЦС, выпустившего сертификат. Обычно сертификаты содержат следующую информацию:\n
§ открытый ключ (public key) владельца сертификата;\n
§ идентификационную информацию владельца сертификата;\n
§ период действия сертификата;\n
§ информацию о центре сертификации;\n
§ цифровую подпись (digital signature).\n
Все сертификаты имеют ограниченный срок действия. Даты начала и окончания срока действия сертификата указываются в сертификате. Для каждого ЦС устанавливается политика обновления сертификатов с истекшим сроком действия.\n
</item>
    </string-array>
</resources>